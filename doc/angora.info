This is ../../angora-src/doc/angora.info, produced by makeinfo version
4.8 from ../../angora-src/doc/angora.texi.

INFO-DIR-SECTION Electromagnetic Simulation
START-INFO-DIR-ENTRY
* Angora: (angora).           A finite-difference time-domain (FDTD) electromagnetic simulation software.
END-INFO-DIR-ENTRY

   Copyright (C) 2012 I.lker R. C,apog(lu

   Portions of the `libconfig' manual were copied verbatim. The
`libconfig' library is distributed under the GNU Lesser Public License,
which can be found at
`http://www.hyperrealm.com/libconfig/libconfig_manual.html#License'.


File: angora.info,  Node: Top,  Next: Getting Started,  Up: (dir)

Angora: A finite-difference time-domain simulation package
**********************************************************

This is the user's guide for Angora, a software package that computes
numerical solutions to electromagnetic radiation and scattering
problems. It is based on the finite-difference time-domain (FDTD)
method, which one of the most popular approaches for solving Maxwell's
equations of electrodynamics.

* Menu:

* Getting Started::    A quick example: Scattering from a sphere.
* Downloading::    How to download Angora.
* Compilation and Installation::    How to compile and install Angora.
* Execution::    How to execute Angora.
* Configuration Format::    The text format for specifying simulation variables.
* Configuration Variables::    How to configure Angora for a simulation.
* References::    Bibliographic references cited in this manual.
* Indices::    Concept and variable indices.


File: angora.info,  Node: Getting Started,  Next: Downloading,  Prev: Top,  Up: Top

1 Getting Started
*****************

Angora simulations are run by constructing a text file, called the
_configuration file_ that specifies all aspects of the simulation. This
file is then given as a command-line option to the Angora executable
`angora'; which reads the configuration file and produces the desired
output (see *Note Execution::).

   Let's start with a simple example. In the following, we will show
how Angora can be used to solve the problem of electromagnetic
scattering from a sphere illuminated by a plane wave.  The geometry of
the scattering problem is shown graphically in the printed manual.

   We start by creating a configuration file; say `sph_sc.cfg'. This
file will be populated by configuration options listed in the
following. Some basic parameters of our simulation are determined by
the following lines (see *Note Grid Properties:: for details):

     dx = 20e-9;
     courant = 0.98;
     grid_dimension_x = 1e-6;
     grid_dimension_y = 1e-6;
     grid_dimension_z = 1e-6;
     pml_thickness_in_cells = 5;
     num_of_time_steps = 1500;

   The first variable, `dx', is the uniform spatial step size in the
FDTD discretization. The second variable, `courant', is the ratio of
the time step to the maximum time step allowable by the Courant
condition. The next three variables determine the physical size of the
simulation grid in meters. The thickness of the absorbing layer (PML)
is determined by the `pml_thickness_in_cells' variable. The last line
specifies the number of time steps in the simulation.

   The sphere from which the electromagnetic plane wave will be
scattered is created in two steps. First, we define a spherical "shape
object" using the `Spheres' variable (see *Note Spheres::):
     Shapes:
     {
         Spheres:
         (
             {
                 shape_tag = "mysphere";
                 center_coord_x = 0;
                 center_coord_y = 0;
                 center_coord_z = 0;
                 radius = 320e-9;
             }
         );
     };
   Next, the material filling the sphere is defined using the
`Materials' variable (see *Note Materials::):
     Materials:
     (
         {
             material_tag = "sph_mat";
             rel_permittivity = 2.25;
             electric_conductivity = 3e4; //in Siemens/m
             rel_permeability = 1.7;
             magnetic_conductivity = 4.2578e9; //in Ohm/m
         }
     );
   The shape and material definitions are then combined in the
`Objects' variable, and the sphere is placed in the grid (see *Note
Objects::):
     SimulationSpace:
     {
         Objects:
         (
             {
                 material_tag = "sph_mat";
                 shape_tag = "mysphere";
             }
         );
     };
   With the above defitions, we have created a sphere of radius 320 nm
and made of the material specified by `"sph_mat"'. Next, we define the
waveform of the incident plane wave using the `Waveforms' variable:
     Waveforms:
     {
         ModulatedGaussianWaveforms:
         (
             {
                 waveform_tag = "mywaveform";
                 modulation_type = "sine";
                 tau = 2.12662e-15;
                 f_0 = 5.88878e14;
             }
         );
     };
   We then create the plane wave incident from the -z direction with
the above waveform as its electric field using the `PlaneWaves'
variable (see *Note Plane Waves::):
     TFSF:
     {
         PlaneWaves:
         (
             {
                 theta = 180;
                 phi = 0;
                 psi = 90;
                 waveform_tag = "mywaveform";
             }
         );
     };
   Finally, we create a near-field-to-far-field transformer to
calculate the scattered field in the far zone using the
`PhasorDomainNFFFT' variable (see *Note Near-Field-to-Far-Field
Transformer::):
     PhasorDomainNFFFT:
     (
         {
             num_of_lambdas = 1;
             lambda_min = 509.09e-9;
             lambda_max = 509.1e-9;
             direction_spec = "theta-phi";
             num_of_dirs_1 = 360;
             dir1_min = 0;
             dir1_max = 360;
             num_of_dirs_2 = 1;
             dir2_min = 0;
             dir2_max = 0;
         }
     );
   With the above definitions, the far field is calculated at the
free-space wavelength 509.1 nm, and 360 equally-spaced angles on the xz
plane. The output of the near-field-to-far-field transformer is in HDF5
format, which can be read and manipulated using freely-available tools.
For more information, see *Note Near-Field-to-Far-Field Transformer::.
The scattered electric field is shown in a polar plot in the printed
manual.


File: angora.info,  Node: Downloading,  Next: Compilation and Installation,  Prev: Getting Started,  Up: Top

2 Downloading
*************

Angora is currently only available for the *GNU/Linux operating
system*. If you would like to port Angora to another operating system,
please contact us at <capoglu@angorafdtd.org>. Contributions are always
welcome.

   The latest version of Angora can be found at `http://angorafdtd.org'
in source code format, as well as binary format for x86_64 GNU/Linux
systems.


File: angora.info,  Node: Compilation and Installation,  Next: Execution,  Prev: Downloading,  Up: Top

3 Compilation and Installation
******************************

If you will be using Angora on a 64-bit x86 architecture with the
GNU/Linux operating system, you can simply download the binary version
(both non-parallel and OpenMPI-based parallel versions available) from
the Angora website and start running simulations right away. After
extracting the `tar' file, the compiled `angora' executable can be
found under the `bin' directory. The full documentation and other
utilites (MATLAB scripts, template configuration file, etc.) are also
provided in the binary distributions under the `share' directory.

   If there is no precompiled Angora binary available for your system,
you will have to compile it from source. You will require the the
following libraries on your system to compile Angora: blitz++
(http://www.oonumerics.org/blitz/), libconfig
(http://www.hyperrealm.com/libconfig/), hdf5
(http://www.hdfgroup.org/HDF5/), and boost (http://www.boost.org/). If
possible, use the package manager for your specific GNU/Linux
distribution (such as Synaptic in Ubuntu) to install the libraries
directly from the package repository. Most major distributions provide
these libraries in their package repositories. If you do not have root
access to your system, you can install these libraries in your home
directory. The installation instructions for the libraries usually
provide detailed information on how to do this. For local installation,
the usual trick is to set the installation path by specifying the
`prefix' variable in the `Makefile's. This is done either by using the
`--prefix=LOCAL-PATH' option when calling the package's `configure'
script, or customizing `make' at the final stage with the
`prefix=LOCAL-PATH' command option.

   Once the dependency libraries are installed, the Angora package is
ready for compilation. Extract the package
`angora-PACKAGE-VERSION.tar.gz' using `tar', and enter the created
directory:

     johndoe@mysystem:~$ tar xvf angora-PACKAGE-VERSION.tar.gz
     johndoe@mysystem:~$ cd angora-PACKAGE-VERSION

   Run the `configure' script in this directory to create the
`Makefile's required to build the package:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ ./configure

   If any of the dependency libraries was installed in a local
directory, then add the option
`--with-LIBRARY-NAME=LOCAL-PATH-TO-LIBRARY' to the above command line.
For example, if the `blitz++' library was installed in
`/home/johndoe/blitz-0.9', then the option to add is
`--with-blitz=/home/johndoe/blitz-0.9'. Type `./configure --help' in
the directory `angora-PACKAGE-VERSION' for information on specifying
the paths to the other dependency libraries.

   After the `configure' script finishes execution, compile and install
Angora using the `make' command:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ make

   If your system has multiple cores, you can speed up the compilation
by executing `make' in parallel. For example, you can use all 4 cores
of your system by typing, instead of the above line,

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ make -j 4

   This might take a couple of minutes, depending on your system. After
`make' finishes, the executable `angora' will be located in the
directory `angora-PACKAGE-VERSION'. If you wish to _install_ the
package globally so that it can be run from anywhere, type

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ sudo make install

   Obviously, this requires super-user privileges on your system. By
default, the package is installed in `/usr/local'; so the binary will
reside in `/usr/local/bin'. If you don't have super-user privileges,
you can install Angora in a local directory `full-path-to-inst-dir' by
typing

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ make prefix=FULL-PATH-TO-INST-DIR install

   The location `full-path-to-inst-dir' should be an absolute path.
After this, the binary `angora' will be located in the directory
`full-path-to-inst-dir/bin/'.

* Menu:

* Enabling MPI Support::    Compiling Angora with MPI support.
* Building the Documentation::    Building the Angora documentation.


File: angora.info,  Node: Enabling MPI Support,  Next: Building the Documentation,  Up: Compilation and Installation

3.1 Enabling MPI Support
========================

Parallel execution on multiple processors or cores is supported by
Angora, provided that the MPI (Message Passing Interface) libraries are
installed on your system (e.g., OpenMPI (http://www.open-mpi.org/) or
MPICH2 (http://www.mcs.anl.gov/research/projects/mpich2/) or other). A
precompiled binary version of Angora based on the OpenMPI
implementation is available on the Angora website.

   If you are compiling Angora from source, you'll have to enable the
MPI feature at compile time. This feature is _disabled_ by default. You
can enable MPI functionality in Angora by adding the option
`--with-mpi' to the `configure' command line:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ ./configure --with-mpi

   For more information on launching Angora simulations on multiple
processors or cores using MPI, *note Parallel Execution::.


File: angora.info,  Node: Building the Documentation,  Prev: Enabling MPI Support,  Up: Compilation and Installation

3.2 Building the Documentation
==============================

The GNU `info' documentation for Angora is automatically built and
installed by `make'. If you have the texi2html
(http://www.mathematik.uni-kl.de/~obachman/Texi2html/) and latex2html
(http://www.latex2html.org/) utilities installed, you can create an
HTML version of the Angora documentation by typing

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ make html

   If you have the `texi2dvi' command available (provided as part of
the GNU Texinfo (http://www.gnu.org/software/texinfo/) package), you
can also build a PDF version of the Angora documentation by typing

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ make pdf

   Once built, both the HTML and PDF versions of the documentation will
be located in the subdirectory `doc/'.


File: angora.info,  Node: Execution,  Next: Configuration Format,  Prev: Compilation and Installation,  Up: Top

4 Execution
***********

Angora operates by reading a text file, called the "configuration
file", that specifies the details of the simulation. Every aspect of
the simulation is configured by a related "configuration variable" (or
"variable" in short) in the configuration file; which comprises either
a single line or a number of lines. In general, an Angora simulation is
run by putting the name of the configuration file pertaining to the
simulation as a command line option when calling the `angora'
executable:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ ./angora PATH-TO-CONFIG-FILE

   If the Angora executable is run without any command-line options, it
looks for the configuration file named `angora.cfg' in the same
directory from which the executable is run. *Note Configuration
Variables::, for details on configuration files.

* Menu:

* Parallel Execution::    Parallel execution using MPI libraries.
* Check Mode::    Checking for errors in the configuration file.


File: angora.info,  Node: Parallel Execution,  Next: Check Mode,  Up: Execution

4.1 Parallel Execution
======================

If Angora is compiled with MPI support, then the standard MPI launcher
(`mpirun') can be used to execute the Angora binary `angora' in
parallel:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ mpirun -n NUM-OF-PROCESSORS ./angora PATH-TO-CONFIG-FILE

   For example, to run the simulation configured by `mysimulation.cfg'
using Angora version `0.9' on 8 processors, one should type

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ mpirun -n 8 ./angora mysimulation.cfg

   MPI support should be enabled in compile time in order to run
simulations in parallel. For details, *note Enabling MPI Support::. If
you are using the OpenMPI-based precompiled binary version of Angora,
then the OpenMPI shared libraries must be in your path before the
binary `angora' can be executed. This can either be done by installing
OpenMPI globally (using a package manager etc.), or adding the path to
the OpenMPI shared libraries to your `LD_LIBRARY_PATH' environment
variable.


File: angora.info,  Node: Check Mode,  Prev: Parallel Execution,  Up: Execution

4.2 Check Mode
==============

Angora can check a configuration file for syntactic and semantic
errors, without actually running the simulation. To do this, simply run
Angora with the `--check' or `-c'option:

     johndoe@mysystem:~/angora-PACKAGE-VERSION$ ./angora --check PATH-TO-CONFIG-FILE

   This reports any errors in the configuration-file syntax or invalid
configuration options (see *Note Template Configuration File::). The
actual size of the simulation does not have any effect on this
operation; therefore it can be run on a single processor with little
memory.


File: angora.info,  Node: Configuration Format,  Next: Configuration Variables,  Prev: Execution,  Up: Top

5 Configuration Format
**********************

Angora uses the libconfig (http://www.hyperrealm.com/libconfig/)
library to read configuration variables regarding the simulation from a
text file. The text file, called the "configuration file", has to
conform to the libconfig grammar; which is explained in greater detail
at `http://www.hyperrealm.com/libconfig/libconfig_manual.html'. Here,
we will provide the minimum information necessary to write
configuration files for Angora simulations.

* Menu:

* Variable Assignment::    Assignment format for simulation variables.
* Variable Types::    Types of values that can be assigned to simulation variables.


File: angora.info,  Node: Variable Assignment,  Next: Variable Types,  Up: Configuration Format

5.1 Variable Assignment
=======================

A variable in a configuration file is set using the following
assignment:

     NAME=VALUE;

   or:

     NAME:VALUE;

   The trailing semicolon is required. Whitespace is not significant.
Here, NAME is the name of the variable, and VALUE is its value; which
may be a scalar value, an array, a group, or a list. *Note Variable
Types::, for information on these value types.

   The order in which variables are specified in the configuration file
is insignificant, except within the `SimulationSpace' variable (*note
Simulation Space::). The sub-variables of the `SimulationSpace'
variable are processed in the order of appearance in the configuration
file. This is necessary because the user needs to be able to control
the order in which objects are placed in the grid, and predict the
regions within an object that will be overwritten by another object.


File: angora.info,  Node: Variable Types,  Prev: Variable Assignment,  Up: Configuration Format

5.2 Variable Types
==================

Angora simulation variables can be assigned C++-type "scalar" values,
as well as more complex values of type "group", "array", and "list".
The latter types are defined by the libconfig library. Some of the text
in this section is copied verbatim from the libconfig manual
(http://www.hyperrealm.com/libconfig/libconfig_manual.html). The
`libconfig' library, along with its documentation, is distributed under
the GNU Lesser Public License
(http://www.hyperrealm.com/libconfig/libconfig_manual.html#License).

* Menu:

* Integer Values::
* Floating-Point Values::
* Boolean Values::
* String Values::
* Groups::
* Arrays::
* Lists::
* Comments::
* Include Directives::


File: angora.info,  Node: Integer Values,  Next: Floating-Point Values,  Up: Variable Types

5.2.1 Integer Values
--------------------

Integers can be represented in one of two ways: as a series of one or
more decimal digits (`0' - `9'), with an optional leading sign
character (`+' or `-'); or as a hexadecimal value consisting of the
characters `0x' followed by a series of one or more hexadecimal digits
(`0' - `9', `A' - `F', `a' - `f').

   Examples:

     n_sx = 3;
     offset = -4;
     address = 0xFFFF;


File: angora.info,  Node: Floating-Point Values,  Next: Boolean Values,  Prev: Integer Values,  Up: Variable Types

5.2.2 Floating-Point Values
---------------------------

Floating point values consist of a series of one or more digits, one
decimal point, an optional leading sign character (`+' or `-'), and an
optional exponent. An exponent consists of the letter `E' or `e', an
optional sign character, and a series of one or more digits.

   Except in special circumstances, floating-point values in Angora are
read and processed in `double' precision, which corresponds to roughly
15 decimal digits.

   Examples:

     f = 1.0;
     origin = -3e-6;
     prefactor = 5E10;


File: angora.info,  Node: Boolean Values,  Next: String Values,  Prev: Floating-Point Values,  Up: Variable Types

5.2.3 Boolean Values
--------------------

Boolean values may have one of the following values: `true', `false',
or any mixed-case variation thereof.

   Examples:

     include_first_value = true;
     include_last_value = FaLsE;


File: angora.info,  Node: String Values,  Next: Groups,  Prev: Boolean Values,  Up: Variable Types

5.2.4 String Values
-------------------

String values consist of arbitrary text delimited by double quotes.
Literal double quotes can be escaped by preceding them with a
backslash: `\"'. The escape sequences `\\', `\f', `\n', `\r', and `\t'
are also recognized, and have the usual meaning.

   In addition, the `\x' escape sequence is supported; this sequence
must be followed by exactly two hexadecimal digits, which represent an
8-bit ASCII value. For example, `\xFF' represents the character with
ASCII code 0xFF.

   No other escape sequences are currently supported.

   Adjacent strings are automatically concatenated, as in C/C++ source
code. This is useful for formatting very long strings as sequences of
shorter strings. For example, the following constructs are equivalent:

   * `"The quick brown fox jumped over the lazy dog."'

   * `"The quick brown fox"'
     `" jumped over the lazy dog."'

   * `"The quick" /* comment */ " brown fox " // another comment'
     `"jumped over the lazy dog."'



File: angora.info,  Node: Groups,  Next: Arrays,  Prev: String Values,  Up: Variable Types

5.2.5 Groups
------------

A group has the form:

     {
        NAME=VALUE;
        OTHER_NAME=OTHER_VALUE;
        ...
     }

   Notice the curly brackets `{}' around the variable assignments.
Groups can contain any number of variable assignments (see *Note
Variable Assignment::), but each variable must have a unique name
within the group.

   Example:

     {
         shape_tag = "mysphere";
         center_coord_x = 5e-6;
         center_coord_y = 5e-6;
         center_coord_z = 5e-6;
         radius = 4e-6;
     }


File: angora.info,  Node: Arrays,  Next: Lists,  Prev: Groups,  Up: Variable Types

5.2.6 Arrays
------------

An array has the form:

     [ VALUE, VALUE, ... ]

   Notice the square brackets `[]' delimiting the comma-separated
values. An array may have zero or more elements, but the elements must
all be *scalar* values of the *same type*.

   Examples:

     disabled_runs = [0,1,3];
     output_variables = ["Ex","Ey"];


File: angora.info,  Node: Lists,  Next: Comments,  Prev: Arrays,  Up: Variable Types

5.2.7 Lists
-----------

A list has the form:

     ( VALUE, VALUE, ... )

   Notice the parantheses `()' delimiting the comma-separated values. A
list may have zero or more elements, each of which can be a scalar
value, an array, a group, or another list. The values in a list can be
of _different types_; however, in Angora, the list type is exclusively
used to contain a collection of _group_ values. In Angora, the list
type  semantically represents a collection of objects, each with a
collection of properties set within their respective group value. Here
is an example:

     Materials:
     (
         {
             material_tag = "mat1";
             rel_permittivity = 2.0;
         },
         {
             material_tag = "mat2";
             rel_permittivity = 2.5;
         }
     );

   Here, the list structure named `Materials' contains two groups (each
delimited by curly brackets `{}') separated by a comma. This defines
two materials with different sets of properties.


File: angora.info,  Node: Comments,  Next: Include Directives,  Prev: Lists,  Up: Variable Types

5.2.8 Comments
--------------

Three types of comments are allowed within a configuration:

   * Script-style comments. All text beginning with a `#' character to
     the end of the line is ignored.

   * C-style comments. All text, including line breaks, between a
     starting `/*' sequence and an ending `*/' sequence is ignored.

   * C++-style comments. All text beginning with a `//' sequence to the
     end of the line is ignored.


   As expected, comment delimiters appearing within quoted strings are
treated as literal text.

     # Here's a comment
     MyGroup:
     (/* This is
         also a comment */
         {
             this_property = "myvalue";
             // Another comment
         }
     );


File: angora.info,  Node: Include Directives,  Prev: Comments,  Up: Variable Types

5.2.9 Include Directives
------------------------

A configuration file may "include" the contents of another file using
an include directive. This directive has the effect of inlining the
contents of the named file at the point of inclusion.

   An include directive must appear on its own line in the input. It has
the form:

     @include "FILENAME"

   Any backslashes or double quotes in the file name must be escaped as
`\\' and `\"', respectively.

   For example, consider the following two configuration files:

     # file: limits.cfg
     back_coord_x = -5e-6;
     front_coord_x = 6e-6;
     left_coord_y = -5e-6;
     right_coord_y = 6e-6;
     lower_coord_z = -3e-6;
     upper_coord_z = 4e-6;

     # file: mysim.cfg
     RectangularBoxes:
     (
         {
             shape_tag = "mybox";
             @include "limits.cfg"
         }
     );

   Include files may be nested to a maximum of 10 levels; exceeding this
limit results in a runtime error.


File: angora.info,  Node: Configuration Variables,  Next: References,  Prev: Configuration Format,  Up: Top

6 Configuration Variables
*************************

The variable assignments (or "settings" in libconfig terminology) in a
configuration file reside either at the uppermost level (called the
"Global" level) or within a group structure (*note Groups::). In the
following, configuration variables will be characterized as either
being a "Global variable", or a "Sub-variable of PARENTVARIABLE"; where
PARENTVARIABLE is the next parent variable upward in the hierarchy that
has a name. The variable PARENTVARIABLE can either be a _group_ or a
_list_ (see *Note Groups:: and *Note Lists::). Quite often, the
immediate parent of a variable assignment is an unnamed group;
therefore the PARENTVARIABLE of that assignment is the list that
contains this unnamed group. For example, the PARENTVARIABLE of the
variable `material_tag' in the example in *Note Lists:: is `Materials',
since its immediate parent is an unnamed group, but the list structure
containing the unnamed group has a name (which is `Materials'). On the
other hand, the variable `Materials' is a "Global variable"; since it
is assigned at the uppermost level in a configuration file, outside any
enclosing structure.

   The configuration variable names are case sensitive; meaning that
`Materials' and `materials' are not the same.

   Angora throws an error message for any missing variable or
misspelled variable name. This is crucial for ensuring that no optional
configuration variable is omitted because of a typo. The valid variable
names are read into the Angora source code in compile time from a
template file `config_all.cfg'. This file, although not required at the
time of execution, is distributed with Angora for reference (see *Note
Template Configuration File::).

* Menu:

* Template Configuration File::    The template file `config_all.cfg' with all possible configuration variables.
* Grid Properties::    Basic properties of the FDTD grid.
* Shapes::    Defining abstract geometrical shapes.
* Materials::    Defining material types.
* Simulation Space::    Specifying the material composition of the simulation space.
* Waveforms::    Defining time waveforms.
* Point Sources::    Defining point (Hertzian) sources.
* Near-Field-to-Far-Field Transformer::    Calculation of the radiated (far-zone) field.
* Optical Imaging::    Calculation of optical images.
* Incident Beams::    Injection of incident beams into the grid.
* Recording::    Movie/line/field-value recording.
* Paths::    Specifying the input and output directories.
* Logging::    Enabling and configuring log output.
* Multiple Simulation Runs::    Configuring the number of consecutive simulations.
* Miscellaneous::    Miscellaneous features.


File: angora.info,  Node: Template Configuration File,  Next: Grid Properties,  Up: Configuration Variables

6.1 Template Configuration File
===============================

A file named `config_all.cfg' is included in the Angora distribution,
which includes all the valid configuration variables. All variables in
a given configuration file are checked against `config_all.cfg' and
labeled invalid if a corresponding variable does not exist in
`config_all.cfg'. It should be stressed, however, that `config_all.cfg'
is *not* necessary for the execution of Angora, but _is_ necessary for
its compilation. This is because `config_all.cfg' is read into the
source code of Angora in the compilation stage. The file
`config_all.cfg' is only distributed as a reference for the user's
convenience.

   The file `config_all.cfg' is installed in the directory
`$(prefix)/share/angora/' (see *Note Compilation and Installation::).
If Angora was installed without any `$(prefix)' configuration option,
the default location is `/usr/local/share/angora/'.


File: angora.info,  Node: Grid Properties,  Next: Shapes,  Prev: Template Configuration File,  Up: Configuration Variables

6.2 Grid Properties
===================

Angora currently only supports a rectangular, Cartesian FDTD grid with
equal grid spacing in the x, y, and z directions. Mesh refinement is
not yet supported; therefore the grid spacing is uniform across the
grid.

* Menu:

* Courant Factor::    The ratio between the temporal and spatial step sizes.
* Spatial Step Size::    The spatial step size in the FDTD grid.
* Grid Dimensions::    The number of FDTD cells in the x, y, and z directions.
* Perfectly-Matched Layer (PML)::    Absorbing layers for grid termination.
* Number of Time Steps::    Number of time steps in the simulation.
* Coordinate Origin::    Origin of the coordinate system.
* Dynamic Range::    The maximum field value and the useful dB dynamic range in the simulation.


File: angora.info,  Node: Courant Factor,  Next: Spatial Step Size,  Up: Grid Properties

6.2.1 Courant Factor
--------------------

 -- Global variable: floating-point courant
     Angora adopts a slightly modified form for the Courant factor,
     defined as

     sqrt(3)*c*D_t/D_x

     where c=299792458 m/s is the speed of light in vacuum, and D_t and
     D_x are the _temporal_ and _spatial_ step sizes (see *Note Spatial
     Step Size::). The Courant factor should be less than `1.0' for
     stability. A common value for `courant' is `0.98'.


File: angora.info,  Node: Spatial Step Size,  Next: Grid Dimensions,  Prev: Courant Factor,  Up: Grid Properties

6.2.2 Spatial Step Size
-----------------------

 -- Global variable: floating-point dx (units: m)
     The spatial step size in the FDTD grid is specified by the `dx'
     variable. Currently only cubic FDTD cells are supported; therefore
     the spatial step sizes in the x, y, and z direction are all
     determined by `dx'.


File: angora.info,  Node: Grid Dimensions,  Next: Perfectly-Matched Layer (PML),  Prev: Spatial Step Size,  Up: Grid Properties

6.2.3 Grid Dimensions
---------------------

 -- Global variable: floating-point grid_dimension_x (units: m)

 -- Global variable: floating-point grid_dimension_y (units: m)

 -- Global variable: floating-point grid_dimension_z (units: m)

 -- Global variable: integer grid_dimension_x_in_cells

 -- Global variable: integer grid_dimension_y_in_cells

 -- Global variable: integer grid_dimension_z_in_cells
     These variables determine the size of the Cartesian FDTD grid. The
     dimensions of the grid can be specified either in meters, or in
     grid cells. For the latter, the `_in_cells' suffix should be
     appended to the variable name. If the dimensions are given in
     meters, the number of FDTD cells in the Cartesian FDTD grid in the
     x, y, and z directions are rounded to the closest integer. If no
     perfectly-matched layers are specified (see *Note
     Perfectly-Matched Layer (PML)::), the total number of FDTD cells
     in the three-dimensional FDTD grid is equal to
     (grid_dimension_x_in_cells) x (grid_dimension_y_in_cells) x
     (grid_dimension_z_in_cells).


File: angora.info,  Node: Perfectly-Matched Layer (PML),  Next: Number of Time Steps,  Prev: Grid Dimensions,  Up: Grid Properties

6.2.4 Perfectly-Matched Layer (PML)
-----------------------------------

 -- Global variable: floating-point pml_thickness (units: m)

 -- Global variable: integer pml_thickness_in_cells
     This variable sets the thickness of the perfectly-matched layers
     (PMLs) around the grid in all directions. Further customization of
     the PML thickness is not yet supported. The thickness can be
     specified either in meters, or in grid cells. For the latter, the
     `_in_cells' suffix should be appended to the variable name.

     Typical PML thicknesses are `5' to `10' grid cells. If you do not
     want to place a PML layer around the grid, just assign
     `pml_thickness=0'. Without a PML layer, the boundary of the FDTD
     grid acts as a perfect electric conductor (PEC). Other boundary
     conditions (perfect magnetic conductor, periodic, etc.) will also
     be supported in the future.

     With a PML definition, the total number of FDTD cells in the
     three-dimensional FDTD grid becomes

     (grid_dimension_x_in_cells+2*pml_thickness_in_cells)

     x (grid_dimension_y_in_cells+2*pml_thickness_in_cells)

     x (grid_dimension_z_in_cells+2*pml_thickness_in_cells)

     The computational burden per FDTD cell associated with the PML
     layer is roughly three times that of the main grid.

     Angora implements the convolution PML (CPML) formulation of the
     complex-frequency shifted (CFS) PML (see *Note Roden00::; *Note
     Kuzuoglu96::.)

 -- Global variable: floating-point cpml_feature_size (units:m,
          default:
          `max(grid_dimension_x,grid_dimension_y,grid_dimension_z)')

 -- Global variable: floating-point cpml_feature_size_in_cells
          (default:
          `max(grid_dimension_x_in_cells,grid_dimension_y_in_cells,grid_dimension_z_in_cells)')
     This variable specifies the maximum size of the scattering or
     radiating structure in the FDTD grid. This size can be specified
     either in meters, or in grid cells. For the latter, the
     `_in_cells' suffix should be appended to the variable name.

     This information is used to determine the frequency-shifting
     parameter _alpha_ in the CFS-PML formulation. Following Berenger's
     derivation (see *Note Berenger02::), this parameter is defined as

     alpha = c*eps/w

     where c is the velocity of propagation in the medium, _eps_ is the
     absolute permittivity (in F/m) in the medium, and _w_ is the
     maximum size of the structure.

     The above relationship follows essentially from the low-frequency
     behavior of the CFS-PML. At low frequencies where the evanescent
     field around the structure dominates, the CFS-PML reduces to a
     real stretch of coordinates without any absorption. This helps the
     termination of evanescent fields, which are poorly handled by
     ordinary PMLs.


File: angora.info,  Node: Number of Time Steps,  Next: Coordinate Origin,  Prev: Perfectly-Matched Layer (PML),  Up: Grid Properties

6.2.5 Number of Time Steps
--------------------------

 -- Global variable: integer num_of_time_steps
     This variable determines the number of time steps in the FDTD
     simulation.


File: angora.info,  Node: Coordinate Origin,  Next: Dynamic Range,  Prev: Number of Time Steps,  Up: Grid Properties

6.2.6 Coordinate Origin
-----------------------

 -- Global variable: floating-point origin_x (units:m, default:
          (grid_dimension_x+2*pml_thickness)/2+1)

 -- Global variable: floating-point origin_y (units:m, default:
          (grid_dimension_y+2*pml_thickness)/2+1)

 -- Global variable: floating-point origin_z (units:m, default:
          (grid_dimension_z+2*pml_thickness)/2+1)

 -- Global variable: integer origin_x_in_cells (default:
          (grid_dimension_x_in_cells+2*pml_thickness_in_cells)/2+1)

 -- Global variable: integer origin_y_in_cells (default:
          (grid_dimension_y_in_cells+2*pml_thickness_in_cells)/2+1)

 -- Global variable: integer origin_z_in_cells (default:
          (grid_dimension_z_in_cells+2*pml_thickness_in_cells)/2+1)
     These variables set the origin of the coordinate system in the
     simulation. All other coordinates in a configuration file are
     taken as relative to this origin. The coordinates can be specified
     either in meters, or in grid cells. For the latter, the
     `_in_cells' suffix should be appended to the variable name. These
     three numbers represent the Cartesian coordinates of the origin
     from the back-left-lower corner of the grid.  See printed manual
     for a graphical illustration.

     If the coordinates are given in meters, they are rounded to the
     closest integer multiple of the spatial step size (*note Spatial
     Step Size::).


File: angora.info,  Node: Dynamic Range,  Prev: Coordinate Origin,  Up: Grid Properties

6.2.7 Dynamic Range
-------------------

The following two variables are only relevant in movie recording (see
*Note Movie Recording::), wherein the floating-point field values on
the movie frames are sometimes discretized to fit into 1 byte.

 -- Global variable: floating-point max_field_value (default: `1.0')
     This value specifies the maximum field value used in the
     discretization for 1-byte movie recording (*note Movie
     Recording::).

 -- Global variable: floating-point dB_accuracy (default: automatic)
     This value specifies the dynamic range (in dB) to be used in the
     discretization for 1-byte movie recording (*note Movie
     Recording::). For example,

          dB_accuracy = -60;

     tells Angora to discretize the field values in a dynamic range
     between the maximum field value (specified by `max_field_value'
     above) and 60dB below that value. If `dB_accuracy' is not
     specified, Angora tries to set this value automatically, based on
     its best guess on the useful accuracy range in the simulation.
     This value can also be read from the output of the movie recorder
     (*note Movie Recording::).


File: angora.info,  Node: Shapes,  Next: Materials,  Prev: Grid Properties,  Up: Configuration Variables

6.3 Shapes
==========

 -- Global variable: group Shapes
     In Angora, a geometrical shape and the material filling that shape
     are two distinct and independent elements of the definition of an
     object. The first of these elements is defined in the `Shapes'
     variable, which is a group (*note Groups::).

          Shapes:
          {
              RectangularBoxes:
              (
                  ...
                  ...
              );
              Spheres:
              (
                  ...
                  ...
              );

              ...
              ...

          };

     In this example, two sub-variables `RectangularBoxes' and
     `Spheres' of the `Shapes' group are shown. These are both list
     variables (*note Lists::).

   Currently, rectangular boxes and spheres are the only basic shape
classes defined in Angora. Unions, intersections, and geometrical
transformations of shapes, as well as more basic shape classes will be
added to Angora in the future. Please send any comments, suggestions,
and requests to <help@angorafdtd.org>.

* Menu:

* Rectangular Boxes::
* Spheres::


File: angora.info,  Node: Rectangular Boxes,  Next: Spheres,  Up: Shapes

6.3.1 Rectangular Boxes
-----------------------

 -- Sub-variable of Shapes: group RectangularBoxes
     Rectangular boxes are defined using the `RectangularBoxes'
     variable, which is a list structure under the `Shapes' group.

          Shapes:
          {
              RectangularBoxes:
              (
                  {
                      shape_tag = "mybox";
                      back_coord_x = -5e-6;
                      front_coord_x = 6e-6;
                      left_coord_y = -5e-6;
                      right_coord_y = 6e-6;
                      lower_coord_z = -3e-6;
                      upper_coord_z = 4e-6;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

     In this example, two rectangular box shapes are defined in two
     respective unnamed groups; only the first being shown in complete
     detail.

      -- Sub-variable of RectangularBoxes: string shape_tag
          This string variable assigns a _name_ to the particular
          shape, so it can be referred to later in the configuration
          file.

      -- Sub-variable of RectangularBoxes: floating-point back_coord_x
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point front_coord_x
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point left_coord_y
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point right_coord_y
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point lower_coord_z
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point upper_coord_z
               (units: m)

      -- Sub-variable of RectangularBoxes: floating-point
     back_coord_x_in_cells

      -- Sub-variable of RectangularBoxes: floating-point
     front_coord_x_in_cells

      -- Sub-variable of RectangularBoxes: floating-point
     left_coord_y_in_cells

      -- Sub-variable of RectangularBoxes: floating-point
     right_coord_y_in_cells

      -- Sub-variable of RectangularBoxes: floating-point
     lower_coord_z_in_cells

      -- Sub-variable of RectangularBoxes: floating-point
     upper_coord_z_in_cells
          These variables determine the minimum and maximum Cartesian
          coordinates of the box in the x, y, and z directions relative
          to the grid origin (*note Coordinate Origin::). The units are
          either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.



File: angora.info,  Node: Spheres,  Prev: Rectangular Boxes,  Up: Shapes

6.3.2 Spheres
-------------

 -- Sub-variable of Shapes: group Spheres
     Spheres are defined using the `Spheres' variable, which is a list
     structure under the `Shapes' group.

          Shapes:
          {
              Spheres:
              (
                  {
                      shape_tag = "mysphere";
                      center_coord_x = 5e-6;
                      center_coord_y = 5e-6;
                      center_coord_z = 5e-6;
                      radius = 4e-6;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

     In this example, two spherical shapes are defined in two
     respective unnamed groups; only the first being shown in complete
     detail.

      -- Sub-variable of Spheres: string shape_tag
          This string variable assigns a _name_ to the particular
          shape, so it can be referred to later in the configuration
          file.

      -- Sub-variable of Spheres: floating-point center_coord_x (units:
               m)

      -- Sub-variable of Spheres: floating-point center_coord_y (units:
               m)

      -- Sub-variable of Spheres: floating-point center_coord_z (units:
               m)

      -- Sub-variable of Spheres: floating-point center_coord_x_in_cells

      -- Sub-variable of Spheres: floating-point center_coord_y_in_cells

      -- Sub-variable of Spheres: floating-point center_coord_z_in_cells
          These variables determine the Cartesian coordinate of the
          center of the sphere relative to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name.

      -- Sub-variable of Spheres: floating-point radius (units: m)

      -- Sub-variable of Spheres: floating-point radius_in_cells
          This variable determines the radius of the sphere. The units
          are either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.



File: angora.info,  Node: Materials,  Next: Simulation Space,  Prev: Shapes,  Up: Configuration Variables

6.4 Materials
=============

Currently, Angora only supports isotropic, non-dispersive materials.
Anisotropic and dispersive materials will also be supported in the
future. Please send any comments, suggestions, and requests to
<help@angorafdtd.org>.

 -- Global variable: list Materials
     The properties of a certain material type are specified in the
     `Materials' list (*note Lists::).
          Materials:
          (
              {
                  material_tag = "this_material";
                  rel_permittivity = 2.0;
                  rel_permeability = 1.0;
                  electric_conductivity = 0.0;
                  magnetic_conductivity = 0.0;
                  transparent = false;
              },
              {
                  ...
                  ...
              }
          );

     In this example, two materials are defined in two respective
     unnamed groups; only the first being shown in complete detail.

      -- Sub-variable of Materials: string material_tag
          This string variable assigns a _name_ to the particular
          material, so it can be referred to later in the configuration
          file.

      -- Sub-variable of Materials: floating-point rel_permittivity
               (default: `1.0')
          This variable specifies the relative permittivity (or the
          dielectric constant) of the material. In SI units, the
          absolute permittivity of the material is this variable
          multiplied by the permittivity of free space (8.85418782E-12
          F/m).

      -- Sub-variable of Materials: floating-point rel_permeability
               (default: `1.0')
          This variable specifies the relative permeability (or the
          magnetic constant) of the material. In SI units, the absolute
          permeability of the material is this variable multiplied by
          the permeability of free space (4piE-7).

      -- Sub-variable of Materials: floating-point
               electric_conductivity (units: S/m) (default: `0')
          This variable specifies the electric conductivity (in
          Siemens/m or Mho/m) of the material.

      -- Sub-variable of Materials: floating-point
               magnetic_conductivity (units: Ohm/m) (default: `0')
          This variable specifies the magnetic conductivity (in Ohm/m)
          of the material.

      -- Sub-variable of Materials: boolean transparent (default:
               `false')
          If set to `false', any unspecified constitutive parameter is
          set to its default value. If set to `true', unspecified
          constitutive parameters become _transparent_, meaning that
          when an object made up of this material is placed in the
          grid, those constitutive parameters are kept unchanged.



File: angora.info,  Node: Simulation Space,  Next: Waveforms,  Prev: Materials,  Up: Configuration Variables

6.5 Simulation Space
====================

 -- Global variable: group SimulationSpace
     The `SimulationSpace' group is where all the objects inside the
     simulation space are defined. If no `SimulationSpace' group is
     specified in the configuration file, the FDTD simulation space
     consists entirely of vacuum.
          SimulationSpace:
          {
              Objects:
              (
                  ...
                  ...
              );
              RandomMaterials:
              {
                  ...
                  ...
              };

              ...
              ...

          };

     In the above example, only two of the sub-variables of the
     `SimulationSpace' group, `Objects' and `RandomMaterials', are
     shown. The sub-variable `Objects' is a list (see *Note Lists::),
     whereas `RandomMaterials' is a group (see *Note Groups::).

     The definitions in the `SimulationSpace' group are processed *in
     the order of placement*. Thus, the user has complete control over
     which object is placed in the simulation space first. As a
     consequence of this first-come-first-serve policy, objects can
     overwrite regions of the simulation space occupied by other
     objects.

* Menu:

* Objects::    Material objects defined as a combination of a `Shapes' object and a `Materials' object.
* Planar Layers::    Planar material layers.
* Random Materials::    Material regions having random material properties with a specified spatial correlation function.
* File Input::    Reading a region of the simulation grid from a file.
* Ground Planes::    Perfectly-conducting planar sheets.


File: angora.info,  Node: Objects,  Next: Planar Layers,  Up: Simulation Space

6.5.1 Objects
-------------

 -- Sub-variable of SimulationSpace: list Objects
     The `Objects' list defines material objects to be placed in the
     simulation grid. An _object_ in this context is defined as a
     combination of two abstract ingredients: A previously-defined
     shape (see *Note Shapes::), and a previously-defined material to
     fill that shape (see *Note Materials::). The shape and material
     are referred to using their shape and material tags, which are
     string variables assigned to them in their definitions.

     Here is an example:

          SimulationSpace:
          {
              Objects:
              (
                  {
                      material_tag = "this_material";
                      shape_tag = "mysphere";
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of Objects: string material_tag
          This string variable specifies the material that makes up the
          object. It should match a previously-defined tag in a
          `Materials' definition (*note Materials::).

      -- Sub-variable of Objects: string shape_tag
          This string variable specifies the geometrical shape of the
          object. It should match a previously-defined tag in a
          `Shapes' definition (*note Shapes::).



File: angora.info,  Node: Planar Layers,  Next: Random Materials,  Prev: Objects,  Up: Simulation Space

6.5.2 Planar Layers
-------------------

 -- Sub-variable of SimulationSpace: list MaterialSlabs
     The purpose of the `MaterialSlab' list is to introduce *planar
     stratification* into the simulation grid. Currently, Angora only
     supports planar stratification along the z direction. The handling
     of planar layers will be further improved in the future. Please
     send any comments, suggestions, and requests to
     <help@angorafdtd.org>.

     Here is an example:

          SimulationSpace:
          {
              MaterialSlabs:
              (
                  {
                      material_tag = "material1";
                      min_coord = 1e-6;
                      max_coord = "max";
                  },
                  {
                      ...
                      ...
                  }
              );
          };

     In the above example, a material slab composed of `material1' is
     placed in the grid.

      -- Sub-variable of MaterialSlabs: string material_tag
          This variable specifies the material that makes up the slab.
          It should match a previously-defined tag in a `Materials'
          definition (*note Materials::).

      -- Sub-variable of MaterialSlabs: floating-point/string min_coord

      -- Sub-variable of MaterialSlabs: floating-point/string max_coord

      -- Sub-variable of MaterialSlabs: integer/string
     min_coord_in_cells

      -- Sub-variable of MaterialSlabs: integer/string
     max_coord_in_cells
          These two floating-point variables specify the lower and
          upper coordinates of the material slab with respect to the
          grid origin (*note Coordinate Origin::). The units are either
          in meters or grid cells. For the latter, the `_in_cells'
          suffix should be appended to the variable name. These
          variables can also be assigned the string values `"min"' or
          `"max"'; which correspond to the lower and upper boundaries
          of the simulation grid, respectively. If the coordinates
          correspond to non-integer cell positions, they are rounded to
          the nearest multiple of the spatial step size. However, the
          tangential components of the electric tensor properties and
          the normal component of the magnetic tensor properties are
          suitably interpolated (*note Hwang01::).

     If the FDTD grid is terminated by absorbing PML boundaries (see
     *Note Perfectly-Matched Layer (PML)::), then the `MaterialSlab'
     definitions effectively create _infinite planar layers_ that
     extend horizontally toward infinity. When the `"min"' or `"max"'
     strings are assigned as lower or upper coordinates of the slab,
     the `MaterialSlab' definition amounts to placing a _half space_.
     When the `MaterialSlab' variable is used, the incident beams (see
     *Note Incident Beams::) and the scattered far field (see *Note
     Near-Field-to-Far-Field Transformer::) are both calculated as if
     the material slab horizontally extends toward infinity.


File: angora.info,  Node: Random Materials,  Next: File Input,  Prev: Planar Layers,  Up: Simulation Space

6.5.3 Random Materials
----------------------

 -- Sub-variable of SimulationSpace: group RandomMaterials
     Independent samples from a random distribution of material
     properties with a specified correlation function can be generated
     and placed into the simulation grid using the `RandomMaterials'
     group. It contains sub-variables in the form of lists (see *Note
     Lists::) that correspond to specific correlation functions.
     Currently, only the _Whittle-Matern_ family of correlation
     functions is supported. More correlation functions can be added in
     the future. Please send any comments, suggestions, and requests to
     <help@angorafdtd.org>.

     Although the spatial correlation of the generated random material
     regions can vary, the joint probability density function of the
     material region is always a _multivariate normal (Gaussian)
     function_.

      -- Sub-variable of RandomMaterials: list WhittleMaternCorrelated
          The Whittle-Matern family of correlations (see *Note
          Rogers09::) is a three-parameter isotropic stochastic model
          that can represent a wide range of spatial correlations. The
          Whittle-Matern correlation function B(r) for two points
          separated in space by a distance of r is given by the formula

          B(r)=2^(5/2-m)(sigma^2)*(r/lc)^(m-3/2)*BesselK(m-3/2,r/lc)/Gamma(m-3/2)

          where BesselK(m-3/2,r/lc) is the modified Bessel function of
          the second kind and order (m-3/2).
             * m: The shape parameter that determines the overall
               behavior of the correlation function. As m->infinity,
               the function approaches a Gaussian distribution. If m=2,
               the function reduces to a decaying exponential. For
               m<3/2, the distribution acquires an inverse power law
               dependence near the origin; approximating a fractal
               distribution. For more details, see *Note Rogers09::.

             * lc: (For m>3/2:) The correlation length. (For m<=3/2:)
               Loosely, the outer length scale where the fractal
               approximation no longer holds.

             * sigma: (For m>3/2:) The standard deviation of the
               distribution at a given point (r=0). (For m<=3/2:) In
               this range, the correlation function enters the fractal
               regime with an inverse-power-law dependence at the
               origin (see *Note Rogers09::). The meaning of sigma
               becomes more subtle in this regime. It can loosely be
               associated with the amplitude of the correlation between
               two points separated by lc.

          The `WhittleMaternCorrelated' list creates regions with
          random material properties described by the Whittle-Matern
          correlation function above. Here is an example of its usage:

               SimulationSpace:
               {
                   RandomMaterials:
                   {
                       WhittleMaternCorrelated:
                       (
                           {
                               constitutive_param_type = "rel_permittivity";
                               mean = 1.33;
                               std_dev = 0.05;
                               corr_len = 100e-9;
                               m = 2.0;
                               shape_tag = "rand_mat_shape";
                               random_seed = 0;
                           },
                           {
                               ...
                               ...
                           }
                       );
                   };

               };

           -- Sub-variable of WhittleMaternCorrelated: string
          constitutive_param_type
               The Whittle-Matern correlation function can describe the
               relative permittivity, relative permeability, electric
               conductivity (in Siemens/m), or magnetic conductivity
               (Ohm/m) of the material region. This is specified by
               assigning `"rel_permittivity"', `"rel_permeability"',
               `"electric_conductivity"', or `"magnetic_conductivity"'
               to the `constitutive_param_type' string variable.

               The constitutive parameters other than the one specified
               are _not changed_. As a result, different random
               constitutive parameter distributions can be superimposed
               using multiple random material definitions:

                    SimulationSpace:
                    {
                        RandomMaterials:
                        {
                            WhittleMaternCorrelated:
                            (
                                {
                                    constitutive_param_type = "rel_permittivity";
                                    mean = 1.33;
                                    std_dev = 0.05;
                                    corr_len = 100e-9;
                                    m = 2.0;
                                    shape_tag = "rand_mat_shape";
                                },
                                {
                                    constitutive_param_type = "rel_permeability";
                                    mean = 1.1;
                                    std_dev = 0.05;
                                    corr_len = 100e-9;
                                    m = 2.0;
                                    shape_tag = "rand_mat_shape";
                                }
                            );
                        };

                    };

               Here, a random permittivity distribution and a random
               permeability distribution are overlaid within the same
               region in the grid.


           -- Sub-variable of WhittleMaternCorrelated: floating-point
          mean (units: none or S/m)
               A baseline constant value equal to `mean' is added to
               the constitutive parameter described by the
               Whittle-Matern correlation function. If `mean=0', then
               the generated random distribution will have zero mean.
               However, this will not necessarily be reflected to the
               actual constitutive parameter values in the grid; since
               Angora will automatically clip the constitutive
               parameters (permittivity, permeability, conductivity,
               etc.) from below to either unity or zero to avoid
               instabilities. For this reason, `mean' should be high
               enough to avoid this clipping as much as possible. As a
               rule of thumb, `mean' should be 5 to 6 times the
               standard deviation (`std_dev') above unity or zero.

           -- Sub-variable of WhittleMaternCorrelated: floating-point
          std_dev (units: none or S/m)
               This variable specifies the sigma parameter in the
               definition of the Whittle-Matern correlation function.

           -- Sub-variable of WhittleMaternCorrelated: floating-point
          corr_len (units: m)

           -- Sub-variable of WhittleMaternCorrelated: floating-point
          corr_len_in_cells
               This variable specifies the lc parameter in the
               definition of the Whittle-Matern correlation function.
               The units are either in meters or grid cells. For the
               latter, the `_in_cells' suffix should be appended to the
               variable name.

           -- Sub-variable of WhittleMaternCorrelated: floating-point m
               This variable specifies the m parameter in the
               definition of the Whittle-Matern correlation function.

           -- Sub-variable of WhittleMaternCorrelated: string shape_tag
               This string variable specifies the geometrical shape of
               the region occupied by the random material. It should
               match a previously-defined tag in a `Shapes' definition
               (*note Shapes::).

           -- Sub-variable of WhittleMaternCorrelated: integer/string
          random_seed (default: determined by system time)
               If you would like to create _exactly the same random
               distribution_ each time the simulation is run, you can
               assign an integer value to the `random_seed' variable.
               Otherwise, you *should not* define this variable. This
               value is used to initialize the random-number generator
               in Angora. If the same seed is used to initialize the
               random-number generator, the same sequence of random
               numbers will be generated each time, resulting in the
               same random distribution.

               If multiple simulation runs are present (see *Note
               Multiple Simulation Runs::), you can create different
               random samples for each simulation run by assigning the
               string value `"run_index"' to `random_seed'. This will
               initialize the intenal random-number generator with the
               run index (ranging from `0' to `number_of_runs-1') of
               each run. This way, a different random distribution will
               be obtained in each simulation run; but a distribution
               for a given simulation run will be _fixed_ in subsequent
               executions of Angora.
          See printed manual for an example of a random distribution.



File: angora.info,  Node: File Input,  Next: Ground Planes,  Prev: Random Materials,  Up: Simulation Space

6.5.4 File Input
----------------

 -- Sub-variable of SimulationSpace: list MaterialsFromFiles
     Material information within rectangular regions of the FDTD
     simulation grid can be read from files using a
     `MaterialsFromFiles' list. This feature of Angora is still under
     development. The user interface for this feature may change in the
     future, or be superseded by another, more general interface.
     Currently, only a single constitutive parameter can be read from a
     file; and dispersive or anisotropic materials are not supported.
     These issues will be handled more comprehensively in a future
     version. Please send any comments, suggestions, and requests to
     <help@angorafdtd.org>.

     The material file should be in a simple custom binary format that
     Angora can recognize. The order and type of each variable in the
     file is explained below:
        * `x-extent': The extent of the array in the x direction in
          grid cells (integer, 4 bytes)

        * `y-extent': The extent of the array in the y direction in
          grid cells (integer, 4 bytes)

        * `z-extent': The extent of the array in the z direction in
          grid cells (integer, 4 bytes)

        * A floating-point array of length (`x-extent') x (`y-extent')
          x (`z-extent'). Each value in this array is either of type
          `double' (8 bytes) or `float' (4 bytes), depending on the
          `datatype' variable (see *Note `datatype': datatype.). The
          floating-point array should be laid out in the file in
          _column-major_ order, meaning that the x dimension is looped
          over first, then the y dimension, and finally the z dimension.
          See printed manual for a graphical illustration of the
          column-major order.


     Here is an example usage of `MaterialsFromFiles':

          SimulationSpace:
          {
              MaterialsFromFiles:
              (
                  {
                      file_name = "path_to_file/materialfile";
                      append_run_index_to_name = true;
                      file_extension = "mat";
                      constitutive_param_type = "rel_permittivity";
                      anchor = "center";
                      coord_x = 0;
                      coord_y = 0;
                      coord_z = 0;
                      datatype = "double";
                      max_new_materials = 1000;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of MaterialsFromFiles: string file_name
          This string specifies the name of the binary file from which
          the material information will be read. Path information can
          be prepended to the file name, as shown in the example above.
          This path is interpreted as being relative to `input_dir'
          (see *Note Paths::), unless it is preceded by a slash `/'.

      -- Sub-variable of MaterialsFromFiles: string file_extension
               (default: "")
          This is the extension of the material file to be read. In the
          above example, the file to be read is
          `path_to_file/materialfile.mat'.

      -- Sub-variable of MaterialsFromFiles: boolean
     append_run_index_to_name
          This boolean flag becomes useful if there are multiple
          simulation runs (see *Note Multiple Simulation Runs::), and a
          different file needs to be read in each run. This can be
          accomplished by appending the run index (which ranges from
          `0' to `number_of_runs-1') to the file name specified by
          `file_name'. For example, if there are 3 simulation runs
          (`number_of_runs' is 3) the above assignment will tell Angora
          to read the file `path_to_file/materialfile0.mat' in the
          first run, `path_to_file/materialfile1.mat' in the second,
          and `path_to_file/materialfile2.mat' in the third.

          This variable is required for all simulations (hence no
          default value) to help the user prevent easy mistakes such as
          reading the same file for all simulation runs
          unintentionally, reading `path_to_file/materialfile0.mat'
          instead of `path_to_file/materialfile.mat', etc.

      -- Sub-variable of MaterialsFromFiles: string
     constitutive_param_type
          The values read from the input file can be assigned to one of
          the following constitutive parameters: relative permittivity,
          relative permeability, electric conductivity, or magnetic
          conductivity. This is determined by assigning
          `"rel_permittivity"', `"rel_permeability"',
          `"electric_conductivity"', or `"magnetic_conductivity"' to
          the `constitutive_param_type' string variable. Electric
          conductivity is assumed to be in Siemens/m, and magnetic
          conductivity is assumed to be in Ohm/m.

          The constitutive parameters other than the one specified are
          _not changed_. As a result, different constitutive parameter
          distributions can be superimposed using multiple file-input
          definitions:

               SimulationSpace:
               {
                   MaterialsFromFiles:
                   (
                       {
                           file_name = "permittivity_file";
                           append_run_index_to_name = true;
                           constitutive_param_type = "rel_permittivity";
                           coord_x = 0;
                           coord_y = 0;
                           coord_z = 0;
                           datatype = "double";
                       },
                       {
                           file_name = "conductivity_file";
                           append_run_index_to_name = true;
                           constitutive_param_type = "electric_conductivity";
                           coord_x = 0;
                           coord_y = 0;
                           coord_z = 0;
                           datatype = "double";
                       }
                   );
               };

          Here, the contents of the files `permittivity_file' and
          `conductivity_file' are interpreted as the relative
          permittivity and electric conductivity of the same region,
          respectively.


      -- Sub-variable of MaterialsFromFiles: string anchor (default:
               `"center"')
          This string defines an anchor point inside the
          rectangular-box-shaped region that is to be read from this
          file. This anchor is then assigned a coordinate in the FDTD
          grid, determining the position of the rectangular box in the
          grid. Valid values for `anchor' are:
             * `"center"': center of the box

             * `"BLL"': back-left-lower corner of the box

             * `"BLU"': back-left-upper corner of the box

             * `"BRL"': back-right-lower corner of the box

             * `"BRU"': back-right-upper corner of the box

             * `"FLL"': front-left-lower corner of the box

             * `"FLU"': front-left-upper corner of the box

             * `"FRL"': front-right-lower corner of the box

             * `"FRU"': front-right-upper corner of the box
          Here, as usual, "back"/"front" refers to the x coordinate,
          "left"/"right" refers to the y coordinate, and
          "lower"/"upper" refers to the z coordinate.

      -- Sub-variable of MaterialsFromFiles: floating-point coord_x
               (units: m)

      -- Sub-variable of MaterialsFromFiles: floating-point coord_y
               (units: m)

      -- Sub-variable of MaterialsFromFiles: floating-point coord_z
               (units: m)

      -- Sub-variable of MaterialsFromFiles: integer coord_x_in_cells

      -- Sub-variable of MaterialsFromFiles: integer coord_y_in_cells

      -- Sub-variable of MaterialsFromFiles: integer coord_z_in_cells
          These values determine the Cartesian x,y, and z coordinates
          of the anchor point (see above) assigned to the rectangular
          region to be read from the file. The coordinates are measured
          with respect to the grid origin (*note Coordinate Origin::).
          The units are either in meters or grid cells. For the latter,
          the `_in_cells' suffix should be appended to the variable
          name. If the coordinates correspond to non-integer cell
          positions, the closest integer positions are chosen.

      -- Sub-variable of MaterialsFromFiles: string datatype
          The datatype for the values read from the file is determined
          by this variable. It should be either `"double"' (8 bytes) or
          `"float"' (4 bytes).

      -- Sub-variable of MaterialsFromFiles: integer max_new_materials
               (default: `1000')
          Internally, Angora uses _material indexing_ to reduce memory
          use for material arrays. Every constitutive parameter in the
          grid can only take a distinct set of values, represented by a
          variable of type `unsigned short' (2 bytes) that can range
          from `0' to `65,535'. Instead of storing a floating-point
          value (which is usually 4 or 8 bytes) for a permittivity
          value at a point, Angora stores an _index_ that represents
          the permittivity at that point. The same applies to other
          constitutive parameters (relative permeability, electric
          conductivity, etc.)

          Each time a material region is read into the FDTD grid using
          `MaterialsFromFiles', a fixed number of new constitutive
          parameter values are defined between the minimum and maximum
          values found in the file. Because of this discretization,
          some loss of information is inevitable. The number of new
          materials is determined by the variable `max_new_materials';
          which is by equal to 1000 default. With the default value,
          the upper limit for the number of materials will be reached
          after about 65 material regions are inserted into the grid.
          If you wish to insert more material regions, and the dynamic
          ranges of constitutive parameters in your material files are
          not large, you can decrease `max_new_materials'.
          Alternatively, you may consider combining multiple material
          regions into a single region.


File: angora.info,  Node: Ground Planes,  Prev: File Input,  Up: Simulation Space

6.5.5 Ground Planes
-------------------

 -- Sub-variable of SimulationSpace: list GroundPlanes
     Infinitely thin perfect-electric-conductor (PEC) sheets can be
     placed in the grid using a `GroundPlanes' list. Currently, only
     z-oriented (parallel to the xy plane) sheets at integer
     (full-cell) positions are supported.

          SimulationSpace:
          {
              GroundPlanes:
              (
                  {
                      coord = 0;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of GroundPlanes: floating-point coord (units: m)

      -- Sub-variable of GroundPlanes: integer coord_in_cells
          This variable specifies the z-coordinate of the ground plane
          with respect to the grid origin (*note Coordinate Origin::).
          The units are either in meters or grid cells. For the latter,
          the `_in_cells' suffix should be appended to the variable
          name. If the coordinate corresponds to a non-integer cell
          position, the closest integer position is chosen.

     The `GroundPlanes' variable also updates the layering
     (stratification) information in the grid, much like
     `MaterialSlabs' (*note Planar Layers::).



File: angora.info,  Node: Waveforms,  Next: Point Sources,  Prev: Simulation Space,  Up: Configuration Variables

6.6 Waveforms
=============

 -- Global variable: group Waveforms
     In Angora, a _time waveform_ is defined as a self-contained
     structure that can be used by other structures; such as a Hertzian
     dipole source or a plane-wave injector. The library of available
     time waveforms will be expanded in the future. Please send any
     comments, suggestions, and requests to <help@angorafdtd.org>.

     An example usage of `Waveforms':
          Waveforms:
          {
              GaussianWaveforms:
              (
                  {
                      ...
                  }
              );

              DifferentiatedGaussianWaveforms:
              (
                  {
                      ...
                  }
              );
              ...
              ...
          };

* Menu:

* Gaussian Waveforms::
* Differentiated-Gaussian Waveforms::
* Modulated-Gaussian Waveforms::


File: angora.info,  Node: Gaussian Waveforms,  Next: Differentiated-Gaussian Waveforms,  Up: Waveforms

6.6.1 Gaussian Waveforms
------------------------

 -- Sub-variable of Waveforms: list GaussianWaveforms
     This variable is used to define Gaussian time waveforms given by
     the formula

     f(t)=A*exp(-(t-n_tau*tau)^2/2tau^2)

     The peak, 10%-amplitude (-20 dB power), and 1%-amplitude (-40 dB
     power) frequencies in the spectrum of the Gaussian are w=0,
     w=2.15/tau, w=3.035/tau , respectively.

     Gaussian waveforms are defined as follows:

          Waveforms:
          {
              GaussianWaveforms:
              (
                  {
                      waveform_tag = "my_waveform";
                      amplitude = 1.0;
                      tau = 2.1291e-15;
                      delay = 3;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of GaussianWaveforms: string waveform_tag
          This is the string tag by which the waveform will later be
          referred to by another structure that requires a time
          waveform in its definition.

      -- Sub-variable of GaussianWaveforms: floating-point amplitude
               (default: `1.0')
          This specifies the variable A in the above equation defining
          the Gaussian waveform.

      -- Sub-variable of GaussianWaveforms: floating-point tau (units:
               sec)
          This specifies the variable tau in the above equation
          defining the Gaussian waveform.

      -- Sub-variable of GaussianWaveforms: floating-point delay
               (default: `0.0')
          This specifies the variable n_tau in the above equation
          defining the Gaussian waveform.


File: angora.info,  Node: Differentiated-Gaussian Waveforms,  Next: Modulated-Gaussian Waveforms,  Prev: Gaussian Waveforms,  Up: Waveforms

6.6.2 Differentiated-Gaussian Waveforms
---------------------------------------

 -- Sub-variable of Waveforms: list DifferentiatedGaussianWaveforms
     This variable is used to define differentiated Gaussian time
     waveforms, given by the formula

     f(t)=A*(D^n/Dt^n][exp(-(t-n_tau*tau)^2/2tau^2)]

     The peak frequency in the spectrum of the differentiated-Gaussian
     is w=1/tau , the 10%-amplitude (-20 dB power) frequencies are
     w=0.06/tau and w=2.76/tau ; and the 1%-amplitude (-40 dB power)
     frequencies are w=0.006/tau and w=3.57/tau .

     Differentiated Gaussian waveforms are defined as follows:

          Waveforms:
          {
              DifferentiatedGaussianWaveforms:
              (
                  {
                      waveform_tag = "my_waveform";
                      amplitude = 1.0;
                      tau = 2.1291e-15;
                      delay = 3;
                      n_diff = 3;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of DifferentiatedGaussianWaveforms: string
     waveform_tag
          This is the string tag by which the waveform will later be
          referred to by another structure that requires a time
          waveform in its definition.

      -- Sub-variable of DifferentiatedGaussianWaveforms:
     floating-point amplitude (default: `1.0')
          This specifies the variable A in the above equation defining
          the differentiated Gaussian waveform.

      -- Sub-variable of DifferentiatedGaussianWaveforms:
     floating-point tau (units: sec)
          This specifies the variable tau in the above equation
          defining the differentiated Gaussian waveform.

      -- Sub-variable of DifferentiatedGaussianWaveforms:
     floating-point delay (default: `0.0')
          This specifies the variable n_tau in the above equation
          defining the differentiated Gaussian waveform.

      -- Sub-variable of DifferentiatedGaussianWaveforms: integer n_diff
          This specifies the order of differentiation n in the above
          equation defining the differentiated Gaussian waveform.


File: angora.info,  Node: Modulated-Gaussian Waveforms,  Prev: Differentiated-Gaussian Waveforms,  Up: Waveforms

6.6.3 Modulated-Gaussian Waveforms
----------------------------------

 -- Sub-variable of Waveforms: list ModulatedGaussianWaveforms
     This variable is used to define sinusoidally-modulated Gaussian
     time waveforms, given by the formula

     f(t)=A*g(2*pi*f_0(t-n_tau\tau)+extra_phase)exp(-(t-n_tau*tau)^2/2tau^2)

     where the function g(t) is a sinusoidal function, being either
     sin(t) or cos(t) .

     The peak frequency in the spectrum of the modulated-Gaussian is
     w=w_0=2*pi*f_0 , the 10%-amplitude (-20 dB power) frequencies are
     w=w_0 +- 2.15/tau ; and the 1%-amplitude (-40 dB power)
     frequencies are w=w_0 +- 3.035/tau .

     Modulated Gaussian waveforms are defined as follows:

          Waveforms:
          {
              ModulatedGaussianWaveforms:
              (
                  {
                      waveform_tag = "my_waveform";
                      modulation_type = "sine";
                      amplitude = 1.0;
                      tau = 2.1291e-15;
                      f_0 = 5.8929e14;
                      delay = 3;
                      phase = 90;
                      differentiated = false;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of ModulatedGaussianWaveforms: string waveform_tag
          This is the string tag by which the waveform will later be
          referred to by another structure that requires a time
          waveform in its definition.

      -- Sub-variable of ModulatedGaussianWaveforms: string
     modulation_type
          If assigned `"sine"', the modulation function g(t) in the
          above equation becomes a sine. If assigned `"cosine"', it
          becomes a cosine.

      -- Sub-variable of ModulatedGaussianWaveforms: floating-point
     amplitude (default: `1.0')
          This specifies the variable A in the above equation defining
          the modulated Gaussian waveform.

      -- Sub-variable of ModulatedGaussianWaveforms: floating-point tau
               (units: sec)
          This specifies the variable tau in the above equation
          defining the modulated Gaussian waveform.

      -- Sub-variable of ModulatedGaussianWaveforms: floating-point f_0
               (units: Hz)
          This specifies the modulation frequency f_0 in the above
          equation defining the modulated Gaussian waveform.

      -- Sub-variable of ModulatedGaussianWaveforms: floating-point
     delay (default: `0.0')
          This specifies the variable n_tau in the above equation
          defining the modulated Gaussian waveform.

      -- Sub-variable of ModulatedGaussianWaveforms: floating-point
     phase (units: degrees, default: `0.0')
          This specifies the extra phase extra_delay in the above
          equation defining the modulated Gaussian waveform. This phase
          should be specified in _degrees_, which is then converted
          internally to radians, which are the actual units of
          extra_delay .

      -- Sub-variable of ModulatedGaussianWaveforms: boolean
     differentiated (default: `false')
          If set to `true', the waveform in the above equation is
          differentiated once with respect to time.



File: angora.info,  Node: Point Sources,  Next: Near-Field-to-Far-Field Transformer,  Prev: Waveforms,  Up: Configuration Variables

6.7 Point Sources
=================

 -- Global variable: list PointSources
     "Infinitesimal" electric dipole sources (also called _Hertzian_
     dipoles) can be simulated in Angora using the `PointSources' list.

     A Hertzian dipole at position (x0,y0,z0) is characterized by the
     following current distribution in space:

     J(x,y,z;t)=^a*j0(t)*delta(x-x0)delta(y-y0)delta(z-z0)

     where delta(x) is the Dirac delta function. The vector ^a
     determines the orientation of the dipole, which can be along the
     x, y, or z directions.  The prefactor j0(t) is called the _current
     moment_ of the dipole, with the units (Ampere*m).

     Here is an example usage of `PointSources':

          PointSources:
          (
              {
                  coord_x = 0;
                  coord_y = 0;
                  coord_z = 0;
                  source_orientation = "y_directed";
                  waveform_tag = "moment_waveform";
                  j_0 = 1.0;
              },
              {
                  ...
                  ...
              }
          );

      -- Sub-variable of PointSources: floating-point coord_x (units: m)

      -- Sub-variable of PointSources: floating-point coord_y (units: m)

      -- Sub-variable of PointSources: floating-point coord_z (units: m)

      -- Sub-variable of PointSources: integer coord_x_in_cells

      -- Sub-variable of PointSources: integer coord_y_in_cells

      -- Sub-variable of PointSources: integer coord_z_in_cells
          These variables specify the Cartesian x, y, and z coordinates
          of the Hertzian dipole with respect to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name. If the coordinates correspond
          to non-integer cell positions, the closest integer positions
          are chosen.

      -- Sub-variable of PointSources: string source_orientation
          This string specifies the spatial orientation of the Hertzian
          dipole. It should be `"x_directed"', `"y_directed"', or
          `"z_directed"'.

      -- Sub-variable of PointSources: string waveform_tag
          This string variable specifies the waveform of the current
          moment j0(t) . The waveform is interpreted in (Ampere*m)
          units. This should match a previously-defined tag in a
          `Waveforms' definition (*note Waveforms::).

      -- Sub-variable of PointSources: floating-point j_0 (units:
               Ampere/m, default: `1.0')
          This is an extra prefactor applied to the current moment
          waveform j0(t) .



File: angora.info,  Node: Near-Field-to-Far-Field Transformer,  Next: Optical Imaging,  Prev: Point Sources,  Up: Configuration Variables

6.8 Near-Field-to-Far-Field Transformer
=======================================

In many electromagnetic problems, it is of interest to calculate the
radiated (or far-zone) field scattered from (or radiated by) the
structures inside the grid. The radiated field is defined as the
asymptotic form of the electric field at large distances, which decays
as 1/r and propagates locally like a plane wave. Although the radial
dependence is trivial in the far field, the angular dependence is
highly variable. In finite numerical solution methods such as FDTD and
FEM, it is only the near-field that is available in the computation
grid. It is hugely impractical to extend the computation grid to large
distances where the field assumes an asymptotic form. Luckily, certain
theorems of electromagnetics (Huygens' principle, equivalence theorem,
etc.) allow the calculation of the far field using this near field
information. This procedure is called a *near-field-to-far-field
transform* (NFFFT). There are two main types of NFFFTs. In the first
type, the far-field waveforms are calculated directly in time domain.
In the second, the frequency (or phasor) components in the Fourier
decomposition of the far-field waveforms are calculated at a number of
frequencies. Angora features both time-domain and phasor domain NFFFTs.

* Menu:

* Time-Domain Near-Field-to-Far-Field-Transformer::    Radiated field time-domain waveforms at a given direction.
* Phasor-Domain Near-Field-to-Far-Field-Transformer::    Phasor components of the radiated field at a range of frequencies.


File: angora.info,  Node: Time-Domain Near-Field-to-Far-Field-Transformer,  Next: Phasor-Domain Near-Field-to-Far-Field-Transformer,  Up: Near-Field-to-Far-Field Transformer

6.8.1 Time-Domain Near-Field-to-Far-Field-Transformer
-----------------------------------------------------

In the _time-domain_ NFFFT, the far-field waveforms (normalized by the
distance r, and advanced in time by r/c ) are calculated directly using
time-domain Green's functions for the particular space. Currently, the
time-domain NFFFT supports up to _three_ lossless infinite planar
material layers with only permittivity variations.

   The time-domain NFFFT should be used when the far-field waveforms
are to be computed over only a few observation directions. The
additional computational burden per observation direction is much
larger than that of the phasor-domain NFFFT. The format used for the
time-domain far-field output is *HDF5* (Hierarchical Data Format)
(`http://www.hdfgroup.org/HDF5/'). The HDF5 format was chosen for its
standard interface, and the availability of free software tools for
inspecting and modifying HDF5 output. The HDF5 output created by the
time-domain NFFFT is explained in more detail in *Note HDF5 Content of
Time-Domain NFFFT Output::.

   The radiated electric field can be expressed in the form

   E(r,theta,phi;t) = E(theta,phi;t-r/c)/r

   The time-domain NFFFT only calculates the _angle and time-dependent_
part of the above expression, namely, E(theta,phi;t) .

 -- Global variable: string td_nffft_output_dir (default: `"nffft/td"')
     This determines the subdirectory in which all the
     time-domain-NFFFT output will be placed. Unless it has a slash `/'
     up front; this path is interpreted as being relative to
     `output_dir' (*note Paths::).

          td_nffft_output_dir = "nffft/td";
          TimeDomainNFFFT:
          {
                  ...
                  ...
          };

 -- Global variable: list TimeDomainNFFFT
     Time-domain NFFFTs are defined inside a `TimeDomainNFFFT' list,
     each within its own group:

          TimeDomainNFFFT:
          (
              {
                  theta = 36;
                  phi = 57;
                  write_hertzian_dipole_far_field = false;
                  nffft_back_margin_x_in_cells = 3;
                  nffft_front_margin_x_in_cells = 3;
                  nffft_left_margin_y_in_cells = 3;
                  nffft_right_margin_y_in_cells = 3;
                  nffft_lower_margin_z_in_cells = 3;
                  nffft_upper_margin_z_in_cells = 3;
                  far_field_origin_x = 0;
                  far_field_origin_y = 0;
                  far_field_origin_z = 0;
                  far_field_dir = "my_dir";
                  far_field_file_name = "FarField_td";
                  far_field_file_extension = "hd5";
              },
              {
                  ...
                  ...
              }
          );

      -- Sub-variable of TimeDomainNFFFT: floating-point theta (units:
               degrees)

      -- Sub-variable of TimeDomainNFFFT: floating-point phi (units:
               degrees)
          The direction at which the time-domain far field will be
          calculated is expressed in terms of the traditional
          spherical-coordinate variables (theta,phi).  The first of
          these angles is the _zenith angle_, while the second is the
          _azimuth angle_.  See printed manual for a graphical
          illustration of these angles.  The `theta' variable specifies
          the zenith angle in degrees. Although this angle is
          traditionally defined between 0 and 180deg, `theta' can be
          assigned any negative or positive value. The `phi' variable
          specifies the azimuth angle in degrees. Although this angle
          is traditionally defined between 0 and 360deg, `phi' can be
          assigned any negative or positive value.

      -- Sub-variable of TimeDomainNFFFT: boolean
     write_hertzian_dipole_far_field (default: `false')
          If set to `true', the theoretical far field waveforms due to
          the Hertzian point sources (see *Note Point Sources::) in the
          simulation grid are also written into the output file. Any
          planar stratification up to three lossless layers with
          permittivity variations is accounted for in the calculation
          of the theoretical far field, but the scattering from any
          other structure inside the grid is ignored. As such, this
          feature can be (and has been) used to test the time-domain
          NFFFT.

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_back_margin_x (units:m)

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_front_margin_x (units:m)

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_left_margin_y (units:m)

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_right_margin_y (units:m)

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_lower_margin_z (units:m)

      -- Sub-variable of TimeDomainNFFFT: floating-point
     nffft_upper_margin_z (units:m)

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_back_margin_x_in_cells (default: `3')

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_front_margin_x_in_cells (default: `3')

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_left_margin_y_in_cells (default: `3')

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_right_margin_y_in_cells (default: `3')

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_lower_margin_z_in_cells (default: `3')

      -- Sub-variable of TimeDomainNFFFT: integer
     nffft_upper_margin_z_in_cells (default: `3')
          The near field is collected over the surface of a rectangular
          prism in the grid, called the _NFFFT surface_. This surface
          should enclose all the scattering and/or radiating structures
          in the grid, as well as the total-field/scattered-field
          surface (see *Note Incident Beams::). By default, this
          rectangular box is placed 3 grid cells away from the PML
          boundary (see *Note Perfectly-Matched Layer (PML)::). You can
          specify different margins to reduce the computational burden
          associated with the NFFFT. This burden is directly
          proportional to the surface area of the box. The margins can
          be specified in meters or in grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.
          If given in meters, the margins are rounded to the nearest
          multiple of the spatial step size.

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_x (units: m, default: `0')

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_y (units: m, default: `0')

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_z (units: m, default: `0')

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_x_in_cells (default: `0')

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_y_in_cells (default: `0')

      -- Sub-variable of TimeDomainNFFFT: floating-point
     far_field_origin_z_in_cells (default: `0')
          These variables set the coordinates of the point relative to
          which the far field will be calculated. The distance r in
          *Note the above equation:
          eq:far_field_angle_dependence_time_domain. is with respect to
          this point. The coordinates of the far-field origin are with
          respect to the grid origin (*note Coordinate Origin::). The
          units are either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.

      -- Sub-variable of TimeDomainNFFFT: string far_field_dir
               (default: `""')
          This determines the subdirectory in which this individual
          far-field file will be placed. Unless it has a slash `/' up
          front; this path is interpreted as being relative to
          `td_nffft_output_dir' (see *Note `td_nffft_output_dir':
          td_nffft_output_dir.). By default, no subdirectory is created
          inside `td_nffft_output_dir'.

      -- Sub-variable of TimeDomainNFFFT: string far_field_file_name
               (default: `"FarField_td"')
          This determines the base string in the full name of the
          far-field file. Other information is appended to the name of
          the file to differentiate individual far-field files (see the
          example below).

      -- Sub-variable of TimeDomainNFFFT: string
     far_field_file_extension (default: `"hd5"')
          This is the extension of the far-field file name. If assigned
          the value `""', no extension is added to the file. The HDF5
          extension `"hd5"' is applied by default.

     Here is an example far-field file name:
          FarField_td_0_1.hd5
     The base string in the name of the file (`"FarField_td"') is
     specified by the `far_field_file_name' variable. The two integers
     that follow are the run index (see *Note Multiple Simulation
     Runs::) and the index of the time-domain NFFFT inside the
     `TimeDomainNFFFT' list. For example, if there are two groups (two
     NFFFTs) in the `TimeDomainNFFFT' list, the first one will write
     into
          FarField_td_0_0.hd5
     while the second will write into
          FarField_td_0_1.hd5
     If there are two simulation runs (i.e., `number_of_runs' is equal
     to 2 - see *Note Multiple Simulation Runs::), then the files
     created in the second run will have `1' instead of `0' as the
     first integer in the above file names. Finally, the extension
     (`"hd5"') of the line files is determined by the variable
     `far_field_file_extension'.


* Menu:

* HDF5 Content of Time-Domain NFFFT Output::    Explanation of the HDF5 content in the time-domain far-field output file.


File: angora.info,  Node: HDF5 Content of Time-Domain NFFFT Output,  Up: Time-Domain Near-Field-to-Far-Field-Transformer

6.8.1.1 HDF5 Content of Time-Domain NFFFT Output
................................................

The HDF5 file created as the output of the time-domain NFFFT can be
viewed and modified using freely-available tools. One of these tools is
HDFView (http://www.hdfgroup.org/hdf-java-html/hdfview/), provided by
the HDF Group. MATLAB also has built-in functions and tools that handle
HDF5 files. For reference, a MATLAB script named `hdf5_read.m' is
distributed as part of the Angora package, which reads an HDF5 dataset
from an HDF5 file into a MATLAB array. This script is installed in the
directory `$(prefix)/share/angora/' (see *Note Compilation and
Installation::). If Angora was installed without any `$(prefix)'
configuration option, the default location is
`/usr/local/share/angora/'. For example, if you want to read the
dataset named `theta' from the file `my_file.hd5', use
     >> theta = hdf5_read('my_file.hd5','theta');

   The HDF5 datasets in the far-field file are the following:

   * `angora_version':  Integer array of length 3 with the major
     version, minor version, and revision numbers of the Angora package
     used to create the file.

   * `theta':  A floating-point value for the spherical zenith angle at
     which the far field is calculated (in radians).

   * `phi':  A floating-point value for the spherical azimuth angle at
     which the far field is calculated (in radians).

   * `time_step':  A floating-point value specifying the temporal step
     in the simulation (in sec).

   * `initial_time_value':  A floating-point value specifying the time
     value corresponding to the beginning of the simulation (in sec).
     This is usually a negative value, since time waveforms frequently
     begin before t=0.

   * Floating-point arrays with the waveforms of different components
     of the vector radiated electric field.  See the printed manual for
     a graphical illustration of the unit vectors in spherical
     coordinates.  Note that only the angle and time-dependent part of
     the radiated electric field is calculated (see *Note the above
     equation: eq:far_field_angle_dependence_time_domain.). Because the
     (1/r) dependence has been factored out, the units are in Volts.
          	`E_theta':  1-D array with the theta component of the
          radiated electric field.

        * 	`E_phi':  1-D array with the phi component of the
          radiated electric field.

   * If the theoretical far field due to Hertzian point sources is also
     calculated (namely, `write_hertzian_dipole_far_field' is `true'):
          	`E_theta_th':  1-D array with the _theoretical_ theta
          component of the radiated electric field created by the
          Hertzian dipoles in the simulation grid.

        * 	`E_phi_th':  1-D array with the _theoretical_ phi
          component of the radiated electric field created by the
          Hertzian dipoles in the simulation grid.


File: angora.info,  Node: Phasor-Domain Near-Field-to-Far-Field-Transformer,  Prev: Time-Domain Near-Field-to-Far-Field-Transformer,  Up: Near-Field-to-Far-Field Transformer

6.8.2 Phasor-Domain Near-Field-to-Far-Field-Transformer
-------------------------------------------------------

The _phasor-domain_ NFFFT calculates the amplitude of the far field at
individual frequencies using Fourier decomposition. This NFFFT supports
free space as well as *infinite planar layered media* with arbitrary
permittivity, permeability and conductivity profiles (see *Note
Capoglu12::). Infinite planar layers are created using the
`MaterialSlabs' variable (*note Planar Layers::).

   The phasor-domain NFFFT in Angora calculates far-field values over a
two-dimensional array of observation directions and a range of
wavelengths; resulting in a three-dimensional array. The spacing of the
wavelengths and the arrangement of observation directions is highly
configurable.  The format used for the phasor-domain far-field output
is *HDF5* (Hierarchical Data Format) (`http://www.hdfgroup.org/HDF5/').
The HDF5 format was chosen for its standard interface, and the
availability of free software tools for inspecting and modifying HDF5
output. The HDF5 output created by the phasor-domain NFFFT is explained
in more detail in *Note HDF5 Content of Phasor-Domain NFFFT Output::.

   Angora uses the engineering convention exp(j*w*t) for time-harmonic
quantities. The time-domain data on the surface of a rectangular prism
in the grid, called the _NFFFT surface_, is decomposed into its phasor
components by a numerical approximation to the temporal Fourier
transform F(w) = (1/(2*pi))int f(t)*exp(-j*w*t)dt . Because of the
1/(2*pi) term, the phasor quantities F(w) correspond to the true
_Fourier components_ of the time-domain quantities on the NFFFT
surface. These quantities are then inserted into phasor-domain
electromagnetic theorems linking the near field to the far field. The
complex phasor output data therefore also corresponds to the Fourier
components of the far-field temporal waveforms.

   In the phasor domain, the radiated electric field can be expressed
in the form

   E(r,theta,phi) = E(theta,phi)exp(-jkr)/r

   The phasor-domain NFFFT only calculates the _angle-dependent_ part
of the above expression, namely, E(theta,phi) .  See printed manual for
a graphical illustration of spherical coordinates.

 -- Global variable: string pd_nffft_output_dir (default: `"nffft/pd"')
     This determines the subdirectory in which all the
     phasor-domain-NFFFT output will be placed. Unless it has a slash
     `/' up front; this path is interpreted as being relative to
     `output_dir' (*note Paths::).

          pd_nffft_output_dir = "nffft/pd";
          PhasorDomainNFFFT:
          {
                  ...
                  ...
          };

 -- Global variable: list PhasorDomainNFFFT
     Phasor-domain NFFFTs are defined inside a `PhasorDomainNFFFT'
     list, each within its own group:

          PhasorDomainNFFFT:
          (
              {
                  num_of_lambdas = 10;
                  lambda_min = 400e-9;
                  lambda_max = 700e-9;
                  lambda_spacing_type = "k-linear";
                  do_not_include_first_lambda = false;
                  do_not_include_last_lambda = false;
                  direction_spec = "theta-phi";
                  num_of_dirs_1 = 9;
                  dir1_min=0.0;
                  dir1_max=90.0;
                  num_of_dirs_2 = 361;
                  dir2_min=0.0;
                  dir2_max=360.0;
                  limit_to_s = 1.0;
                  write_hertzian_dipole_far_field = false;
                  nffft_back_margin_x_in_cells = 3;
                  nffft_front_margin_x_in_cells = 3;
                  nffft_left_margin_y_in_cells = 3;
                  nffft_right_margin_y_in_cells = 3;
                  nffft_lower_margin_z_in_cells = 3;
                  nffft_upper_margin_z_in_cells = 3;
                  far_field_origin_x = 0.0;
                  far_field_origin_y = 0.0;
                  far_field_origin_z = 0.0;
                  far_field_dir = "my_dir";
                  far_field_file_name = "FarField_pd";
                  far_field_file_extension = "hd5";
              },
              {
                  ...
                  ...
              }
          );

      -- Sub-variable of PhasorDomainNFFFT: integer num_of_lambdas
          This specifies the number of wavelengths (in vacuum) at which
          the far field will be calculated.

      -- Sub-variable of PhasorDomainNFFFT: floating-point lambda_min
               (units: m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     lambda_min_in_cells
          This value sets the lower limit of the wavelength range (in
          vacuum) over which the far field is calculated. The far field
          may or may not be calculated at the wavelength `lambda_min',
          depending on the variable `do_not_include_first_lambda'. The
          units are either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.

      -- Sub-variable of PhasorDomainNFFFT: floating-point lambda_max
               (units: m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     lambda_max_in_cells
          This value sets the upper limit of the wavelength range (in
          vacuum) over which the far field is calculated. The far field
          may or may not be calculated at the wavelength `lambda_max',
          depending on the variable `do_not_include_last_lambda'. The
          units are either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.

      -- Sub-variable of PhasorDomainNFFFT: string lambda_spacing_type
          This string specifies how the wavelengths will be spaced
          between the two end points determined by `lambda_min',
          `lambda_max', `do_not_include_first_lambda', and
          `do_not_include_last_lambda'.
             * `"lambda-linear"':  The wavelengths are spaced lineary
               between the two end points.

             * `"k-linear"':  The wavenumbers k=2*pi/lambda are spaced
               linearly between the two end points. Since the
               wavenumber is also equal to k=w/c , where w is the
               radian frequency, this causes the frequencies to be
               spaced linearly as well.

             * `"log"':  The logarithms of the wavelengths (therefore
               the logarithms of the wavenumbers) are spaced linearly
               between the two end points.

      -- Sub-variable of PhasorDomainNFFFT: boolean
     do_not_include_first_lambda (default: `false')

      -- Sub-variable of PhasorDomainNFFFT: boolean
     do_not_include_last_lambda (default: `false')
          Let's assume that `lambda_spacing_type' is `lambda-linear'.
          For `k-linear' and `log', replace `lambda_min' in the
          following by 2*pi/ `lambda_min' and log(`lambda_min'),
          respectively. The same applies to `lambda_max'.

             * If `do_not_include_first_lambda=false' and
               `do_not_include_last_lambda=false':  The interval
               between `lambda_min' and `lambda_max' is divided into
               `(num_of_lambdas-1)' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, including both
               endpoints `lambda_min' and `lambda_max'.

             * If `do_not_include_first_lambda=true' and
               `do_not_include_last_lambda=false':  The interval
               between `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, excluding the endpoint
               `lambda_min'.

             * If `do_not_include_first_lambda=false' and
               `do_not_include_last_lambda=true':  The interval between
               `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, excluding the endpoint
               `lambda_max'.

             * If `do_not_include_first_lambda=true' and
               `do_not_include_last_lambda=true':  The interval between
               `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed at the midpoints
               of each interval.

      -- Sub-variable of PhasorDomainNFFFT: string direction_spec
          This string specifies how the observation directions are
          arranged in a two-dimensional array.
             * `"theta-phi"':  The first dimension is the spherical
               polar angle theta , defined as the angle between the
               observation direction and the z-axis. The second
               dimension is the spherical azimuth angle phi , defined
               as the angle between the x-axis and the projection of
               the observation direction onto the xy-plane.  See the
               printed manual for a graphical illustration.  These
               angles are spaced linearly between their respective
               endpoints.

             * `"dircosx-dircosy-upper"' or `"dircosx-dircosy-lower"':
               The first dimension is the x-direction-cosine sx =
               sin(theta)*cos(phi) while the second dimension is the
               y-direction-cosine sy = sin(theta)*sin(phi) . These
               direction cosines are spaced linearly between their
               respective endpoints. The suffix `"-upper"' or
               `"-lower"' determines whether the observation direction
               is in the upper half space (+z direction) or the lower
               half space (-z direction).

      -- Sub-variable of PhasorDomainNFFFT: integer num_of_dirs_1
          This is the number of observation directions over the first
          dimension of the two-dimensional observation-direction array.
          If `direction_spec' is `"theta-phi"', this is the number of
          theta values; otherwise, the number of x-direction-cosines sx
          = sin(theta)*cos(phi) .

      -- Sub-variable of PhasorDomainNFFFT: floating-point dir1_min

      -- Sub-variable of PhasorDomainNFFFT: floating-point dir1_max
          These are the minimum/maximum values of either the theta
          angle (in degrees), or the x-direction-cosine (between -1 and
          1).

      -- Sub-variable of PhasorDomainNFFFT: integer num_of_dirs_2
          This is the number of observation directions over the second
          dimension of the two-dimensional observation-direction array.
          If `direction_spec' is `"theta-phi"', this is the number of
          phi values; otherwise, the number of y-direction-cosines sy =
          sin(theta)*sin(phi) .

      -- Sub-variable of PhasorDomainNFFFT: floating-point dir2_min

      -- Sub-variable of PhasorDomainNFFFT: floating-point dir2_max
          These are the minimum/maximum values of either the phi angle
          (in degrees), or the y-direction-cosine (between -1 and 1).

      -- Sub-variable of PhasorDomainNFFFT: floating-point limit_to_s
               (default: `1')
          If `direction_spec' is `"dircosx-dircosy-upper"' or
          `"dircosx-dircosy-lower"' (the direction cosines are used to
          specify the observation directions), it might happen that
          some combinations of sx and sy do not correspond to a real
          observation direction, since sx^2+sy^2>1 . Such direction
          cosines are automatically assigned a far-field value of zero.
          If you would like to limit the direction cosines further into
          a narrower observation cone, you can choose the value of
          `limit_to_s' to be smaller than `1.0'. Then, the far field
          corresponding to the direction cosines satisfying
          sx^2+sy^2>(limit_to_s) are assigned a zero value. Although
          this could also be done in post processing, eliminating some
          observation directions in this way removes the burden of
          computing them in the first place.  Specifying a `limit_to_s'
          value corresponds to reducing the _numerical aperture_ in a
          microscope objective.

      -- Sub-variable of PhasorDomainNFFFT: boolean
     write_hertzian_dipole_far_field (default: `false')
          If set to `true', the theoretical far field due to the
          Hertzian point sources (see *Note Point Sources::) in the
          simulation grid is also written into the output file. Any
          planar stratification is accounted for in the calculation of
          the theoretical far field, but the scattering from any other
          structure inside the grid is ignored. As such, this feature
          can be (and has been) used to test the phasor-domain NFFFT.

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_back_margin_x (units:m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_front_margin_x (units:m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_left_margin_y (units:m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_right_margin_y (units:m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_lower_margin_z (units:m)

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     nffft_upper_margin_z (units:m)

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_back_margin_x_in_cells (default: `3')

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_front_margin_x_in_cells (default: `3')

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_left_margin_y_in_cells (default: `3')

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_right_margin_y_in_cells (default: `3')

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_lower_margin_z_in_cells (default: `3')

      -- Sub-variable of PhasorDomainNFFFT: integer
     nffft_upper_margin_z_in_cells (default: `3')
          The near field is collected over the surface of a rectangular
          prism in the grid, called the _NFFFT surface_. This surface
          should enclose all the scattering and/or radiating structures
          in the grid, as well as the total-field/scattered-field
          surface (see *Note Incident Beams::). By default, this
          rectangular box is placed 3 grid cells away from the PML
          boundary (see *Note Perfectly-Matched Layer (PML)::). You can
          specify different margins to reduce the computational burden
          associated with the NFFFT. This burden is directly
          proportional to the surface area of the box. The margins can
          be specified in meters or in grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.
          If given in meters, the margins are rounded to the nearest
          multiple of the spatial step size.

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_x (units: m, default: `0')

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_y (units: m, default: `0')

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_z (units: m, default: `0')

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_x_in_cells (default: `0')

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_y_in_cells (default: `0')

      -- Sub-variable of PhasorDomainNFFFT: floating-point
     far_field_origin_z_in_cells (default: `0')
          These variables set the coordinates of the point relative to
          which the far field will be calculated. The distance r in
          *Note the above equation: eq:far_field_angle_dependence. is
          with respect to this point. The coordinates of the far-field
          origin are with respect to the grid origin (*note Coordinate
          Origin::). The units are either in meters or grid cells. For
          the latter, the `_in_cells' suffix should be appended to the
          variable name.

      -- Sub-variable of PhasorDomainNFFFT: string far_field_dir
               (default: `""')
          This determines the subdirectory in which this individual
          far-field file will be placed. Unless it has a slash `/' up
          front; this path is interpreted as being relative to
          `pd_nffft_output_dir' (see *Note `pd_nffft_output_dir':
          pd_nffft_output_dir.). By default, no subdirectory is created
          inside `pd_nffft_output_dir'.

      -- Sub-variable of PhasorDomainNFFFT: string far_field_file_name
               (default: `"FarField_pd"')
          This determines the base string in the full name of the
          far-field file. Other information is appended to the name of
          the file to differentiate individual far-field files (see the
          example below).

      -- Sub-variable of PhasorDomainNFFFT: string
     far_field_file_extension (default: `"hd5"')
          This is the extension of the far-field file name. If assigned
          the value `""', no extension is added to the file. The HDF5
          extension `"hd5"' is applied by default.

     Here is an example far-field file name:
          FarField_pd_0_1.hd5
     The base string in the name of the file (`"FarField_pd"') is
     specified by the `far_field_file_name' variable. The two integers
     that follow are the run index (see *Note Multiple Simulation
     Runs::) and the index of the phasor-domain NFFFT inside the
     `PhasorDomainNFFFT' list. For example, if there are two groups
     (two NFFFTs) in the `PhasorDomainNFFFT' list, the first one will
     write into
          FarField_pd_0_0.hd5
     while the second will write into
          FarField_pd_0_1.hd5
     If there are two simulation runs (i.e., `number_of_runs' is equal
     to 2 - see *Note Multiple Simulation Runs::), then the files
     created in the second run will have `1' instead of `0' as the
     first integer in the above file names. Finally, the extension
     (`"hd5"') of the line files is determined by the variable
     `far_field_file_extension'.


* Menu:

* HDF5 Content of Phasor-Domain NFFFT Output::    Explanation of the HDF5 content in the phasor-domain far-field output file.


File: angora.info,  Node: HDF5 Content of Phasor-Domain NFFFT Output,  Up: Phasor-Domain Near-Field-to-Far-Field-Transformer

6.8.2.1 HDF5 Content of Phasor-Domain NFFFT Output
..................................................

The HDF5 file created as the output of the phasor-domain NFFFT can be
viewed and modified using freely-available tools. One of these tools is
HDFView (http://www.hdfgroup.org/hdf-java-html/hdfview/), provided by
the HDF Group. MATLAB also has built-in functions and tools that handle
HDF5 files. For reference, a MATLAB script named `hdf5_read.m' is
distributed as part of the Angora package, which reads an HDF5 dataset
from an HDF5 file into a MATLAB array. This script is installed in the
directory `$(prefix)/share/angora/' (see *Note Compilation and
Installation::). If Angora was installed without any `$(prefix)'
configuration option, the default location is
`/usr/local/share/angora/'. For example, if you want to read the
dataset named `lambda' from the file `my_file.hd5', use
     >> lambda = hdf5_read('my_file.hd5','lambda');

   The HDF5 datasets in the far-field file are the following:

   * `angora_version':  Integer array of length 3 with the major
     version, minor version, and revision numbers of the Angora package
     used to create the file.

   * `lambda':  1-D array with the recorded free-space wavelength
     values (in m).

   * If `direction_spec' is `"theta-phi"':


        * 	`theta':  1-D array with the theta values.

        * 	`phi':  1-D array with the phi values.

   * If `direction_spec' is `"dircosx-dircosy-upper"' or
     `"dircosx-dircosy-lower"':


        * 	`dircos_x':  1-D array with the x-direction-cosine
          values.

        * 	`dircos_y':  1-D array with the y-direction-cosine
          values.

   * Floating-point arrays with the real and imaginary parts of
     different components of the vector radiated electric field.  See
     the printed manual for a graphical illustration of the unit
     vectors in spherical coordinates.  Note that only the
     angle-dependent part of the radiated electric field is calculated
     (see *Note the above equation: eq:far_field_angle_dependence.).
     Because the (1/r) dependence has been factored out, the units are
     in Volts. The first dimension is the wavelength, the second is
     either theta or the x-direction-cosine, and the third is either
     phi or the y-direction-cosine.
          	`E_theta_r',`E_theta_i':  3-D arrays with the real and
          imaginary parts of the theta component of the radiated
          electric field.

        * 	`E_phi_r',`E_phi_i':  3-D arrays with the real and
          imaginary parts of the phi component of the radiated electric
          field.

   * If the theoretical far field due to Hertzian point sources is also
     calculated (namely, `write_hertzian_dipole_far_field' is `true'):
          	`E_theta_th_r',`E_theta_th_i':  3-D arrays with the
          _theoretical_ real and imaginary parts of the theta component
          of the radiated electric field created by the Hertzian
          dipoles in the simulation grid.

        * 	`E_phi_th_r',`E_phi_th_i':  3-D arrays with the
          _theoretical_ real and imaginary parts of the phi component
          of the radiated electric field created by the Hertzian
          dipoles in the simulation grid.


File: angora.info,  Node: Optical Imaging,  Next: Incident Beams,  Prev: Near-Field-to-Far-Field Transformer,  Up: Configuration Variables

6.9 Optical Imaging
===================

Angora can synthesize numerical *optical images* created by an ideal
imaging system. The image is calculated in the form of a field
distribution on a two-dimensional plane in the image space; which is
assumed homogeneous. In photolithography, this image distribution is
commonly called an _aerial image_.

   The optical axis of the imaging system is currently limited to the z
axis. The collection can be either through the +z or -z direction,
allowing the simulation of reflection or transmission-mode imaging
without changing the illumination scheme.  Angora internally utilizes a
near-field-to-far-field transformer (NFFFT) (see *Note
Near-Field-to-Far-Field Transformer::) to calculate the optical image.

   See printed manual for a graphical illustration of the optical
imaging geometry.

   The format used for the optical imaging output is *HDF5*
(Hierarchical Data Format) (`http://www.hdfgroup.org/HDF5/'). The HDF5
format was chosen for its standard interface, and the availability of
free software tools for inspecting and modifying HDF5 output. The HDF5
content of the optical image file is explained in more detail in *Note
Optical Image File HDF5 Content::.

 -- Global variable: string imaging_output_dir (default: `"imaging/"')
     This determines the subdirectory in which all the optical-imaging
     output will be placed. Unless it has a slash `/' up front; this
     path is interpreted as being relative to `output_dir' (*note
     Paths::).

          imaging_output_dir = "imaging";
          OpticalImages:
          {
                  ...
                  ...
          };

 -- Global variable: list OpticalImages
     Optical images are defined in an `OpticalImages' list:

          OpticalImages:
          (
              {
                  output_data = ["E_x_tot","E_y_tot","E_z_tot",
                                 "E_x_sca","E_y_sca","E_z_sca",
                                 "E_x_inc","E_y_inc","E_z_inc",
                                 "intensity_tot",
                                 "intensity_sca",
                                 "intensity_inc"];
                  num_of_lambdas = 5;
                  lambda_min = 400e-9;
                  lambda_max = 700e-9;
                  lambda_spacing_type = "k-linear";
                  do_not_include_first_lambda = false;
                  do_not_include_last_lambda = false;
                  ap_half_angle = 36.87;
                  magnification = 40.0;
                  image_space_refr_index = 1.0;
                  image_expansion_factor_x = 1.0;
                  image_expansion_factor_y = 1.0;
                  image_oversampling_rate_x = 1.0;
                  image_oversampling_rate_y = 1.0;
                  coll_half_space = "upper";
                  nffft_back_margin_x_in_cells = 3;
                  nffft_front_margin_x_in_cells = 3;
                  nffft_left_margin_y_in_cells = 3;
                  nffft_right_margin_y_in_cells = 3;
                  nffft_lower_margin_z_in_cells = 3;
                  nffft_upper_margin_z_in_cells = 3;
                  image_origin_x = 0.0;
                  image_origin_y = 0.0;
                  image_origin_z = 0.0;
                  image_dir = "";
                  image_file_name = "Image";
                  image_file_extension = "hd5";
              },
              {
                  ...
                  ...
              }
          );

      -- Sub-variable of OpticalImages: string-array output_data
          This array of strings determines what will be included in the
          final output file. Any combination of the following strings
          can be listed in the array.
             * `"E_x_sca"', `"E_y_sca"', `"E_z_sca"':  The x, y, and z
               components of the _scattered_ electric field of the
               image. This is the electric field that is scattered or
               generated by the structures inside the simulation grid.
               The contribution to the image by the incident beams (see
               *Note Incident Beams::) is not included in the scattered
               field.

             * `"E_x_inc"', `"E_y_inc"', `"E_z_inc"':  The x, y, and z
               components of the _incident_ electric field of the
               image. This is the contribution to the image by the
               portion of the illumination (see *Note Incident Beams::)
               that is collected by the optical system. The
               contribution to the image due to the reflections and
               transmissions of the illumination beams from the
               infinite planar layer interfaces are also lumped into
               the incident field.

             * `"E_x_tot"', `"E_y_tot"', `"E_z_tot"':  The x, y, and z
               components of the _total_ electric field of the image,
               defined as the sum of the scattered and incident fields
               above.

             * `"intensity_sca"':  The _scattered_ light intensity of
               the image, defined here simply as the absolute-square of
               the scattered electric field vector.

             * `"intensity_inc"':  The _incident_ light intensity of
               the image, defined here simply as the absolute-square of
               the incident electric field vector.

             * `"intensity_tot"':  The _total_ light intensity of the
               image, defined here simply as the absolute-square of the
               total electric field vector.

          For example, if the `output_data' array is
               output_data = ["E_x_sca","intensity_tot"];
          then only the x-component of the scattered electric field of
          the image and the total light intensity of the image are
          recorded in the output.


      -- Sub-variable of OpticalImages: integer num_of_lambdas
          This specifies the number of wavelengths (in vacuum) at which
          the optical image will be calculated.

      -- Sub-variable of OpticalImages: floating-point lambda_min
               (units: m)

      -- Sub-variable of OpticalImages: floating-point
     lambda_min_in_cells
          This value sets the lower limit of the wavelength range (in
          vacuum) over which the optical image is calculated. The
          optical image may or may not be calculated at the wavelength
          `lambda_min', depending on the variable
          `do_not_include_first_lambda'. The units are either in meters
          or grid cells. For the latter, the `_in_cells' suffix should
          be appended to the variable name.

      -- Sub-variable of OpticalImages: floating-point lambda_max
               (units: m)

      -- Sub-variable of OpticalImages: floating-point
     lambda_max_in_cells
          This value sets the upper limit of the wavelength range (in
          vacuum) over which the optical image is calculated. The
          optical image may or may not be calculated at the wavelength
          `lambda_max', depending on the variable
          `do_not_include_last_lambda'. The units are either in meters
          or grid cells. For the latter, the `_in_cells' suffix should
          be appended to the variable name.

      -- Sub-variable of OpticalImages: string lambda_spacing_type
          This string specifies how the wavelengths will be spaced
          between the two end points determined by `lambda_min',
          `lambda_max', `do_not_include_first_lambda', and
          `do_not_include_last_lambda'.
             * `"lambda-linear"':  The wavelengths are spaced lineary
               between the two end points.

             * `"k-linear"':  The wavenumbers k=2*pi/lambda are spaced
               linearly between the two end points. Since the
               wavenumber is also equal to k=w/c , where w is the
               radian frequency, this causes the frequencies to be
               spaced linearly as well.

             * `"log"':  The logarithms of the wavelengths (therefore
               the logarithms of the wavenumbers) are spaced linearly
               between the two end points.

      -- Sub-variable of OpticalImages: boolean
     do_not_include_first_lambda (default: `false')

      -- Sub-variable of OpticalImages: boolean
     do_not_include_last_lambda (default: `false')
          Let's assume that `lambda_spacing_type' is `lambda-linear'.
          For `k-linear' and `log', replace `lambda_min' in the
          following by 2*pi/ `lambda_min' and log(`lambda_min'),
          respectively. The same applies to `lambda_max'.

             * If `do_not_include_first_lambda=false' and
               `do_not_include_last_lambda=false':  The interval
               between `lambda_min' and `lambda_max' is divided into
               `(num_of_lambdas-1)' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, including both
               endpoints `lambda_min' and `lambda_max'.

             * If `do_not_include_first_lambda=true' and
               `do_not_include_last_lambda=false':  The interval
               between `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, excluding the endpoint
               `lambda_min'.

             * If `do_not_include_first_lambda=false' and
               `do_not_include_last_lambda=true':  The interval between
               `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed linearly at the
               boundaries between the intervals, excluding the endpoint
               `lambda_max'.

             * If `do_not_include_first_lambda=true' and
               `do_not_include_last_lambda=true':  The interval between
               `lambda_min' and `lambda_max' is divided into
               `num_of_lambdas' equal intervals. A total of
               `num_of_lambdas' wavelengths are placed at the midpoints
               of each interval.

      -- Sub-variable of OpticalImages: floating-point ap_half_angle
               (units: degrees)
          This is the half-angle of the collection cone over which the
          far field is collected.  See printed manual for a graphical
          description of this angle.

      -- Sub-variable of OpticalImages: floating-point magnification
               (default: `1')
          This is the absolute value of the _lateral magnification_ of
          the optical imaging system. If greater than `1', the imaging
          system shows a magnified image of the object. This is the
          case in _microscopy_, where the magnification ranges from 10
          to 100. If less than `1', the image is a de-magnified version
          of the object, This is the case in _photolithography_, where
          a de-magnified image of a mask is projected on a photoresist.
          Typical magnifications in photolithography are 0.1 to 0.25.

      -- Sub-variable of OpticalImages: floating-point
     image_space_refr_index (default: `1')
          This variable specifies the refractive index of the image
          space, assumed to be homogeneous.

      -- Sub-variable of OpticalImages: floating-point
     image_expansion_factor_x (default: `1')

      -- Sub-variable of OpticalImages: floating-point
     image_expansion_factor_y (default: `1')
          By default, the optical image will only span the lateral
          (x-y) dimensions of the FDTD grid. The x and y dimensions of
          the image can be increased or decreased using these two
          factors. Setting these factors greater than 1 will reduce the
          aliasing effects in the numerical computation of the image,
          but linearly increase the computational burden associated
          with the far-field computation. This is because the far-field
          has to be collected at a denser set of observation directions
          for a larger image. The technical details of this are the
          subject of _sampling theory_, and are explained in *Note
          Capoglu12b::.

      -- Sub-variable of OpticalImages: floating-point
     image_oversampling_rate_x (default: `1')

      -- Sub-variable of OpticalImages: floating-point
     image_oversampling_rate_y (default: `1')
          Angora tries to automatically determine the minimum number of
          far-field collection directions to accurately synthesize the
          optical image. By default, the number of pixels in the final
          image is the same as the number of far-field collection
          directions. As a result, the image is sampled very
          economically; causing a pixelated appearance. A finer image
          can be synthesized by scaling the sampling rate in the x and
          y directions by modifying `image_oversampling_rate_x' and
          `image_oversampling_rate_y', respectively. For example,
          setting `image_oversampling_rate_x'=10 results in 10 times
          the default number of pixels in the x direction. Choosing
          high values for these two factors do not really cause much
          degradation in performance, since only the post-processing
          (post-simulation) computational burden is affected. The
          post-processing burden is usually a small fraction of the
          burden associated with the whole simulation.

          In sampling theory, the minimum number of pixels needed to
          represent the image is determined by the _Nyquist sampling
          rate_ for the image (see *Note Capoglu12b::). There is a
          well-defined Nyquist sampling rate associated with every
          optical image, since they are constrained in spatial
          frequency content by the wavelength of illumination. If
          desired, the default image (the one obtained with
          `image_oversampling_rate_x'=`image_oversampling_rate_y'=1)
          can be made arbitrarily fine through _bandlimited
          interpolation_ in post-processing.

      -- Sub-variable of OpticalImages: string coll_half_space
          The collection apparatus can either be situated in the upper
          (+z) half space or the lower (-z) half space. This is
          specified by assigning the string `"upper"' or `"lower"' to
          the `coll_half_space' variable, respectively.  See printed
          manual for a graphical explanation of the upper vs. lower
          collection half space.

      -- Sub-variable of OpticalImages: floating-point
     nffft_back_margin_x (units:m)

      -- Sub-variable of OpticalImages: floating-point
     nffft_front_margin_x (units:m)

      -- Sub-variable of OpticalImages: floating-point
     nffft_left_margin_y (units:m)

      -- Sub-variable of OpticalImages: floating-point
     nffft_right_margin_y (units:m)

      -- Sub-variable of OpticalImages: floating-point
     nffft_lower_margin_z (units:m)

      -- Sub-variable of OpticalImages: floating-point
     nffft_upper_margin_z (units:m)

      -- Sub-variable of OpticalImages: integer
     nffft_back_margin_x_in_cells (default: `3')

      -- Sub-variable of OpticalImages: integer
     nffft_front_margin_x_in_cells (default: `3')

      -- Sub-variable of OpticalImages: integer
     nffft_left_margin_y_in_cells (default: `3')

      -- Sub-variable of OpticalImages: integer
     nffft_right_margin_y_in_cells (default: `3')

      -- Sub-variable of OpticalImages: integer
     nffft_lower_margin_z_in_cells (default: `3')

      -- Sub-variable of OpticalImages: integer
     nffft_upper_margin_z_in_cells (default: `3')
          In the collection stage of optical imaging (see figure in
          printed manual), the far field scattered from the sample is
          calculated using a near-field-to-far-field transformer
          (NFFFT). These variables determine the surface over which the
          near field is collected for the calculation of the far field.
          For more information, see *Note Near-Field-to-Far-Field
          Transformer::.

      -- Sub-variable of OpticalImages: floating-point image_origin_x
               (units: m, default: `0')

      -- Sub-variable of OpticalImages: floating-point image_origin_y
               (units: m, default: `0')

      -- Sub-variable of OpticalImages: floating-point image_origin_z
               (units: m, default: `0')

      -- Sub-variable of OpticalImages: floating-point
     image_origin_x_in_cells (default: `0')

      -- Sub-variable of OpticalImages: floating-point
     image_origin_y_in_cells (default: `0')

      -- Sub-variable of OpticalImages: floating-point
     image_origin_z_in_cells (default: `0')
          These variables set the coordinates of the optical conjugate
          of the center of the image plane. Changing these values
          amounts to focusing at different positions and depths in the
          sample using the focusing knob on a microscope. The
          coordinates are with respect to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name.


* Menu:

* Optical Image File HDF5 Content::    Explanation of the HDF5 content in the optical image file.


File: angora.info,  Node: Optical Image File HDF5 Content,  Up: Optical Imaging

6.9.1 Optical Image File HDF5 Content
-------------------------------------

The HDF5 file created as the output of optical imaging can be viewed
and modified using freely-available tools. One of these tools is
HDFView (http://www.hdfgroup.org/hdf-java-html/hdfview/), provided by
the HDF Group. MATLAB also has built-in functions and tools that handle
HDF5 files. For reference, a MATLAB script named `hdf5_read.m' is
distributed as part of the Angora package, which reads an HDF5 dataset
from an HDF5 file into a MATLAB array. This script is installed in the
directory `$(prefix)/share/angora/' (see *Note Compilation and
Installation::). If Angora was installed without any `$(prefix)'
configuration option, the default location is
`/usr/local/share/angora/'. For example, if you want to read the
dataset named `lambda' from the file `my_file.hd5', use
     >> lambda = hdf5_read('my_file.hd5','lambda');

   The HDF5 datasets in the optical image file are the following:

   * `angora_version':  Integer array of length 3 with the major
     version, minor version, and revision numbers of the Angora package
     used to create the file.

   * `wv_range':  1-D array with the recorded free-space wavelength
     values (in m).

   * `k_range':  1-D array with the recorded free-space wavenumber
     values (in 1/m).

   * `x_range',`y_range':  1-D arrays with the x and y coordinates of
     the image (in m).

   * `n_obj',`n_img':  Refractive indices of the object and image
     spaces, respectively.

   * `magnification':  Absolute value of the lateral magnification of
     the imaging system.

   * `ap_half_angle':  The half-angle of the collection cone over which
     the scattered light is collected (in degrees).

   * `E_x_sca_r',`E_x_sca_i':  3-D arrays with the real and imaginary
     parts of the x component of the scattered electric field in the
     image. (if `"E_x_sca"' is included in the array `output_data')

   * `E_y_inc_r',`E_y_inc_i':  3-D arrays with the real and imaginary
     parts of the y component of the incident electric field in the
     image. (if `"E_y_inc"' is included in the array `output_data')

   * `E_z_tot_r',`E_z_tot_i':  3-D arrays with the real and imaginary
     parts of the z component of the total electric field in the image.
     (if `"E_z_tot"' is included in the array `output_data')

   * `E_x_sca_r',`E_x_sca_i':  3-D arrays with the real and imaginary
     parts of the x component of the scattered electric field in the
     image. (if `"E_x_sca"' is included in the array `output_data')

   * `E_y_inc_r',`E_y_inc_i':  3-D arrays with the real and imaginary
     parts of the y component of the incident electric field in the
     image. (if `"E_y_inc"' is included in the array `output_data')

   * `E_z_tot_r',`E_z_tot_i':  3-D arrays with the real and imaginary
     parts of the z component of the total electric field in the image.
     (if `"E_z_tot"' is included in the array `output_data')

   * `E_x_sca_r',`E_x_sca_i':  3-D arrays with the real and imaginary
     parts of the x component of the scattered electric field in the
     image. (if `"E_x_sca"' is included in the array `output_data')

   * `E_y_inc_r',`E_y_inc_i':  3-D arrays with the real and imaginary
     parts of the y component of the incident electric field in the
     image. (if `"E_y_inc"' is included in the array `output_data')

   * `E_z_tot_r',`E_z_tot_i':  3-D arrays with the real and imaginary
     parts of the z component of the total electric field in the image.
     (if `"E_z_tot"' is included in the array `output_data')

   * `intensity_sca':  3-D array with the intensity of the scattered
     light in the image. (if `"intensity_sca"' is included in the array
     `output_data'). The intensity here is defined simply as the
     absolute norm of the scattered electric field vector.

   * `intensity_inc':  3-D array with the intensity of the incident
     light in the image. (if `"intensity_inc"' is included in the array
     `output_data') The intensity here is defined simply as the
     absolute norm of the incident electric field vector.

   * `intensity_tot':  3-D array with the intensity of the total light
     in the image. (if `"intensity_tot"' is included in the array
     `output_data') The intensity here is defined simply as the
     absolute norm of the total electric field vector.


File: angora.info,  Node: Incident Beams,  Next: Recording,  Prev: Optical Imaging,  Up: Configuration Variables

6.10 Incident Beams
===================

Different types of incident beams can be sourced into the simulation
grid using the `TFSF' group.

 -- Global variable: group TFSF
     The `TFSF' group contains definitions for various types of
     incident electromagnetic beams required for scattering problems.
     Angora uses the _total-field/scattered-field_ (TF/SF) technique to
     source incident beams into the simulation grid (see *Note
     TafloveHagness::). In this technique, a rectangular surface
     surrounding the scatterer is designated the
     total-field/scattered-field boundary (or the _TF/SF box_ in
     short); and the electromagnetic field on this surface is
     supplemented by certain terms proportional to the incident
     electromagnetic field. These additional terms create the incident
     field inside the surface (suggesting the term _injection_), while
     maintaining a very small electromagnetic field outside the
     surface. The region outside the TF/SF box only harbors the
     _scattered field_ created by the scatterers inside the TF/SF box.
     The field inside the box is the _total field_, which is a sum of
     the incident field and the scattered field. Since the boundary
     divides the grid into total-field and scattered-field regions, the
     term "TF/SF boundary" is justified.

     TF/SF incident beam injection is supported for *infinite planar
     layered media*. Infinite planar layers are created using the
     `MaterialSlabs' variable (*note Planar Layers::). Currently, only
     layers with different permittivities and electrical conductivities
     are supported. Permeability variations across layers will also be
     supported in the future. Angora also supports *evanescent plane
     waves* resulting from plane waves passing from a high-permittivity
     layer to a low-permittivity one at a low grazing angle. Angora
     supports evanescent waves only for _narrowband_ plane waves, which
     have appreciable frequency components only in a small band around
     a center frequency. A modulated Gaussian waveform with a large
     f0*tau can be used as a narrowband waveform in cases where
     evanescent waves might be present (see *Note Modulated-Gaussian
     Waveforms::).

     Different types of incident beams are defined in their respective
     lists inside the `TFSF' group. These are explained in the
     following subsections.

          TFSF:
          {
              PlaneWaves:
              (
                  {
                      ...
                      ...
                  }
              );
              FocusedLaserBeams:
              (
                  {
                      ...
                      ...
                  }
              );
          };

* Menu:

* Plane Waves::
* Focused Laser Beams::    Spatially-coherent paraxial laser modes (TEM_mn) focused by an aplanatic converging lens.


File: angora.info,  Node: Plane Waves,  Next: Focused Laser Beams,  Up: Incident Beams

6.10.1 Plane Waves
------------------

A plane wave is one of the simplest solutions of Maxwell's equations;
with the electric field

   E(r,t) = (^e)*E0*f(t-r.ki/vp)

   where ^ki is the unit vector in the direction of propagation, ^e is
the electric-field unit vector, E0 is the electric field amplitude, and
r is the distance vector. The velocity of propagation vp is determined
by the material properties in the direction from which the plane wave
is incident.  The time waveform f(t) is arbitrary. Inserting the above
expression into Maxwell's equations, it is found that the
electric-field unit vector ^e is perpendicular to the direction of
propagation, as well as the magnetic-field unit vector.

   In a discrete FDTD grid, a plane wave propagates at a slightly lower
velocity than in continuum. Furthermore, there is an intrinsic grid
velocity anisotropy that results from the inherent rotational asymmetry
of the rectangular FDTD grid. These are partially alleviated in Angora
by the use of the _matched numerical dispersion_ (MND) technique (see
*Note TafloveHagness::).

 -- Sub-variable of TFSF: list PlaneWaves
     Plane waves are defined inside a `PlaneWaves' list inside the
     `TFSF' group:

          TFSF:
          {
              PlaneWaves:
              (
                  {
                      theta = 40.0;
                      phi = 90.0;
                      psi = 90.0;
                      waveform_tag = "waveform1";
                      pw_extra_amplitude = 1.0;
                      tfsf_back_margin_x_in_cells = 6;
                      tfsf_front_margin_x_in_cells = 6;
                      tfsf_left_margin_y_in_cells = 6;
                      tfsf_right_margin_y_in_cells = 6;
                      tfsf_lower_margin_z_in_cells = 6;
                      tfsf_upper_margin_z_in_cells = 6;
                      pw_origin_x = 0.0;
                      pw_origin_y = 0.0;
                      pw_origin_z = 0.0;
                      display_warnings = true;
                      min_cells_per_lambda = 15.0;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of PlaneWaves: floating-point theta (units:
               degrees)

      -- Sub-variable of PlaneWaves: floating-point phi (units: degrees)
          The incidence angles of the plane waves are defined in terms
          of the traditional spherical-coordinate variables (theta,phi).
          The first of these angles is the _zenith angle_, while the
          second is the _azimuth angle_.  See printed manual for a
          graphical illustration of these angles.  The `theta' variable
          specifies the zenith angle in degrees. Although this angle is
          traditionally defined between 0 and 180deg, `theta' can be
          assigned any negative or positive value. The `phi' variable
          specifies the azimuth angle in degrees. Although this angle
          is traditionally defined between 0 and 360deg, `phi' can be
          assigned any negative or positive value.

          Note that the incidence angles (theta,phi) specify the
          direction _from which the plane wave is incident_; *not* the
          direction in which it propagates.


      -- Sub-variable of PlaneWaves: floating-point psi (units: degrees)
          This variable is used to specify the polarization of the
          electric field of the incident plane wave. Maxwell's
          equations dictate that the electric field is *perpendicular*
          to the incidence vector ^ki.  In order to define the
          orientation of the electric vector unambiguously, a local
          coordinate system (xi,eta) is defined, such that (^xi)=(^ki)
          x (^z) and (^eta)=(^xi) x (^ki) The unit vectors (^xi,^eta)
          are perpendicular to each other, and lie in the plane
          perpendicular to the incidence vector ^ki.  The _polarization
          angle_ psi of the electric-field unit vector ^e is defined as
          the left-handed (clockwise) rotation angle around the axis
          defined by the incidence vector ^ki.  The variable `psi' sets
          this angle in degrees.


      -- Sub-variable of PlaneWaves: string waveform_tag
          This string variable specifies the electric-field waveform
          f(t) in *Note the above equation: eq:pw_E_field. The waveform
          is interpreted in (Volts/m) units. This should match a
          previously-defined tag in a `Waveforms' definition (*note
          Waveforms::).

      -- Sub-variable of PlaneWaves: floating-point pw_extra_amplitude
               (units: V/m, default: `1.0')
          This variable sets the electric field amplitude E0 in *Note
          the above equation: eq:pw_E_field.

      -- Sub-variable of PlaneWaves: floating-point tfsf_back_margin_x
               (units: m)

      -- Sub-variable of PlaneWaves: floating-point tfsf_front_margin_x
               (units: m)

      -- Sub-variable of PlaneWaves: floating-point tfsf_left_margin_y
               (units: m)

      -- Sub-variable of PlaneWaves: floating-point tfsf_right_margin_y
               (units: m)

      -- Sub-variable of PlaneWaves: floating-point tfsf_lower_margin_z
               (units: m)

      -- Sub-variable of PlaneWaves: floating-point tfsf_upper_margin_z
               (units: m)

      -- Sub-variable of PlaneWaves: integer
               tfsf_back_margin_x_in_cells (default: `6')

      -- Sub-variable of PlaneWaves: integer
     tfsf_front_margin_x_in_cells (default: `6')

      -- Sub-variable of PlaneWaves: integer
               tfsf_left_margin_y_in_cells (default: `6')

      -- Sub-variable of PlaneWaves: integer
     tfsf_right_margin_y_in_cells (default: `6')

      -- Sub-variable of PlaneWaves: integer
     tfsf_lower_margin_z_in_cells (default: `6')

      -- Sub-variable of PlaneWaves: integer
     tfsf_upper_margin_z_in_cells (default: `6')
          By default, the total-field/scattered-field (TF/SF) surface
          is placed 6 grid cells away from the PML boundary (see *Note
          Perfectly-Matched Layer (PML)::). You can specify different
          margins to reduce the computational burden associated with
          the TF/SF operation. This burden is directly proportional to
          the area of the TF/SF surface. The margins can be specified
          in meters or in grid cells. For the latter, the `_in_cells'
          suffix should be appended to the variable name. If given in
          meters, the margins are rounded to the nearest multiple of
          the spatial step size.

      -- Sub-variable of PlaneWaves: floating-point pw_origin_x (units:
               m)

      -- Sub-variable of PlaneWaves: floating-point pw_origin_y (units:
               m)

      -- Sub-variable of PlaneWaves: floating-point pw_origin_z (units:
               m)

      -- Sub-variable of PlaneWaves: floating-point
               pw_origin_x_in_cells (default: `0')

      -- Sub-variable of PlaneWaves: floating-point
               pw_origin_y_in_cells (default: `0')

      -- Sub-variable of PlaneWaves: floating-point
               pw_origin_z_in_cells (default: `0')
          These variables set the coordinates of the point relative to
          which the distance r is defined in *Note the above equation:
          eq:pw_E_field. The coordinates are with respect to the grid
          origin (*note Coordinate Origin::). The units are either in
          meters or grid cells. For the latter, the `_in_cells' suffix
          should be appended to the variable name.

      -- Sub-variable of PlaneWaves: boolean display_warnings (default:
               `true')

      -- Sub-variable of PlaneWaves: floating-point
               min_cells_per_lambda (default: `15')
          The boolean variable `display_warnings' enables or disables
          the printing of warning messages. Currently, a warning is
          displayed only when there are not enough grid cells per
          "minimum" wavelength in the excitation waveform. This minimum
          wavelength is defined to be the one at which the spectrum of
          the waveform falls to -40dB below its maximum. The number of
          required grid cells per the minimum wavelength is determined
          by the `min_cells_per_lambda' variable.



File: angora.info,  Node: Focused Laser Beams,  Prev: Plane Waves,  Up: Incident Beams

6.10.2 Focused Laser Beams
--------------------------

Angora can synthesize _focused laser beams_ created by an aplanatic
optical system (i.e., free of spherical aberration and coma)
illuminated by a normally-incident _paraxial Hermite-Gaussian laser
mode_. The electromagnetic formulation of the focused beam is based on
the classic work of Richards and Wolf (see *Note Richards59::). This
formulation is interpreted as a sum of plane waves, and approximated by
a finite sum in the FDTD implementation (see *Note Capoglu08::). It is
assumed that the Hermite-Gaussian laser mode filling the entrance pupil
of the optical system has a beam width much larger than the wavelength,
and is therefore in the paraxial regime. In this regime, the wavefronts
are almost planar, perpendicular to the optical axis, and the electric
field of the beam has a negligible longitudinal component.

   See the printed manual for a graphical description of the incident
laser mode illuminating the entrance pupil of the system.  A local
coordinate system (xi,eta) is defined on the plane of the entrance
pupil, such that (^xi)=(^ki) x (^z) and (^eta)=(^xi) x (^ki) The unit
vectors (^xi,^eta) are perpendicular to each other, and lie in the
plane perpendicular to the incidence vector ^ki.  The symmetry axes
(x',y') of the Hermite-Gaussian beam are rotated at an angle of alpha
with respect to the xi axis, in a clock-wise (left-handed) sense with
respect to ^ki.

   On the plane of the entrance pupil, which is assumed to coincide
with the waist of the Hermite-Gaussian beam, the electric field is
given by

   E(r,t) =
(^e)*E0*f(t)H_m(sqrt(2)*x/w0)H_n(sqrt(2)*y/w0)exp(-(x'^2+y'^2)/w0^2)

   where w0 is the beam half width (or beam waist radius), ^e is the
electric-field unit vector, E0 is the electric field amplitude, and
H_m(x) are the (physicists') _Hermite polynomials_ of order m. The
first few Hermite polynomials are H_0(x)=1

   H_1(x)=2x

   H_2(x)=4x^2-2 The time waveform f(t) is arbitrary. Since we assume
that the width of the beam at the entrance pupil is much larger than
the wavelengths contained in the waveform f(t), it is reasonable to
employ the _paraxial_ approximation, in which the rays propagate
parallel to the optical axis and the electric-field unit vector ^e is
perpendicular to the direction of propagation ^ki.

   The focusing optical system between the entrance pupil and the exit
pupil is assumed _aplanatic_. This means that, in addition to focusing
on-axis points stigmatically (without spherical aberration), the system
also correctly focuses off-axis points up to the first order in
off-axis distance. The latter condition corresponds to the absence of
circular coma. The _sine condition_, first derived by Ernst Abbe in
1881, is an expression of this in mathematical terms. The sine
condition reads

   h = f*sin(theta_ill)

   where h is the radius of the entrance pupil, and f is the back focal
length of the focusing system.

 -- Sub-variable of TFSF: list FocusedLaserBeams
     Focused laser beams are defined inside a `FocusedLaserBeams' list
     inside the `TFSF' group:

          TFSF:
          {
              FocusedLaserBeams:
              (
                  {
                      theta = 40.0;
                      phi = 90.0;
                      psi = 90.0;
                      alpha = 0;
                      x_order = 1;
                      y_order = 1;
                      waveform_tag = "waveform1";
                      flb_extra_amplitude = 1.0;
                      ap_half_angle = 23.5782;
                      back_focal_length = 0.1;
                      filling_factor = 1;
                      object_space_refr_index = 1.0;
                      tfsf_back_margin_x_in_cells = 6;
                      tfsf_front_margin_x_in_cells = 6;
                      tfsf_left_margin_y_in_cells = 6;
                      tfsf_right_margin_y_in_cells = 6;
                      tfsf_lower_margin_z_in_cells = 6;
                      tfsf_upper_margin_z_in_cells = 6;
                      flb_origin_x = 0.0;
                      flb_origin_y = 0.0;
                      flb_origin_z = 0.0;
                      display_warnings = true;
                      min_cells_per_lambda = 15.0;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of FocusedLaserBeams: floating-point theta
               (units: degrees)

      -- Sub-variable of FocusedLaserBeams: floating-point phi (units:
               degrees)
          The incidence angles for the focused laser beam are defined
          in reference to the paraxial beam that hits the entrance pupil
          (see printed manual for a graphical illustration).  The
          incidence angles are defined in terms of the traditional
          spherical-coordinate variables (theta,phi).  The first of
          these angles is the _zenith angle_, while the second is the
          _azimuth angle_.  The `theta' variable specifies the zenith
          angle in degrees. Although this angle is traditionally
          defined between 0 and 180deg, `theta' can be assigned any
          negative or positive value. The `phi' variable specifies the
          azimuth angle in degrees. Although this angle is
          traditionally defined between 0 and 360deg, `phi' can be
          assigned any negative or positive value.

          Note that the incidence angles (theta,phi) specify the
          direction _from which the paraxial beam is incident_; *not*
          the direction in which it propagates.


      -- Sub-variable of FocusedLaserBeams: floating-point psi (units:
               degrees)
          This variable is used to specify the polarization of the
          transverse electric field of the paraxial beam on the
          entrance pupil. The electric field is perpendicular to the
          incidence vector ^ki.  The _polarization angle_ psi is
          defined as the left-handed (clockwise) rotation angle with
          respect to the incidence vector ^ki between the symmetry axis
          x' and the electric-field unit vector ^e (see illustration in
          printed manual).  The variable `psi' sets this angle in
          degrees.

      -- Sub-variable of FocusedLaserBeams: floating-point alpha
               (units: degrees) (default: `0')
          This angle specifies the rotation of the symmetry axes (x',y')
          of the Hermite-Gaussian beam with respect to the local
          coordinate axes (xi,eta).  The rotation is clock-wise
          (left-handed) with respect to the incidence vector ^ki (see
          illustration in printed manual).

      -- Sub-variable of FocusedLaserBeams: integer x_order

      -- Sub-variable of FocusedLaserBeams: integer y_order
          These positive integers specify the orders of the Hermite
          polynomials H_m(x), H_n(y) in the definition of the
          Hermite-Gaussian beam in *Note the above equation:
          eq:fb_incident_E_field. `x_order' and `y_order' correspond to
          m and n, respectively.

      -- Sub-variable of FocusedLaserBeams: string waveform_tag
          This string variable specifies the electric-field waveform
          f(t) in *Note the above equation: eq:fb_incident_E_field,
          except a time advance t0 equal to the time of propagation
          from the entrance pupil to the focal point F. In other words,
          the actual waveform f(t) on the entrance pupil is advanced in
          time by t0 with respect to the waveform represented by
          `waveform_tag'. This is needed because we simulate the fields
          around the focus F; not the entrance pupil.  The waveform is
          interpreted in (Volts/m) units. The string `waveform_tag'
          should match a previously-defined string tag in a `Waveforms'
          definition (*note Waveforms::).

      -- Sub-variable of FocusedLaserBeams: floating-point
     flb_extra_amplitude (units: V/m, default: `1.0')
          This variable sets the electric field amplitude E0 in *Note
          the above equation: eq:fb_incident_E_field.

      -- Sub-variable of FocusedLaserBeams: floating-point
               ap_half_angle (units: degrees)
          This variable sets the half-angle theta_ill of the
          illumination cone in degrees (see illustration in printed
          manual).

          If a planar layered medium is present in the grid (see *Note
          Planar Layers::), the incidence cone bounded by the angle
          theta_ill should lie _entirely_ within the upper or lower
          half space. In other words, the incidence cone _cannot_ cut
          across the grazing direction theta=pi/2 . Angora will throw
          an error if this is found to be the case.

      -- Sub-variable of FocusedLaserBeams: floating-point
     back_focal_length (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     back_focal_length_in_cells
          This variable specifies the back focal length f of the
          optical system. The units are either in meters or grid cells.
          For the latter, the `_in_cells' suffix should be appended to
          the variable name.

      -- Sub-variable of FocusedLaserBeams: floating-point
     filling_factor
          This dimensionless parameter represents the ratio between the
          half-width of the incident paraxial beam and the radius of
          the entrance pupil. The larger this ratio, the more
          overfilled the pupil, and vice versa. This parameter is
          defined as

          f0 = w_0/(f*sin(theta_ill))


      -- Sub-variable of FocusedLaserBeams: floating-point
     object_space_refr_index (default: `1.0')
          This variable specifies the refractive index of the object
          space of the optical system; i.e., the space from which the
          paraxial beam is incident. Note that the FDTD simulation grid
          is in the image space of the optical system; therefore the
          refractive index of the image space is determined by the
          material filling the FDTD grid. If you want to simulate an
          oil immersion scenario, for example, you should fill the FDTD
          simulation space with the material representing the immersion
          oil. The object-side refractive index
          `object_space_refr_index' is seldom different than `1.0',
          which is the default value.

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_back_margin_x (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_front_margin_x (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_left_margin_y (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_right_margin_y (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_lower_margin_z (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     tfsf_upper_margin_z (units: m)

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_back_margin_x_in_cells (default: `6')

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_front_margin_x_in_cells (default: `6')

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_left_margin_y_in_cells (default: `6')

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_right_margin_y_in_cells (default: `6')

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_lower_margin_z_in_cells (default: `6')

      -- Sub-variable of FocusedLaserBeams: integer
     tfsf_upper_margin_z_in_cells (default: `6')
          By default, the total-field/scattered-field (TF/SF) surface
          is placed 6 grid cells away from the PML boundary (see *Note
          Perfectly-Matched Layer (PML)::). You can specify different
          margins to reduce the computational burden associated with
          the TF/SF operation. This burden is directly proportional to
          the area of the TF/SF surface. Because the focused beam is
          actually a collection of many (often hundreds) of plane
          waves, the reduction of the surface area of the TF/SF box
          greatly helps the simulation performance.

          The margins can be specified in meters or in grid cells. For
          the latter, the `_in_cells' suffix should be appended to the
          variable name. If given in meters, the margins are rounded to
          the nearest multiple of the spatial step size.

      -- Sub-variable of FocusedLaserBeams: floating-point flb_origin_x
               (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point flb_origin_y
               (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point flb_origin_z
               (units: m)

      -- Sub-variable of FocusedLaserBeams: floating-point
     flb_origin_x_in_cells (default: `0')

      -- Sub-variable of FocusedLaserBeams: floating-point
     flb_origin_y_in_cells (default: `0')

      -- Sub-variable of FocusedLaserBeams: floating-point
     flb_origin_z_in_cells (default: `0')
          These variables set the coordinates of the back focal point F
          of the focusing lens.  (see printed manual for a graphical
          illustration).  The coordinates are with respect to the grid
          origin (*note Coordinate Origin::). The units are either in
          meters or grid cells. For the latter, the `_in_cells' suffix
          should be appended to the variable name.

      -- Sub-variable of FocusedLaserBeams: boolean display_warnings
               (default: `true')

      -- Sub-variable of FocusedLaserBeams: floating-point
     min_cells_per_lambda (default: `15')
          The boolean variable `display_warnings' enables or disables
          the printing of warning messages. Currently, a warning is
          displayed only when there are not enough grid cells per
          "minimum" wavelength in the excitation waveform. This minimum
          wavelength is defined to be the one at which the spectrum of
          the waveform falls to -40dB below its maximum. The number of
          required grid cells per the minimum wavelength is determined
          by the `min_cells_per_lambda' variable.



File: angora.info,  Node: Recording,  Next: Paths,  Prev: Incident Beams,  Up: Configuration Variables

6.11 Recording
==============

Angora can record field values computed during a simulation into a file
in a variety of ways. Field values can be recorded on a cross-section
of the grid, along a line through the grid, or at a given point in the
grid. Currently, Angora only supports the recording of the electric or
the magnetic field. Recording of other field-related quantities such as
energy, flux, Poynting's vector, etc. will be implemented in the
future. Please send any comments, suggestions, and requests to
<help@angorafdtd.org>.

 -- Global variable: string recorder_output_dir (default: `"recorder"')
     This determines the subdirectory in which all the
     recording-related stuff will be placed. Unless it has a slash `/'
     up front; this path is interpreted as being relative to
     `output_dir' (*note Paths::).

          recorder_output_dir = "recorder";
          Recorder:
          {
                  ...
                  ...
          };

 -- Global variable: group Recorder
     The `Recorder' group contains the sub-variables related to
     different types of field recording. These are explained in the
     following subsections.

          Recorder:
          {
              MovieRecorders:
              (
                  {
                      ...
                      ...
                  }
              );
              LineRecorders:
              (
                  {
                      ...
                      ...
                  }
              );
              FieldValueRecorders:
              (
                  {
                      ...
                      ...
                  }
              );
          };

* Menu:

* Movie Recording::
* Line Recording::
* Field-Value Recording::


File: angora.info,  Node: Movie Recording,  Next: Line Recording,  Up: Recording

6.11.1 Movie Recording
----------------------

Angora can record field components on a two-dimensional cross section
of the grid into a custom movie file. The binary format used for movie
recording is described in more detail in *Note Movie File Format::.

 -- Sub-variable of Recorder: string movie_recorder_output_dir
          (default: `""')
     This determines the subdirectory in which all the recorded movie
     files will be placed. Unless it has a slash `/' up front; this
     path is interpreted as being relative to `recorder_output_dir'
     (see *Note `recorder_output_dir': recorder_output_dir.).

          Recorder:
          {
              movie_recorder_output_dir = "movies";
              MovieRecorders:
              (
                  ...
                  ...
              );
          };

 -- Sub-variable of Recorder: list MovieRecorders
     Field values on a two-dimensional cross section of the FDTD grid
     can be recorded using the `MovieRecorders' list.

          Recorder:
          {
              MovieRecorders:
              (
                  {
                      recorded_section = "xz";
                      recorded_position = 0;
                      recorded_component = "Ex";
                      recording_scale = "dB";
                      recording_type = "uchar1";
                      movie_dir = "this_movie_dir";
                      movie_file_name = "MovieFile"
                      movie_file_extension = "amv";
                      only_records_material_info = false;
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of MovieRecorders: string recorded_section
          This determines the cross section of the grid over which the
          field is recorded. Currently, only xz, yz, and xy cross
          sections are supported. These are represented by the string
          values `"xz"', `"yz"', and `"xy"', respectively.

      -- Sub-variable of MovieRecorders: floating-point
     recorded_position (units: m)

      -- Sub-variable of MovieRecorders: integer
     recorded_position_in_cells
          This value specifies the coordinate of the recorded cross
          section along the perpendicular direction (e.g., the z
          direction if `recorded_section' is `"xy"'). The coordinate is
          relative to the grid origin (*note Coordinate Origin::). The
          units are either in meters or grid cells. For the latter, the
          `_in_cells' suffix should be appended to the variable name.
          If the coordinate corresponds to a non-integer cell position,
          the closest integer position is chosen.

      -- Sub-variable of MovieRecorders: string recorded_component
          An individual movie recorder (in a group delineated by the
          curly brackets `{}') only records a single scalar value
          extracted from the vector-valued electromagnetic field. This
          could be one of the Cartesian components or the absolute
          value of the electric or the magnetic field. These are
          represented by the string values `"Ex"', `"Ey"', `"Ez"',
          `"E"', `"Hx"', `"Hy"', `"Hz"', and `"H"'. If you would like
          to record multiple Cartesian components of a vector field,
          simply add other movie recorders (i.e., other groups, see
          *Note Groups::) to the `MovieRecorders' list with the desired
          `recorded_component' values.

      -- Sub-variable of MovieRecorders: string recording_scale
          If `"linear"', the raw values are recorded. If `"absolute"',
          the absolute value is taken before recording. If `"dB"', the
          decibel value (20*log10(|x|)) is recorded.

      -- Sub-variable of MovieRecorders: string recording_type
          Movies can either be recorded either in raw floating-point
          format, or in a single-byte compressed format. This is
          specified by assigning the string values `"dbl8"' or
          `"uchar1"' to the `recording_type' variable, respectively.
          Using the single-byte format reduces the file size
          considerably, but results in some data loss.

          If `recording_type' is `"dbl8"', then the field values are
          recorded in 8-byte `double' datatype, after processed in
          accordance with the `recording_scale' specification above.
          This provides practically lossless recording, albeit with
          increased computational burden and file size.

          With the `"uchar1"' option, the field values are reduced to
          256 discrete bins within a fixed _dynamic range_. This
          requires only a single byte per field value; reducing the
          storage requirement by a factor of 8.
             * If `recording_type' is `"dB"', the maximum and minimum
               values in this dynamic range are determined by the
               global variables `max_field_value' and `dB_accuracy'
               (see *Note Dynamic Range::):

               max:  20*log10(|max_field_value|)

               min:  20*log10(|max_field_value|)+(dB_accuracy)

               The `dB_accuracy' variable should always be negative;
               therefore the minimum value in the dynamic range is
               lower than the maximum.

             * If `recording_type' is `"linear"' or`"absolute"', the
               maximum and minimum values are determined only by the
               global variable `max_field_value' (see *Note Dynamic
               Range::):

               max:  max_field_value

               min:  (-max_field_value) or 0

      -- Sub-variable of MovieRecorders: string movie_dir (default:
               `""')
          This determines the subdirectory in which this individual
          movie file will be placed. Unless it has a slash `/' up
          front; this path is interpreted as being relative to
          `movie_recorder_output_dir' (see *Note
          `movie_recorder_output_dir': movie_recorder_output_dir.). By
          default, no subdirectory is created inside
          `movie_recorder_output_dir'.

      -- Sub-variable of MovieRecorders: string movie_file_name
               (default: `"MovieFile"')
          This determines the base string in the full name of the movie
          file. Other information is appended to the name of the file
          to differentiate individual movie files (see the example
          below).

      -- Sub-variable of MovieRecorders: string movie_file_extension
               (default: `"amv"')
          This is the extension of the movie file name. If assigned the
          value `""', no extension is added to the file.
      Here is an example movie file name:
          MovieFile_Ex_0_1.amv
     The base string in the name of the file (`"MovieFile"') is
     specified by the `movie_file_name' variable. The second part of
     the file name, `"Ex"', is determined by the recorded field
     component. The two integers that follow are the run index (see
     *Note Multiple Simulation Runs::) and the index of the movie
     inside the `MovieRecorders' list. For example, if there are two
     groups (two movies) in the `MovieRecorders' list, the first one
     will write into
          MovieFile_Ex_0_0.amv
     while the second will write into
          MovieFile_Ex_0_1.amv
     If there are two simulation runs (i.e., `number_of_runs' is equal
     to 2 - see *Note Multiple Simulation Runs::), then the files
     created in the second run will have `1' instead of `0' as the
     first integer in the above file names. Finally, the extension
     (`"amv"') of the movie files is determined by the variable
     `movie_file_extension'.

      -- Sub-variable of MovieRecorders: boolean
     only_records_material_info (default: `false')
          If set to `true', only the material information is recorded
          into the file, and no field recording is performed during the
          simulation.


* Menu:

* Movie File Format::    Custom binary format for the movie output.


File: angora.info,  Node: Movie File Format,  Up: Movie Recording

6.11.1.1 Movie File Format
..........................

Angora records movies in a custom binary format for better speed and
performance. Please be aware that this format is subject to
modification. The changes in the format will be documented in this
manual as necessary. You may refer to the `ChangeLog' file in the
Angora distribution for recent changes in the movie recording format.

   The MATLAB script `angora_movie.m', distributed as part of the
Angora package, reads an Angora movie file and displays it as a MATLAB
movie. It can also save the movie in AVI format. This script is
installed in the directory `$(prefix)/share/angora/' (see *Note
Compilation and Installation::). If Angora was installed without any
`$(prefix)' configuration option, the default location is
`/usr/local/share/angora/'.

   The movie file is composed of chunks of data, ordered as follows.
For each chunk, a short explanation (and maybe an alias) is given,
followed by a description of the datatype in parantheses.

   * major package version (integer, 4 bytes)

   * minor package version (integer, 4 bytes)

   * package revision number (integer, 4 bytes)

   * number of bytes used to record each field component (integer, 4
     bytes):  This is either equal to `1' or `8', depending on the
     `recording_type' variable.

   * spatial step size (double, 8 bytes)

   * temporal step size (double, 8 bytes)

   * time value that corresponds to the beginning of the simulation
     (double, 8 bytes):  This is usually a negative value, since time
     waveforms frequently begin before t=0.

   * maximum value in the field discretization range (double, 8 bytes):
     This is the maximum value in the discretization dynamic range for
     single-byte recording (i.e., `recording_type' is `"uchar1"'). If
     `recording_type' is `"dbl8"', this value is irrelevant. Same
     applies to the next value in the file.

   * minimum value in the field discretization range (double, 8 bytes)

   * `length_1': length along the first dimension of the recorded array
     (integer, 4 bytes):  If the xy section were recorded, this would
     be the length of the array in the x dimension. This includes the
     thickness of the PML sections in both directions.

   * `length_2': length along the second dimension of the recorded
     array (integer, 4 bytes):  If the xy section were recorded, this
     would be the length of the array in the y dimension. This includes
     the thickness of the PML sections in both directions.

   * `length_time': number of time steps in the simulation (integer, 4
     bytes)

   * thickness of the PML region, in grid cells (integer, 4 bytes):
     See *Note Perfectly-Matched Layer (PML):: for more information on
     the PML. The PML sections are included in the recorded cross
     sectional area. They can easily be removed in post-processing.

   * an array of length `length_1' with the actual physical coordinates
     (in m) along the first dimension of the recorded cross section
     (double, 8 bytes)

   * an array of length `length_2' with the actual physical coordinates
     (in m) along the second dimension of the recorded cross section
     (double, 8 bytes)

   * an array of length (`length_2' x `length_1') holding the relative
     permittivity (if the electric field is recorded) or the relative
     permeability (if the magnetic field is recorded) values on the
     recorded cross section (double, 8 bytes): See printed manual for a
     graphical illustration of the 2D data layout in the movie-file .

   * an array of length (`length_2' x `length_1') holding the electric
     conductivity values (in Siemens/m, if the electric field is
     recorded) or the magnetic conductivity values (in Ohm/m, if the
     magnetic field is recorded) on the recorded cross section (double,
     8 bytes):  The 2D cross section is laid out in the movie file in
     the same way as the previous array.

   * arrays (movie frames) of length (`length_2' x `length_1') holding
     the field values on the recorded cross section (double, 8 bytes OR
     unsigned char, 1 byte - depending on `recording_type'):  The total
     number of these movie frames is equal to `length_time', read
     earlier from the binary file. Each of these frames is laid out in
     the movie file in the same way as the previous arrays.


File: angora.info,  Node: Line Recording,  Next: Field-Value Recording,  Prev: Movie Recording,  Up: Recording

6.11.2 Line Recording
---------------------

Angora can record field components along a line into a file. The binary
format used for line recording is described in more detail in *Note
Line File Format::.

 -- Sub-variable of Recorder: string line_recorder_output_dir (default:
          `""')
     This determines the subdirectory in which all the recorded line
     files will be placed. Unless it has a slash `/' up front; this
     path is interpreted as being relative to `recorder_output_dir'
     (see *Note `recorder_output_dir': recorder_output_dir.).

          Recorder:
          {
              line_recorder_output_dir = "lines";
              LineRecorders:
              (
                  ...
                  ...
              );
          };

 -- Sub-variable of Recorder: list LineRecorders
          Recorder:
          {
              LineRecorders:
              (
                  {
                      line_orientation = "y_directed";
                      line_position_x1 = 0;
                      line_position_x2 = 0;
                      recorded_component = "Ex";
                      recording_scale = "linear";
                      line_dir = "this_line_dir";
                      line_file_name = "LineFile";
                      line_file_extension = "aln";
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of LineRecorders: string line_orientation
          There are three possible orientations for the line over which
          the field values are recorded .These orientations are along
          the three principal axes of the grid; namely, the x,y, and z
          directions. These are specified by the strings
          `"x_directed"', `"y_directed"', and `"z_directed"',
          respectively.

      -- Sub-variable of LineRecorders: floating-point line_position_x1
               (units: m)

      -- Sub-variable of LineRecorders: integer
     line_position_x1_in_cells
          This is the first of the remaining two coordinates that
          specify the position of the recorded line. The coordinate is
          relative to the grid origin (*note Coordinate Origin::). For
          example, if the line is oriented in the y direction
          (`line_orientation' is `"y_directed"'), then
          `line_position_x1_in_cells' specifies the x coordinate of the
          line. The units are either in meters or grid cells. For the
          latter, the `_in_cells' suffix should be appended to the
          variable name. If the coordinate corresponds to a non-integer
          cell position, the closest integer position is chosen.

      -- Sub-variable of LineRecorders: floating-point line_position_x2
               (units: m)

      -- Sub-variable of LineRecorders: integer
     line_position_x2_in_cells
          This is the second of the remaining two coordinates that
          specify the position of the recorded line. The coordinate is
          relative to the grid origin (*note Coordinate Origin::). For
          example, if the line is oriented in the y direction
          (`line_orientation' is `"y_directed"'), then
          `line_position_x2_in_cells' specifies the z coordinate of the
          line. The units are either in meters or grid cells. For the
          latter, the `_in_cells' suffix should be appended to the
          variable name. If the coordinate corresponds to a non-integer
          cell position, the closest integer position is chosen.

      -- Sub-variable of LineRecorders: string recorded_component
          An individual line recorder (in a group delineated by the
          curly brackets `{}') only records a single scalar value
          extracted from the vector-valued electromagnetic field. This
          could be one of the Cartesian components or the absolute
          value of the electric or the magnetic field. These are
          represented by the string values `"Ex"', `"Ey"', `"Ez"',
          `"E"', `"Hx"', `"Hy"', `"Hz"', and `"H"'. If you would like
          to record multiple Cartesian components of a vector field,
          simply add other line recorders (i.e., other groups, see
          *Note Groups::) to the `LineRecorders' list with the desired
          `recorded_component' values.

      -- Sub-variable of LineRecorders: string recording_scale
          If `"linear"', the raw values are recorded. If `"absolute"',
          the absolute value is taken before recording. If `"dB"', the
          decibel value (20*log10(|x|)) is recorded.

      -- Sub-variable of LineRecorders: string line_dir (default: `""')
          This determines the subdirectory in which this individual
          line file will be placed. Unless it has a slash `/' up front;
          this path is interpreted as being relative to
          `line_recorder_output_dir' (see *Note
          `line_recorder_output_dir': line_recorder_output_dir.). By
          default, no subdirectory is created inside
          `line_recorder_output_dir'.

      -- Sub-variable of LineRecorders: string line_file_name (default:
               `"LineFile"')
          This determines the base string in the full name of the line
          file. Other information is appended to the name of the file
          to differentiate individual line files (see the example
          below).

      -- Sub-variable of LineRecorders: string line_file_extension
               (default: `"aln"')
          This is the extension of the line file name. If assigned the
          value `""', no extension is added to the file.
      Here is an example line file name:
          LineFile_Ey_Y_0_1.aln
     The base string in the name of the file (`"LineFile"') is
     specified by the `line_file_name' variable. The second part of the
     file name, `"Ey"', is determined by the recorded field component.
     The following string `"Y"' indicates the orientation of the line,
     which is y-directed for this example. The two integers that follow
     are the run index (see *Note Multiple Simulation Runs::) and the
     index of the line recorder inside the `LineRecorders' list. For
     example, if there are two groups (two line recorders) in the
     `LineRecorders' list, the first one will write into
          LineFile_Ey_Y_0_0.aln
     while the second will write into
          LineFile_Ey_Y_0_1.aln
     If there are two simulation runs (i.e., `number_of_runs' is equal
     to 2 - see *Note Multiple Simulation Runs::), then the files
     created in the second run will have `1' instead of `0' as the
     first integer in the above file names. Finally, the extension
     (`"aln"') of the line files is determined by the variable
     `line_file_extension'.


* Menu:

* Line File Format::    Custom binary format for the line-recorder output.


File: angora.info,  Node: Line File Format,  Up: Line Recording

6.11.2.1 Line File Format
.........................

As with movies, Angora records the line files in a custom binary format
for better speed and performance. Please be aware that this format is
subject to modification. The changes in the format will be documented
in this manual as necessary. You may refer to the `ChangeLog' file in
the Angora distribution for recent changes in the line recording format.

   The MATLAB script `angora_line.m', distributed as part of the Angora
package, reads an Angora line file and displays it as a MATLAB movie.
This script is installed in the directory `$(prefix)/share/angora/'
(see *Note Compilation and Installation::). If Angora was installed
without any `$(prefix)' configuration option, the default location is
`/usr/local/share/angora/'.

   The line file is composed of chunks of data, ordered as follows. For
each chunk, a short explanation (and maybe an alias) is given, followed
by a description of the datatype in parantheses.

   * major package version (integer, 4 bytes)

   * minor package version (integer, 4 bytes)

   * package revision number (integer, 4 bytes)

   * temporal step size (double, 8 bytes)

   * time value that corresponds to the beginning of the simulation
     (double, 8 bytes):  This is usually a negative value, since time
     waveforms frequently begin before t=0.

   * `total_length': the number of recorded elements on each line
     snapshot (integer, 4 bytes)

   * `length_time': number of time steps in the simulation (integer, 4
     bytes)

   * thickness of the PML region, in grid cells (integer, 4 bytes):
     See *Note Perfectly-Matched Layer (PML):: for more information on
     the PML. The recorded line includes two PML sections on opposite
     ends, each with this length. These sections can easily be removed
     in post-processing.

   * arrays (line snapshots) of length `total_length' holding the field
     values on the recorded line (double, 8 bytes):  The total number
     of these line snapshots is equal to `length_time', read earlier
     from the binary file.


File: angora.info,  Node: Field-Value Recording,  Prev: Line Recording,  Up: Recording

6.11.3 Field-Value Recording
----------------------------

Angora can record the time history of the field at a given position in
the simulation grid. The format used for this sort of recording is
*HDF5* (Hierarchical Data Format) (`http://www.hdfgroup.org/HDF5/').
The HDF5 format was chosen for its standard interface, and the
availability of free software tools for inspecting and modifying HDF5
output. The HDF5 output created by the field-value recorder is
explained in more detail in *Note Field-Value File HDF5 Content::.

 -- Sub-variable of Recorder: string field_value_recorder_output_dir
          (default: `""')
     This determines the subdirectory in which all the recorded
     field-value files will be placed. Unless it has a slash `/' up
     front; this path is interpreted as being relative to
     `recorder_output_dir' (see *Note `recorder_output_dir':
     recorder_output_dir.).

          Recorder:
          {
              field_value_recorder_output_dir = "fieldvalues";
              FieldValueRecorders:
              (
                  ...
                  ...
              );
          };

 -- Sub-variable of Recorder: list FieldValueRecorders
          Recorder:
          {
              FieldValueRecorders:
              (
                  {
                      coord_x = 0;
                      coord_y = 0;
                      coord_z = 0;
                      recorded_component = "Ex";
                      recording_scale = "linear";
                      field_value_dir = "this_field_value_dir";
                      field_value_file_name = "FieldValueFile";
                      field_value_file_extension = "hd5";
                  },
                  {
                      ...
                      ...
                  }
              );
          };

      -- Sub-variable of FieldValueRecorders: floating-point coord_x
               (units: m)

      -- Sub-variable of FieldValueRecorders: integer coord_x_in_cells
          This is the x coordinate of the recorded position in the
          simulation grid. It is relative to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name. If the coordinate corresponds
          to a non-integer cell position, the closest integer position
          is chosen.

      -- Sub-variable of FieldValueRecorders: floating-point coord_y
               (units: m)

      -- Sub-variable of FieldValueRecorders: integer coord_y_in_cells
          This is the y coordinate of the recorded position in the
          simulation grid. It is relative to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name. If the coordinate corresponds
          to a non-integer cell position, the closest integer position
          is chosen.

      -- Sub-variable of FieldValueRecorders: floating-point coord_z
               (units: m)

      -- Sub-variable of FieldValueRecorders: integer coord_z_in_cells
          This is the z coordinate of the recorded position in the
          simulation grid. It is relative to the grid origin (*note
          Coordinate Origin::). The units are either in meters or grid
          cells. For the latter, the `_in_cells' suffix should be
          appended to the variable name. If the coordinate corresponds
          to a non-integer cell position, the closest integer position
          is chosen.

      -- Sub-variable of FieldValueRecorders: string recorded_component
          An individual field-value recorder (in a group delineated by
          the curly brackets `{}') only records a single scalar value
          extracted from the vector-valued electromagnetic field. This
          could be one of the Cartesian components or the absolute
          value of the electric or the magnetic field. These are
          represented by the string values `"Ex"', `"Ey"', `"Ez"',
          `"E"', `"Hx"', `"Hy"', `"Hz"', and `"H"'. If you would like
          to record multiple Cartesian components of a vector field,
          simply add other field-value recorders (i.e., other groups,
          see *Note Groups::) to the `FieldValueRecorders' list with
          the desired `recorded_component' values.

      -- Sub-variable of FieldValueRecorders: string recording_scale
          If `"linear"', the raw values are recorded. If `"absolute"',
          the absolute value is taken before recording. If `"dB"', the
          decibel value (20*log10(|x|)) is recorded.

      -- Sub-variable of FieldValueRecorders: string field_value_dir
               (default: `""')
          This determines the subdirectory in which this individual
          field-value file will be placed. Unless it has a slash `/' up
          front; this path is interpreted as being relative to
          `field_value_recorder_output_dir' (see *Note
          `field_value_recorder_output_dir':
          field_value_recorder_output_dir.). By default, no
          subdirectory is created inside
          `field_value_recorder_output_dir'.

      -- Sub-variable of FieldValueRecorders: string
     field_value_file_name (default: `"FieldValueFile"')
          This determines the base string in the full name of the
          field-value file. Other information is appended to the name
          of the file to differentiate individual field-value files
          (see the example below).

      -- Sub-variable of FieldValueRecorders: string
     field_value_file_extension (default: `"hd5"')
          This is the extension of the field-value file name. If
          assigned the value `""', no extension is added to the file.
          The HDF5 extension `"hd5"' is applied by default.
      Here is an example field-value file name:
          FieldValueFile_Ex_0_1.hd5
     The base string in the name of the file (`"FieldValueFile"') is
     specified by the `field_value_file_name' variable. The second part
     of the file name, `"Ex"', is determined by the recorded field
     component. The two integers that follow are the run index (see
     *Note Multiple Simulation Runs::) and the index of the field-value
     recorder inside the `FieldValueRecorders' list. For example, if
     there are two groups (two field-value recorders) in the
     `FieldValueRecorders' list, the first one will write into
          FieldValueFile_Ex_0_0.hd5
     while the second will write into
          FieldValueFile_Ex_0_1.hd5
     If there are two simulation runs (i.e., `number_of_runs' is equal
     to 2 - see *Note Multiple Simulation Runs::), then the files
     created in the second run will have `1' instead of `0' as the
     first integer in the above file names. Finally, the extension
     (`"hd5"') of the line files is determined by the variable
     `field_value_file_extension'.


* Menu:

* Field-Value File HDF5 Content::    Explanation of the HDF5 content in the field-value-recorder output file.


File: angora.info,  Node: Field-Value File HDF5 Content,  Up: Field-Value Recording

6.11.3.1 Field-Value File HDF5 Content
......................................

The HDF5 file created as the output of the field-value recorder can be
viewed and modified using freely-available tools. One of these tools is
HDFView (http://www.hdfgroup.org/hdf-java-html/hdfview/), provided by
the HDF Group. MATLAB also has built-in functions and tools that handle
HDF5 files. For reference, a MATLAB script named `angora_fieldvalue.m'
is distributed as part of the Angora package, which reads an Angora
field-value file and plots the recorded waveform. This script is
installed in the directory `$(prefix)/share/angora/' (see *Note
Compilation and Installation::). If Angora was installed without any
`$(prefix)' configuration option, the default location is
`/usr/local/share/angora/'.

   The HDF5 datasets in the field-value file are the following:

   * `angora_version':  An integer array of length 3 with the major
     version, minor version, and revision numbers of the Angora package
     used to create the file.

   * `time_step':  A floating-point value specifying the temporal step
     in the simulation (in sec).

   * `initial_time_value':  A floating-point value specifying the time
     value corresponding to the beginning of the simulation (in sec).
     This is usually a negative value, since time waveforms frequently
     begin before t=0.

   * `field_values':  A 1-D floating-point array with the recorded
     field values.


File: angora.info,  Node: Paths,  Next: Logging,  Prev: Recording,  Up: Configuration Variables

6.12 Paths
==========

 -- Global variable: string angora_basepath (default: `"."')
     This variable specifies the base directory for all the
     input-output operations in Angora. If there is no slash `/' in
     front of the path, it is interpreted as a relative path starting
     from the working directory (i.e, the one from which Angora is
     launched.)

     Any other input or output directory will be assumed _relative_ to
     `angora_basepath'. An overarching exception is when a directory is
     specified with a slash `/' up front; in which case that directory
     will be taken as an _absolute path_, and not relative to
     `angora_basepath'.


 -- Global variable: string output_dir (default: `"output"')
     This is the base directory for all the output that will result
     from Angora. It is interpreted as being relative to
     `angora_basepath', unless it is preceded by a slash `/'. All other
     output directories are created as subdirectories of this directory.

     Example:

          angora_basepath = "angora_stuff";
          output_dir = "data";

     With these variable assignments, all the output will be written
     into subdirectories within `./angora_stuff/data/'.

 -- Global variable: string input_dir
     This is the base directory for all the input that will be read by
     Angora. It is interpreted as being relative to `angora_basepath',
     unless it is preceded by a slash `/'. Unless the path to an input
     file is absolute (i.e., preceded by a slash `/'), it is
     interpreted as being relative to `input_dir'.

     Example:

          angora_basepath = "angora_stuff";
          input_dir = "input_data";

     With these variable assignments, the input base directory becomes
     `./angora_stuff/input_data/'.


File: angora.info,  Node: Logging,  Next: Multiple Simulation Runs,  Prev: Paths,  Up: Configuration Variables

6.13 Logging
============

You can keep a log of the simulations run by Angora in a log file,
which contains several lines of information for each simulation. First,
an estimate of the finishing time and duration of the simulation is
written into the log entry. The actual finishing time and duration is
added to the log entry upon completion of the simulation.

   Here is an example entry for a simulation in the log file:

     johndoe started Angora on 02/22/12 11:54:36AM
         Estimated to finish on 02/22/12 11:54:42AM
         Estimated duration : 6 seconds.
         Simulation finished on 02/22/12 11:54:42AM
         Elapsed time : 6 seconds.

 -- Global variable: boolean enable_logging (default: `"true"')
     If set to `true', Angora will keep a record of the simulations
     that it runs in a log file. The name of this log file is specified
     by the `log_file_name' variable, and the directory in which this
     file resides is specified by the `log_output_dir' variable.

 -- Global variable: string log_file_name (default: `"angora.log"')
     This is the name of the Angora log file. It resides in the
     directory specified by the `log_output_dir' variable.

 -- Global variable: string log_output_dir (default: `"log"')
     This is the directory in which the Angora log file is kept. Unless
     it is preceded by a slash `/', it is taken as relative to the base
     output directory `output_dir' (*note Paths::).


File: angora.info,  Node: Multiple Simulation Runs,  Next: Miscellaneous,  Prev: Logging,  Up: Configuration Variables

6.14 Multiple Simulation Runs
=============================

A number of consecutive Angora simulations can be set up in a single
configuration file.

 -- Global variable: integer number_of_runs (default: `1')
     The number of simulation runs is specified by the `number_of_runs'
     variable. The simulation runs (or _runs_ for short) are indexed
     from `0' to `number_of_runs-1'. You can refer to these indices
     later in the configuration file for enabling or disabling certain
     configuration variables for certain runs (*note
     `enabled_for_runs': enabled_for_runs.).

 -- Global variable: integer-array disabled_runs (default: none)
     This array of integers (see *Note Arrays::) lists the run indices
     for simulations that will be skipped.

     Example:

          disabled_runs = [1,2,3,4,5];

     If `number_of_runs' was `7', the above variable will cause only
     the simulations with indices `0' and `6' to be run.


 -- Global variable: integer-array disabled_run_range (default: none)
     If you would like to disable simulations that correspond to a
     _range_ of run indices, you can use this variable. This has to be
     an array of integers with only two elements (*note Arrays::).
     Simulations with run indices between (and including) these two
     integers will be skipped.

     The following variable assignment has the same effect as the one
     in the previous example:

          disabled_run_range = [1,5];

 -- Sub-variable of any group: integer-array enabled_for_runs (default:
          all)

 -- Sub-variable of any group: integer-array enabled_for_run_range
          (default: all)
     Certain variables can be _enabled_ or _disabled_ for any of the
     simulation runs using the `enabled_for_runs' or
     `enabled_for_run_range' arrays. These arrays can be used inside
     any group structure (see *Note Groups::) to specify the run
     indices for which that group is enabled.

     The `enabled_for_runs' array simply lists the run indices for
     which the specific group is enabled. For example,

          number_of_runs = 4;
          PointSources:
          (
              {
                  //point source #1
                  enabled_for_runs = [0,1,2];
                  coord_x_in_cells = 0;
                  coord_y_in_cells = 0;
                  coord_z_in_cells = 0;
                  source_orientation = "x_directed";
                  waveform_tag = "waveform1";
              },
              {
                  //point source #2
                  enabled_for_runs = [3];
                  coord_x_in_cells = 0;
                  coord_y_in_cells = 0;
                  coord_z_in_cells = 0;
                  source_orientation = "x_directed";
                  waveform_tag = "waveform2";
              }
          );

     In this example, each group represents a collection of variable
     assignments that characterize an individual point source. With the
     `enabled_for_runs' variables set as shown, simulations `0', `1',
     and `2' will be run with the first point source; whereas
     simulation `3' will be run with the second point source.

     Alternatively, the `enabled_for_run_range' array can be used to
     specify a range of run indices for which the group is enabled.
     This should be an integer array of length two. It specifies the
     lower and upper limits of the range of run indices for the
     specific group. For example,

          number_of_runs = 10;
          PointSources:
          (
              {
                  enabled_for_run_range = [0,5];
                  coord_x_in_cells = 0;
                  coord_y_in_cells = 0;
                  coord_z_in_cells = 0;
                  source_orientation = "x_directed";
                  waveform_tag = "waveform1";
              }
          );

     This point source will only be enabled for run indices `0', `1',
     `2', `3', `4', and `5'.



File: angora.info,  Node: Miscellaneous,  Prev: Multiple Simulation Runs,  Up: Configuration Variables

6.15 Miscellaneous
==================

* Menu:

* Auto-Saving the Configuration::    Keeping record of the simulation configuration.


File: angora.info,  Node: Auto-Saving the Configuration,  Up: Miscellaneous

6.15.1 Auto-Saving the Configuration
------------------------------------

Angora can automatically save a record of every simulation
configuration that it processes.

 -- Global variable: boolean auto_save_cfg (default: `"false"')
     If set to `true', Angora will automatically write every simulation
     configuration it runs into another configuration file, and save it
     in the directory specified by `cfg_output_dir'. A time/date string
     is appended to the name of the saved file to differentiate between
     subsequent executions of the same configuration file.

 -- Global variable: string cfg_output_dir (default: `"cfg"')
     This is the directory in which the auto-saved configuration files
     are placed. Unless it is preceded by a slash `/', it is taken as
     relative to the base output directory `output_dir' (*note Paths::).


File: angora.info,  Node: References,  Next: Indices,  Prev: Configuration Variables,  Up: Top

7 References
************

[Matzler02]  C. Matzler, "MATLAB Functions for Mie Scattering and
Absorption Version 2," [Online]. Available:
http://www.iap.unibe.ch/publications/download/199/en/. [Accessed April
2012].

   [Roden00]  J. A. Roden and S. D. Gedney, "Convolution PML (CPML): an
efficient FDTD implementation of the CFD-PML for arbitrary media,"
Microw. Opt. Technol. Lett., vol. 27, pp. 334-9, Dec. 2000.

   [Kuzuoglu96]   M. Kuzuoglu and R. Mittra, "Frequency dependence of
the constitutive parameters of causal perfectly matched absorbers,"
IEEE Microwave Guided Wave Lett., vol. 6, pp. 447-449, Dec. 1996.

   [Berenger02]   J.-P. Berenger,"Numerical reflection from FDTD-PMLs:
a comparison of the split PML with the unsplit and CFS PMLs," IEEE
Trans. Antennas Propag, vol. 50, pp.258-265, Mar 2002.

   [Rogers09]   J. D. Rogers, I. R. Capoglu, V. Backman, "Nonscalar
elastic light scattering from continuous media in the Born
approximation", Optics Letters, vol. 34, no. 12, pp. 1891-1893, 2009.

   [Richards59]   B. Richards and E. Wolf, "Electromagnetic diffraction
in optical systems. II. Structure of the image field in an aplanatic
system," Proc. Roy. Soc. A, vol. 253, no. 1274, pp.358379, Dec. 1959.

   [Capoglu08]   I. R. Capoglu, A. Taflove, and V. Backman, "Generation
of an incident focused light pulse in FDTD," Optics Express, vol. 16,
no. 23, pp. 19,20819,220, Nov. 2008.

   [Capoglu12]   I. R. Capoglu, A. Taflove, V. Backman, "A
frequency-domain near-field-to-far-field transform for planar layered
media", IEEE Trans. Antennas Propag, vol. 60 No. 04, Apr. 2012.

   [Capoglu12b]   I. R. Capoglu, J. D. Rogers, A. Taflove, V. Backman,
"The microscope in a computer:  Image synthesis from three-dimensional
full-vector solutions of Maxwells equations at the nanometer scale",
Progress in Optics, (to appear in vol. 57, 2012.)

   [TafloveHagness]   A. Taflove and S. C. Hagness (2005).
Computational Electrodynamics: The Finite-Difference Time-Domain
Method, 3rd ed.. Artech House Publishers. ISBN 1-58053-832-0.

   [Hwang01]   K.-P. Hwang and A. C. Cangellaris, Effective
permittivities for second-order accurate FDTD equations at dielectric
interfaces, IEEE Microw. Wireless Compon. Lett., vol. 11, no. 4, pp.
15860, Apr. 2001.


File: angora.info,  Node: Indices,  Prev: References,  Up: Top

Indices
*******

* Menu:

* Configuration Variable Index::    Index of Angora configuration variables.
* Concept Index::    Index of Angora concepts.


File: angora.info,  Node: Configuration Variable Index,  Next: Concept Index,  Up: Indices

Configuration Variable Index
============================

 [index ]
* Menu:

* alpha:                                 Focused Laser Beams. (line 142)
* amplitude <1>:                         Modulated-Gaussian Waveforms.
                                                              (line  56)
* amplitude <2>:                         Differentiated-Gaussian Waveforms.
                                                              (line  45)
* amplitude:                             Gaussian Waveforms.  (line  42)
* anchor:                                File Input.          (line 148)
* angora_basepath:                       Paths.               (line   7)
* ap_half_angle <1>:                     Focused Laser Beams. (line 177)
* ap_half_angle:                         Optical Imaging.     (line 224)
* append_run_index_to_name:              File Input.          (line  81)
* auto_save_cfg:                         Auto-Saving the Configuration.
                                                              (line  10)
* back_coord_x:                          Rectangular Boxes.   (line  41)
* back_coord_x_in_cells:                 Rectangular Boxes.   (line  59)
* back_focal_length:                     Focused Laser Beams. (line 190)
* back_focal_length_in_cells:            Focused Laser Beams. (line 193)
* center_coord_x:                        Spheres.             (line  39)
* center_coord_x_in_cells:               Spheres.             (line  47)
* center_coord_y:                        Spheres.             (line  42)
* center_coord_y_in_cells:               Spheres.             (line  49)
* center_coord_z:                        Spheres.             (line  45)
* center_coord_z_in_cells:               Spheres.             (line  51)
* cfg_output_dir:                        Auto-Saving the Configuration.
                                                              (line  17)
* coll_half_space:                       Optical Imaging.     (line 295)
* constitutive_param_type <1>:           File Input.          (line 100)
* constitutive_param_type:               Random Materials.    (line  84)
* coord:                                 Ground Planes.       (line  27)
* coord_in_cells:                        Ground Planes.       (line  29)
* coord_x <1>:                           Field-Value Recording.
                                                              (line  56)
* coord_x <2>:                           Point Sources.       (line  39)
* coord_x:                               File Input.          (line 176)
* coord_x_in_cells <1>:                  Field-Value Recording.
                                                              (line  58)
* coord_x_in_cells <2>:                  Point Sources.       (line  45)
* coord_x_in_cells:                      File Input.          (line 184)
* coord_y <1>:                           Field-Value Recording.
                                                              (line  68)
* coord_y <2>:                           Point Sources.       (line  41)
* coord_y:                               File Input.          (line 179)
* coord_y_in_cells <1>:                  Field-Value Recording.
                                                              (line  70)
* coord_y_in_cells <2>:                  Point Sources.       (line  47)
* coord_y_in_cells:                      File Input.          (line 186)
* coord_z <1>:                           Field-Value Recording.
                                                              (line  80)
* coord_z <2>:                           Point Sources.       (line  43)
* coord_z:                               File Input.          (line 182)
* coord_z_in_cells <1>:                  Field-Value Recording.
                                                              (line  82)
* coord_z_in_cells <2>:                  Point Sources.       (line  49)
* coord_z_in_cells:                      File Input.          (line 188)
* corr_len:                              Random Materials.    (line 152)
* corr_len_in_cells:                     Random Materials.    (line 155)
* courant:                               Courant Factor.      (line   7)
* cpml_feature_size:                     Perfectly-Matched Layer (PML).
                                                              (line  41)
* cpml_feature_size_in_cells:            Perfectly-Matched Layer (PML).
                                                              (line  45)
* datatype:                              File Input.          (line 198)
* dB_accuracy:                           Dynamic Range.       (line  16)
* delay <1>:                             Modulated-Gaussian Waveforms.
                                                              (line  71)
* delay <2>:                             Differentiated-Gaussian Waveforms.
                                                              (line  55)
* delay:                                 Gaussian Waveforms.  (line  52)
* differentiated:                        Modulated-Gaussian Waveforms.
                                                              (line  84)
* DifferentiatedGaussianWaveforms:       Differentiated-Gaussian Waveforms.
                                                              (line   7)
* dir1_max:                              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 219)
* dir1_min:                              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 217)
* dir2_max:                              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 233)
* dir2_min:                              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 231)
* direction_spec:                        Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 187)
* disabled_run_range:                    Multiple Simulation Runs.
                                                              (line  30)
* disabled_runs:                         Multiple Simulation Runs.
                                                              (line  18)
* display_warnings <1>:                  Focused Laser Beams. (line 299)
* display_warnings:                      Plane Waves.         (line 181)
* do_not_include_first_lambda <1>:       Optical Imaging.     (line 183)
* do_not_include_first_lambda:           Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 147)
* do_not_include_last_lambda <1>:        Optical Imaging.     (line 186)
* do_not_include_last_lambda:            Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 150)
* dx:                                    Spatial Step Size.   (line   7)
* electric_conductivity:                 Materials.           (line  55)
* enable_logging:                        Logging.             (line  21)
* enabled_for_run_range:                 Multiple Simulation Runs.
                                                              (line  46)
* enabled_for_runs:                      Multiple Simulation Runs.
                                                              (line  43)
* f_0:                                   Modulated-Gaussian Waveforms.
                                                              (line  66)
* far_field_dir <1>:                     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 343)
* far_field_dir:                         Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 180)
* far_field_file_extension <1>:          Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 359)
* far_field_file_extension:              Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 196)
* far_field_file_name <1>:               Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 352)
* far_field_file_name:                   Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 189)
* far_field_origin_x <1>:                Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 317)
* far_field_origin_x:                    Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 154)
* far_field_origin_x_in_cells <1>:       Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 326)
* far_field_origin_x_in_cells:           Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 163)
* far_field_origin_y <1>:                Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 320)
* far_field_origin_y:                    Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 157)
* far_field_origin_y_in_cells <1>:       Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 329)
* far_field_origin_y_in_cells:           Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 166)
* far_field_origin_z <1>:                Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 323)
* far_field_origin_z:                    Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 160)
* far_field_origin_z_in_cells <1>:       Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 332)
* far_field_origin_z_in_cells:           Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 169)
* field_value_dir:                       Field-Value Recording.
                                                              (line 110)
* field_value_file_extension:            Field-Value Recording.
                                                              (line 128)
* field_value_file_name:                 Field-Value Recording.
                                                              (line 121)
* field_value_recorder_output_dir:       Field-Value Recording.
                                                              (line  16)
* FieldValueRecorders:                   Field-Value Recording.
                                                              (line  33)
* file_extension:                        File Input.          (line  75)
* file_name:                             File Input.          (line  67)
* filling_factor:                        Focused Laser Beams. (line 200)
* flb_extra_amplitude:                   Focused Laser Beams. (line 172)
* flb_origin_x:                          Focused Laser Beams. (line 275)
* flb_origin_x_in_cells:                 Focused Laser Beams. (line 284)
* flb_origin_y:                          Focused Laser Beams. (line 278)
* flb_origin_y_in_cells:                 Focused Laser Beams. (line 287)
* flb_origin_z:                          Focused Laser Beams. (line 281)
* flb_origin_z_in_cells:                 Focused Laser Beams. (line 290)
* FocusedLaserBeams:                     Focused Laser Beams. (line  65)
* front_coord_x:                         Rectangular Boxes.   (line  44)
* front_coord_x_in_cells:                Rectangular Boxes.   (line  62)
* GaussianWaveforms:                     Gaussian Waveforms.  (line   7)
* grid_dimension_x:                      Grid Dimensions.     (line   7)
* grid_dimension_x_in_cells:             Grid Dimensions.     (line  13)
* grid_dimension_y:                      Grid Dimensions.     (line   9)
* grid_dimension_y_in_cells:             Grid Dimensions.     (line  15)
* grid_dimension_z:                      Grid Dimensions.     (line  11)
* grid_dimension_z_in_cells:             Grid Dimensions.     (line  17)
* GroundPlanes:                          Ground Planes.       (line   7)
* image_expansion_factor_x:              Optical Imaging.     (line 246)
* image_expansion_factor_y:              Optical Imaging.     (line 249)
* image_origin_x:                        Optical Imaging.     (line 347)
* image_origin_x_in_cells:               Optical Imaging.     (line 356)
* image_origin_y:                        Optical Imaging.     (line 350)
* image_origin_y_in_cells:               Optical Imaging.     (line 359)
* image_origin_z:                        Optical Imaging.     (line 353)
* image_origin_z_in_cells:               Optical Imaging.     (line 362)
* image_oversampling_rate_x:             Optical Imaging.     (line 263)
* image_oversampling_rate_y:             Optical Imaging.     (line 266)
* image_space_refr_index:                Optical Imaging.     (line 241)
* imaging_output_dir:                    Optical Imaging.     (line  30)
* input_dir:                             Paths.               (line  35)
* j_0:                                   Point Sources.       (line  70)
* lambda_max <1>:                        Optical Imaging.     (line 152)
* lambda_max:                            Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 117)
* lambda_max_in_cells <1>:               Optical Imaging.     (line 155)
* lambda_max_in_cells:                   Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 120)
* lambda_min <1>:                        Optical Imaging.     (line 139)
* lambda_min:                            Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 105)
* lambda_min_in_cells <1>:               Optical Imaging.     (line 142)
* lambda_min_in_cells:                   Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 108)
* lambda_spacing_type <1>:               Optical Imaging.     (line 164)
* lambda_spacing_type:                   Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 128)
* left_coord_y:                          Rectangular Boxes.   (line  47)
* left_coord_y_in_cells:                 Rectangular Boxes.   (line  65)
* limit_to_s:                            Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 238)
* line_dir:                              Line Recording.      (line 108)
* line_file_extension:                   Line Recording.      (line 125)
* line_file_name:                        Line Recording.      (line 118)
* line_orientation:                      Line Recording.      (line  50)
* line_position_x1:                      Line Recording.      (line  59)
* line_position_x1_in_cells:             Line Recording.      (line  62)
* line_position_x2:                      Line Recording.      (line  75)
* line_position_x2_in_cells:             Line Recording.      (line  78)
* line_recorder_output_dir:              Line Recording.      (line  12)
* LineRecorders:                         Line Recording.      (line  28)
* log_file_name:                         Logging.             (line  27)
* log_output_dir:                        Logging.             (line  31)
* lower_coord_z:                         Rectangular Boxes.   (line  53)
* lower_coord_z_in_cells:                Rectangular Boxes.   (line  71)
* m:                                     Random Materials.    (line 162)
* magnetic_conductivity:                 Materials.           (line  60)
* magnification:                         Optical Imaging.     (line 230)
* material_tag <1>:                      Planar Layers.       (line  36)
* material_tag <2>:                      Objects.             (line  33)
* material_tag:                          Materials.           (line  34)
* Materials:                             Materials.           (line  12)
* MaterialsFromFiles:                    File Input.          (line   7)
* MaterialSlabs:                         Planar Layers.       (line   7)
* max_coord:                             Planar Layers.       (line  43)
* max_coord_in_cells:                    Planar Layers.       (line  49)
* max_field_value:                       Dynamic Range.       (line  11)
* max_new_materials:                     File Input.          (line 204)
* mean:                                  Random Materials.    (line 131)
* min_cells_per_lambda <1>:              Focused Laser Beams. (line 302)
* min_cells_per_lambda:                  Plane Waves.         (line 184)
* min_coord:                             Planar Layers.       (line  41)
* min_coord_in_cells:                    Planar Layers.       (line  46)
* ModulatedGaussianWaveforms:            Modulated-Gaussian Waveforms.
                                                              (line   7)
* modulation_type:                       Modulated-Gaussian Waveforms.
                                                              (line  50)
* movie_dir:                             Movie Recording.     (line 133)
* movie_file_extension:                  Movie Recording.     (line 150)
* movie_file_name:                       Movie Recording.     (line 143)
* movie_recorder_output_dir:             Movie Recording.     (line  12)
* MovieRecorders:                        Movie Recording.     (line  28)
* n_diff:                                Differentiated-Gaussian Waveforms.
                                                              (line  59)
* nffft_back_margin_x <1>:               Optical Imaging.     (line 304)
* nffft_back_margin_x <2>:               Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 267)
* nffft_back_margin_x:                   Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 104)
* nffft_back_margin_x_in_cells <1>:      Optical Imaging.     (line 322)
* nffft_back_margin_x_in_cells <2>:      Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 285)
* nffft_back_margin_x_in_cells:          Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 122)
* nffft_front_margin_x <1>:              Optical Imaging.     (line 307)
* nffft_front_margin_x <2>:              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 270)
* nffft_front_margin_x:                  Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 107)
* nffft_front_margin_x_in_cells <1>:     Optical Imaging.     (line 325)
* nffft_front_margin_x_in_cells <2>:     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 288)
* nffft_front_margin_x_in_cells:         Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 125)
* nffft_left_margin_y <1>:               Optical Imaging.     (line 310)
* nffft_left_margin_y <2>:               Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 273)
* nffft_left_margin_y:                   Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 110)
* nffft_left_margin_y_in_cells <1>:      Optical Imaging.     (line 328)
* nffft_left_margin_y_in_cells <2>:      Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 291)
* nffft_left_margin_y_in_cells:          Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 128)
* nffft_lower_margin_z <1>:              Optical Imaging.     (line 316)
* nffft_lower_margin_z <2>:              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 279)
* nffft_lower_margin_z:                  Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 116)
* nffft_lower_margin_z_in_cells <1>:     Optical Imaging.     (line 334)
* nffft_lower_margin_z_in_cells <2>:     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 297)
* nffft_lower_margin_z_in_cells:         Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 134)
* nffft_right_margin_y <1>:              Optical Imaging.     (line 313)
* nffft_right_margin_y <2>:              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 276)
* nffft_right_margin_y:                  Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 113)
* nffft_right_margin_y_in_cells <1>:     Optical Imaging.     (line 331)
* nffft_right_margin_y_in_cells <2>:     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 294)
* nffft_right_margin_y_in_cells:         Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 131)
* nffft_upper_margin_z <1>:              Optical Imaging.     (line 319)
* nffft_upper_margin_z <2>:              Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 282)
* nffft_upper_margin_z:                  Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 119)
* nffft_upper_margin_z_in_cells <1>:     Optical Imaging.     (line 337)
* nffft_upper_margin_z_in_cells <2>:     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 300)
* nffft_upper_margin_z_in_cells:         Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 137)
* num_of_dirs_1:                         Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 210)
* num_of_dirs_2:                         Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 224)
* num_of_lambdas <1>:                    Optical Imaging.     (line 134)
* num_of_lambdas:                        Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 100)
* num_of_time_steps:                     Number of Time Steps.
                                                              (line   7)
* number_of_runs:                        Multiple Simulation Runs.
                                                              (line  10)
* object_space_refr_index:               Focused Laser Beams. (line 211)
* Objects:                               Objects.             (line   7)
* only_records_material_info:            Movie Recording.     (line 174)
* OpticalImages:                         Optical Imaging.     (line  43)
* origin_x:                              Coordinate Origin.   (line   8)
* origin_x_in_cells:                     Coordinate Origin.   (line  17)
* origin_y:                              Coordinate Origin.   (line  11)
* origin_y_in_cells:                     Coordinate Origin.   (line  20)
* origin_z:                              Coordinate Origin.   (line  14)
* origin_z_in_cells:                     Coordinate Origin.   (line  23)
* output_data:                           Optical Imaging.     (line  88)
* output_dir:                            Paths.               (line  21)
* pd_nffft_output_dir:                   Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  46)
* phase:                                 Modulated-Gaussian Waveforms.
                                                              (line  76)
* PhasorDomainNFFFT:                     Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  59)
* phi <1>:                               Focused Laser Beams. (line 109)
* phi <2>:                               Plane Waves.         (line  64)
* phi:                                   Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  77)
* PlaneWaves:                            Plane Waves.         (line  28)
* pml_thickness:                         Perfectly-Matched Layer (PML).
                                                              (line   7)
* pml_thickness_in_cells:                Perfectly-Matched Layer (PML).
                                                              (line   9)
* PointSources:                          Point Sources.       (line   7)
* psi <1>:                               Focused Laser Beams. (line 130)
* psi:                                   Plane Waves.         (line  82)
* pw_extra_amplitude:                    Plane Waves.         (line 106)
* pw_origin_x:                           Plane Waves.         (line 157)
* pw_origin_x_in_cells:                  Plane Waves.         (line 166)
* pw_origin_y:                           Plane Waves.         (line 160)
* pw_origin_y_in_cells:                  Plane Waves.         (line 169)
* pw_origin_z:                           Plane Waves.         (line 163)
* pw_origin_z_in_cells:                  Plane Waves.         (line 172)
* radius:                                Spheres.             (line  58)
* radius_in_cells:                       Spheres.             (line  60)
* random_seed:                           Random Materials.    (line 173)
* RandomMaterials:                       Random Materials.    (line   7)
* recorded_component <1>:                Field-Value Recording.
                                                              (line  91)
* recorded_component <2>:                Line Recording.      (line  90)
* recorded_component:                    Movie Recording.     (line  74)
* recorded_position:                     Movie Recording.     (line  61)
* recorded_position_in_cells:            Movie Recording.     (line  64)
* recorded_section:                      Movie Recording.     (line  54)
* Recorder:                              Recording.           (line  29)
* recorder_output_dir:                   Recording.           (line  16)
* recording_scale <1>:                   Field-Value Recording.
                                                              (line 104)
* recording_scale <2>:                   Line Recording.      (line 103)
* recording_scale:                       Movie Recording.     (line  87)
* recording_type:                        Movie Recording.     (line  92)
* RectangularBoxes:                      Rectangular Boxes.   (line   7)
* rel_permeability:                      Materials.           (line  48)
* rel_permittivity:                      Materials.           (line  40)
* right_coord_y:                         Rectangular Boxes.   (line  50)
* right_coord_y_in_cells:                Rectangular Boxes.   (line  68)
* shape_tag <1>:                         Random Materials.    (line 166)
* shape_tag <2>:                         Objects.             (line  38)
* shape_tag <3>:                         Spheres.             (line  33)
* shape_tag:                             Rectangular Boxes.   (line  35)
* Shapes:                                Shapes.              (line   7)
* SimulationSpace:                       Simulation Space.    (line   7)
* source_orientation:                    Point Sources.       (line  58)
* Spheres:                               Spheres.             (line   7)
* std_dev:                               Random Materials.    (line 147)
* tau <1>:                               Modulated-Gaussian Waveforms.
                                                              (line  61)
* tau <2>:                               Differentiated-Gaussian Waveforms.
                                                              (line  50)
* tau:                                   Gaussian Waveforms.  (line  47)
* td_nffft_output_dir:                   Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  31)
* TFSF:                                  Incident Beams.      (line  10)
* tfsf_back_margin_x <1>:                Focused Laser Beams. (line 225)
* tfsf_back_margin_x:                    Plane Waves.         (line 111)
* tfsf_back_margin_x_in_cells <1>:       Focused Laser Beams. (line 243)
* tfsf_back_margin_x_in_cells:           Plane Waves.         (line 129)
* tfsf_front_margin_x <1>:               Focused Laser Beams. (line 228)
* tfsf_front_margin_x:                   Plane Waves.         (line 114)
* tfsf_front_margin_x_in_cells <1>:      Focused Laser Beams. (line 246)
* tfsf_front_margin_x_in_cells:          Plane Waves.         (line 132)
* tfsf_left_margin_y <1>:                Focused Laser Beams. (line 231)
* tfsf_left_margin_y:                    Plane Waves.         (line 117)
* tfsf_left_margin_y_in_cells <1>:       Focused Laser Beams. (line 249)
* tfsf_left_margin_y_in_cells:           Plane Waves.         (line 135)
* tfsf_lower_margin_z <1>:               Focused Laser Beams. (line 237)
* tfsf_lower_margin_z:                   Plane Waves.         (line 123)
* tfsf_lower_margin_z_in_cells <1>:      Focused Laser Beams. (line 255)
* tfsf_lower_margin_z_in_cells:          Plane Waves.         (line 141)
* tfsf_right_margin_y <1>:               Focused Laser Beams. (line 234)
* tfsf_right_margin_y:                   Plane Waves.         (line 120)
* tfsf_right_margin_y_in_cells <1>:      Focused Laser Beams. (line 252)
* tfsf_right_margin_y_in_cells:          Plane Waves.         (line 138)
* tfsf_upper_margin_z <1>:               Focused Laser Beams. (line 240)
* tfsf_upper_margin_z:                   Plane Waves.         (line 126)
* tfsf_upper_margin_z_in_cells <1>:      Focused Laser Beams. (line 258)
* tfsf_upper_margin_z_in_cells:          Plane Waves.         (line 144)
* theta <1>:                             Focused Laser Beams. (line 106)
* theta <2>:                             Plane Waves.         (line  62)
* theta:                                 Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  74)
* TimeDomainNFFFT:                       Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  44)
* transparent:                           Materials.           (line  65)
* upper_coord_z:                         Rectangular Boxes.   (line  56)
* upper_coord_z_in_cells:                Rectangular Boxes.   (line  74)
* waveform_tag <1>:                      Focused Laser Beams. (line 158)
* waveform_tag <2>:                      Plane Waves.         (line  98)
* waveform_tag <3>:                      Point Sources.       (line  63)
* waveform_tag <4>:                      Modulated-Gaussian Waveforms.
                                                              (line  44)
* waveform_tag <5>:                      Differentiated-Gaussian Waveforms.
                                                              (line  39)
* waveform_tag:                          Gaussian Waveforms.  (line  36)
* Waveforms:                             Waveforms.           (line   7)
* WhittleMaternCorrelated:               Random Materials.    (line  23)
* write_hertzian_dipole_far_field <1>:   Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line 257)
* write_hertzian_dipole_far_field:       Time-Domain Near-Field-to-Far-Field-Transformer.
                                                              (line  92)
* x_order:                               Focused Laser Beams. (line 149)
* y_order:                               Focused Laser Beams. (line 151)


File: angora.info,  Node: Concept Index,  Prev: Configuration Variable Index,  Up: Indices

Concept Index
=============

 [index ]
* Menu:

* Absorbing layers:                      Perfectly-Matched Layer (PML).
                                                                (line 6)
* Arrays:                                Arrays.                (line 6)
* Boolean values:                        Boolean Values.        (line 6)
* Check mode:                            Check Mode.            (line 6)
* Comments, inserting:                   Comments.              (line 6)
* Compiling Angora:                      Compilation and Installation.
                                                                (line 6)
* config_all.cfg:                        Template Configuration File.
                                                                (line 6)
* Configuration file, checking for errors: Check Mode.          (line 6)
* Configuration file, template:          Template Configuration File.
                                                                (line 6)
* Configuration format:                  Configuration Format.  (line 6)
* Configuration variables:               Configuration Variables.
                                                                (line 6)
* Configuration variables, assigning:    Variable Assignment.   (line 6)
* Configuration variables, value types:  Variable Types.        (line 6)
* Configuration, auto-saving:            Auto-Saving the Configuration.
                                                                (line 6)
* Configuring Angora simulations:        Configuration Variables.
                                                                (line 6)
* Courant factor:                        Courant Factor.        (line 6)
* CPML:                                  Perfectly-Matched Layer (PML).
                                                                (line 6)
* Dimensions, grid:                      Grid Dimensions.       (line 6)
* Directories, input:                    Paths.                 (line 6)
* Directories, output:                   Paths.                 (line 6)
* Directories, specifying:               Paths.                 (line 6)
* Documentation, building:               Building the Documentation.
                                                                (line 6)
* Downloading Angora:                    Downloading.           (line 6)
* Dynamic range:                         Dynamic Range.         (line 6)
* Executing Angora:                      Execution.             (line 6)
* Floating-point values:                 Floating-Point Values. (line 6)
* Focused beams:                         Focused Laser Beams.   (line 6)
* Focused Hermite-Gaussian beams:        Focused Laser Beams.   (line 6)
* Focused laser beams:                   Focused Laser Beams.   (line 6)
* Focused laser modes:                   Focused Laser Beams.   (line 6)
* Gaussian waveforms (differentiated), defining: Differentiated-Gaussian Waveforms.
                                                                (line 6)
* Gaussian waveforms (modulated), defining: Modulated-Gaussian Waveforms.
                                                                (line 6)
* Gaussian waveforms, defining:          Gaussian Waveforms.    (line 6)
* Grid size:                             Grid Dimensions.       (line 6)
* Grid spacing:                          Spatial Step Size.     (line 6)
* Grid termination:                      Perfectly-Matched Layer (PML).
                                                                (line 6)
* Ground planes, placing:                Ground Planes.         (line 6)
* Groups:                                Groups.                (line 6)
* Hertzian sources, placing:             Point Sources.         (line 6)
* Imaging:                               Optical Imaging.       (line 6)
* Imaging, HDF5 file content:            Optical Image File HDF5 Content.
                                                                (line 6)
* Incident beams:                        Incident Beams.        (line 6)
* Including other configuration files:   Include Directives.    (line 6)
* Infinitesimal sources, placing:        Point Sources.         (line 6)
* Installing Angora:                     Compilation and Installation.
                                                                (line 6)
* Integer values:                        Integer Values.        (line 6)
* libconfig:                             Configuration Format.  (line 6)
* Lists:                                 Lists.                 (line 6)
* Log, keeping:                          Logging.               (line 6)
* Logging:                               Logging.               (line 6)
* Material files, reading from:          File Input.            (line 6)
* Materials, defining:                   Materials.             (line 6)
* Maximum field value:                   Dynamic Range.         (line 6)
* MPI support:                           Parallel Execution.    (line 6)
* MPI support, enabling:                 Enabling MPI Support.  (line 6)
* Multiple runs:                         Multiple Simulation Runs.
                                                                (line 6)
* Multiple simulations:                  Multiple Simulation Runs.
                                                                (line 6)
* Near-field-to-far-field transformer (NFFFT): Near-Field-to-Far-Field Transformer.
                                                                (line 6)
* Near-field-to-far-field transformer (NFFFT), phasor domain: Phasor-Domain Near-Field-to-Far-Field-Transformer.
                                                                (line 6)
* Near-field-to-far-field transformer (NFFFT), phasor domain, HDF5 file content: HDF5 Content of Phasor-Domain NFFFT Output.
                                                                (line 6)
* Near-field-to-far-field transformer (NFFFT), time domain: Time-Domain Near-Field-to-Far-Field-Transformer.
                                                                (line 6)
* Near-field-to-far-field transformer (NFFFT), time domain, HDF5 file content: HDF5 Content of Time-Domain NFFFT Output.
                                                                (line 6)
* Objects, placing:                      Objects.               (line 6)
* Optical imaging:                       Optical Imaging.       (line 6)
* Optical imaging, HDF5 file content:    Optical Image File HDF5 Content.
                                                                (line 6)
* Origin, global:                        Coordinate Origin.     (line 6)
* Origin, grid:                          Coordinate Origin.     (line 6)
* Parallelization:                       Parallel Execution.    (line 6)
* Parallelization, enabling:             Enabling MPI Support.  (line 6)
* Paths, input:                          Paths.                 (line 6)
* Paths, output:                         Paths.                 (line 6)
* Paths, specifying:                     Paths.                 (line 6)
* PEC planes, placing:                   Ground Planes.         (line 6)
* Perfectly-matched layers:              Perfectly-Matched Layer (PML).
                                                                (line 6)
* Planar layers, placing:                Planar Layers.         (line 6)
* Plane waves:                           Plane Waves.           (line 6)
* PML:                                   Perfectly-Matched Layer (PML).
                                                                (line 6)
* Point sources, placing:                Point Sources.         (line 6)
* Random materials, placing:             Random Materials.      (line 6)
* Recording:                             Recording.             (line 6)
* Recording, cross-section:              Movie Recording.       (line 6)
* Recording, cross-section, file format: Movie File Format.     (line 6)
* Recording, field-value:                Field-Value Recording. (line 6)
* Recording, field-value, HDF5 file format: Field-Value File HDF5 Content.
                                                                (line 6)
* Recording, line:                       Line Recording.        (line 6)
* Recording, line, file format:          Line File Format.      (line 6)
* Recording, movie:                      Movie Recording.       (line 6)
* Recording, movie, file format:         Movie File Format.     (line 6)
* Rectangular boxes, defining:           Rectangular Boxes.     (line 6)
* Running Angora:                        Execution.             (line 6)
* Shapes, defining:                      Shapes.                (line 6)
* Simulations, configuring:              Configuration Variables.
                                                                (line 6)
* Simulations, parallelizing:            Parallel Execution.    (line 6)
* Spheres, defining:                     Spheres.               (line 6)
* Stability:                             Courant Factor.        (line 6)
* Step size, spatial:                    Spatial Step Size.     (line 6)
* Step size, temporal:                   Courant Factor.        (line 6)
* Stratification, defining:              Planar Layers.         (line 6)
* String values:                         String Values.         (line 6)
* Time steps, number of:                 Number of Time Steps.  (line 6)
* Total-field/scattered-field (TF/SF) boundary: Incident Beams. (line 6)
* Total-field/scattered-field (TF/SF) boundary, focused laser beams: Focused Laser Beams.
                                                                (line 6)
* Total-field/scattered-field (TF/SF) boundary, plane waves: Plane Waves.
                                                                (line 6)
* Waveforms, defining:                   Waveforms.             (line 6)



Tag Table:
Node: Top577
Node: Getting Started1561
Node: Downloading6302
Node: Compilation and Installation6811
Node: Enabling MPI Support11021
Node: Building the Documentation12031
Node: Execution12953
Node: Parallel Execution14054
Node: Check Mode15147
Node: Configuration Format15807
Node: Variable Assignment16577
Node: Variable Types17583
Node: Integer Values18390
Node: Floating-Point Values18907
Node: Boolean Values19589
Node: String Values19938
Node: Groups21052
Node: Arrays21673
Node: Lists22101
Node: Comments23181
Node: Include Directives24006
Node: Configuration Variables25062
Node: Template Configuration File27871
Node: Grid Properties28918
Node: Courant Factor29829
Node: Spatial Step Size30386
Node: Grid Dimensions30833
Node: Perfectly-Matched Layer (PML)32064
Node: Number of Time Steps35051
Node: Coordinate Origin35374
Node: Dynamic Range36938
Node: Shapes38189
Node: Rectangular Boxes39431
Node: Spheres42113
Node: Materials44323
Node: Simulation Space47220
Node: Objects48984
Node: Planar Layers50464
Node: Random Materials53640
Node: File Input63332
Ref: datatype72047
Node: Ground Planes73973
Node: Waveforms75384
Node: Gaussian Waveforms76413
Ref: eq:gaussian76711
Node: Differentiated-Gaussian Waveforms78240
Ref: eq:diffgaussian78635
Node: Modulated-Gaussian Waveforms80601
Ref: eq:modgaussian80962
Node: Point Sources84015
Node: Near-Field-to-Far-Field Transformer86852
Node: Time-Domain Near-Field-to-Far-Field-Transformer88561
Ref: eq:far_field_angle_dependence_time_domain89879
Ref: td_nffft_output_dir90052
Ref: far_field_filename_example_time_domain97555
Node: HDF5 Content of Time-Domain NFFFT Output98645
Node: Phasor-Domain Near-Field-to-Far-Field-Transformer101714
Ref: eq:far_field_angle_dependence103889
Ref: pd_nffft_output_dir104129
Ref: far_field_filename_example119381
Node: HDF5 Content of Phasor-Domain NFFFT Output120481
Node: Optical Imaging123849
Ref: imaging_output_dir125207
Node: Optical Image File HDF5 Content141518
Node: Incident Beams145976
Node: Plane Waves149010
Ref: eq:pw_E_field149233
Node: Focused Laser Beams157495
Ref: eq:fb_incident_E_field159177
Node: Recording171898
Ref: recorder_output_dir172543
Node: Movie Recording173759
Ref: movie_recorder_output_dir174100
Ref: movie_filename_example180576
Node: Movie File Format181943
Node: Line Recording186370
Ref: line_recorder_output_dir186690
Ref: line_filename_example192138
Node: Line File Format193368
Node: Field-Value Recording195513
Ref: field_value_recorder_output_dir196133
Ref: field_value_filename_example201512
Node: Field-Value File HDF5 Content202733
Node: Paths204272
Node: Logging206155
Node: Multiple Simulation Runs207718
Ref: enabled_for_runs209307
Ref: enabled_for_run_range209397
Node: Miscellaneous211779
Node: Auto-Saving the Configuration212019
Node: References212955
Ref: Matzler02213080
Ref: Roden00213269
Ref: Kuzuoglu96213469
Ref: Berenger02213674
Ref: Rogers09213868
Ref: Richards59214066
Ref: Capoglu08214281
Ref: Capoglu12214464
Ref: Capoglu12b214658
Ref: TafloveHagness214923
Ref: Hwang01215110
Node: Indices215337
Node: Configuration Variable Index215554
Node: Concept Index249107

End Tag Table

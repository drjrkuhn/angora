\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename angora.info
@set UPDATED May 2012
@set VERSION 0.18.8 and later
@settitle Angora User's Guide
@c %**end of header

@c (IRC 02-17-2012) Rerun autoreconf after modifying this file!!

@dircategory Electromagnetic Simulation
@direntry
* Angora: (angora).           A finite-difference time-domain (FDTD) electromagnetic simulation software.
@end direntry

@copying
Copyright @copyright{} 2012 @dotaccent Ilker R. @,Capo@u glu

Portions of the @command{libconfig} manual were copied verbatim. The @command{libconfig} library is distributed under the GNU Lesser Public License, which can be found at @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html#License}.
@end copying

@titlepage
@title Angora User's Guide
@c The following two commands start the copyright page.
@subtitle A finite-difference time-domain (FDTD) electromagnetic simulation software
@subtitle for version @value{VERSION}, @value{UPDATED}
@author @dotaccent Ilker R. @,Capo@u glu
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c Output the table of contents at the beginning.
@contents

@c @defindex co

@c @ifnottex @c these are not necessary if texi2html (latex2html) is used
@node Top
@top Angora: A finite-difference time-domain simulation package

This is the user's guide for Angora, a software package that computes numerical solutions to electromagnetic radiation and scattering problems. It is based on the finite-difference time-domain (FDTD) method, which one of the most popular approaches for solving Maxwell's equations of electrodynamics.
@c @end ifnottex @c these are not necessary if texi2html (latex2html) is used

@menu
* Getting Started::    A quick example: Scattering from a sphere.
* Downloading::    How to download Angora.
* Compilation and Installation::    How to compile and install Angora.
* Execution::    How to execute Angora.
* Configuration Format::    The text format for specifying simulation variables.
* Configuration Variables::    How to configure Angora for a simulation.
* References::    Bibliographic references cited in this manual.
@ifnotinfo
* List of Figures::
@end ifnotinfo
* Indices::    Concept and variable indices.
@end menu

@node Getting Started
@chapter Getting Started

Angora simulations are run by constructing a text file, called the @emph{configuration file} that specifies all aspects of the simulation. This file is then given as a command-line option to the Angora executable @code{angora}; which reads the configuration file and produces the desired output (see @ref{Execution}).

Let's start with a simple example. In the following, we will show how Angora can be used to solve the problem of electromagnetic scattering from a sphere illuminated by a plane wave.
@ifinfo
The geometry of the scattering problem is shown graphically in the printed manual.
@end ifinfo
@ifnotinfo
The geometry of the scattering problem is shown in @ref{fig:sph_sc, the figure below}.

@float Figure,fig:sph_sc
@center @image{sph_sc,4in}
@caption{Scattering from a sphere illuminated by a plane wave incident from the -z direction.}
@end float
@end ifnotinfo

We start by creating a configuration file; say @file{sph_sc.cfg}. This file will be populated by configuration options listed in the following. Some basic parameters of our simulation are determined by the following lines (see @ref{Grid Properties} for details):

@example
dx = 20e-9;
courant = 0.98;
grid_dimension_x = 1e-6;
grid_dimension_y = 1e-6;
grid_dimension_z = 1e-6;
pml_thickness_in_cells = 5;
num_of_time_steps = 1500;
@end example

The first variable, @code{dx}, is the uniform spatial step size in the FDTD discretization. The second variable, @code{courant}, is the ratio of the time step to the maximum time step allowable by the Courant condition. The next three variables determine the physical size of the simulation grid in meters. The thickness of the absorbing layer (PML) is determined by the @code{pml_thickness_in_cells} variable. The last line specifies the number of time steps in the simulation.

The sphere from which the electromagnetic plane wave will be scattered is created in two steps. First, we define a spherical "shape object" using the @code{Spheres} variable (see @ref{Spheres}):
@example
Shapes:
@{
    Spheres:
    (
        @{
            shape_tag = "mysphere";
            center_coord_x = 0;
            center_coord_y = 0;
            center_coord_z = 0;
            radius = 320e-9;
        @}
    );
@};
@end example
Next, the material filling the sphere is defined using the @code{Materials} variable (see @ref{Materials}):
@example
Materials:
(
    @{
        material_tag = "sph_mat";
        rel_permittivity = 2.25;
        electric_conductivity = 3e4; //in Siemens/m
        rel_permeability = 1.7;
        magnetic_conductivity = 4.2578e9; //in Ohm/m
    @}
);
@end example
The shape and material definitions are then combined in the @code{Objects} variable, and the sphere is placed in the grid (see @ref{Objects}):
@example
SimulationSpace:
@{
    Objects:
    (
        @{
            material_tag = "sph_mat";
            shape_tag = "mysphere";
        @}
    );
@};
@end example
With the above defitions, we have created a sphere of radius 320 nm and made of the material specified by @code{"sph_mat"}. Next, we define the waveform of the incident plane wave using the @code{Waveforms} variable:
@example
Waveforms:
@{
    ModulatedGaussianWaveforms:
    (
        @{
            waveform_tag = "mywaveform";
            modulation_type = "sine";
            tau = 2.12662e-15;
            f_0 = 5.88878e14;
        @}
    );
@};
@end example
We then create the plane wave incident from the -z direction with the above waveform as its electric field using the @code{PlaneWaves} variable (see @ref{Plane Waves}):
@example
TFSF:
@{
    PlaneWaves:
    (
        @{
            theta = 180;
            phi = 0;
            psi = 90;
            waveform_tag = "mywaveform";
        @}
    );
@};
@end example
Finally, we create a near-field-to-far-field transformer to calculate the scattered field in the far zone using the @code{PhasorDomainNFFFT} variable (see @ref{Near-Field-to-Far-Field Transformer}):
@example
PhasorDomainNFFFT:
(
    @{
        num_of_lambdas = 1;
        lambda_min = 509.09e-9;
        lambda_max = 509.1e-9;
        direction_spec = "theta-phi";
        num_of_dirs_1 = 360;
        dir1_min = 0;
        dir1_max = 360;
        num_of_dirs_2 = 1;
        dir2_min = 0;
        dir2_max = 0;
    @}
);
@end example
With the above definitions, the far field is calculated at the free-space wavelength 509.1 nm, and 360 equally-spaced angles on the xz plane. The output of the near-field-to-far-field transformer is in HDF5 format, which can be read and manipulated using freely-available tools. For more information, see @ref{Near-Field-to-Far-Field Transformer}.
@ifinfo
The scattered electric field is shown in a polar plot in the printed manual.
@end ifinfo
@ifnotinfo
The absolute value of the phasor component of the far-zone electric field (normalized by 1/r) at 509.1 nm is shown in a polar plot in @ref{fig:sph_pattern,the figure below}.
@float Figure,fig:sph_pattern
@center @image{sph_pattern,2in}
@caption{The absolute scattered electric field phasor amplitude on the xz plane at 509.1 nm.}
@end float
The scattered electric field can also be obtained theoretically using Mie theory (see @ref{Matzler02}), which is shown alongside the Angora solution in the above figure.
@end ifnotinfo

@node Downloading
@chapter Downloading

@cindex Downloading Angora

Angora is currently only available for the @strong{GNU/Linux operating system}. If you would like to port Angora to another operating system, please contact us at @email{capoglu@@angorafdtd.org}. Contributions are always welcome.

The latest version of Angora can be found at @uref{http://angorafdtd.org} in source code format, as well as binary format for x86_64 GNU/Linux systems.

@node Compilation and Installation
@chapter Compilation and Installation

@cindex Compiling Angora
@cindex Installing Angora

If you will be using Angora on a 64-bit x86 architecture with the GNU/Linux operating system, you can simply download the binary version (both non-parallel and OpenMPI-based parallel versions available) from the Angora website and start running simulations right away.

If there is no precompiled Angora binary available for your system, you will have to compile it from source. You will require the the following libraries on your system to compile Angora: @uref{http://www.oonumerics.org/blitz/,blitz++}, @uref{http://www.hyperrealm.com/libconfig/,libconfig}, @uref{http://www.hdfgroup.org/HDF5/,hdf5}, and @uref{http://www.boost.org/,boost}. If possible, use the package manager for your specific GNU/Linux distribution (such as Synaptic in Ubuntu) to install the libraries directly from the package repository. Most major distributions provide these libraries in their package repositories. If you do not have root access to your system, you can install these libraries in your home directory. The installation instructions for the libraries usually provide detailed information on how to do this. For local installation, the usual trick is to set the installation path by specifying the @code{prefix} variable in the @command{Makefile}s. This is done either by using the @option{--prefix=@var{local-path}} option when calling the package's @command{configure} script, or customizing @command{make} at the final stage with the @option{prefix=@var{local-path}} command option.

Once the dependency libraries are installed, the Angora package is ready for compilation. Extract the package @file{angora-@var{package-version}.tar.gz} using @command{tar}, and enter the created directory:

@example
johndoe@@mysystem:~@w{$} tar xvf angora-@var{package-version}.tar.gz
johndoe@@mysystem:~@w{$} cd angora-@var{package-version}
@end example

Run the @command{configure} script in this directory to create the @code{Makefile}s required to build the package:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./configure
@end example

If any of the dependency libraries was installed in a local directory, then add the option @option{--with-@var{library-name}=@var{local-path-to-library}} to the above command line. For example, if the @code{blitz++} library was installed in @file{/home/johndoe/blitz-0.9}, then the option to add is @option{--with-blitz=/home/johndoe/blitz-0.9}. Type @samp{./configure --help} in the directory @file{angora-@var{package-version}} for information on specifying the paths to the other dependency libraries.

After the @command{configure} script finishes execution, compile and install Angora using the @command{make} command:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make
@end example

If your system has multiple cores, you can speed up the compilation by executing @command{make} in parallel. For example, you can use all 4 cores of your system by typing, instead of the above line,

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make -j 4
@end example

This might take a couple of minutes, depending on your system. After @command{make} finishes, the executable @command{angora} will be located in the directory @file{angora-@var{package-version}}. If you wish to @emph{install} the package globally so that it can be run from anywhere, type

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} sudo make install
@end example

Obviously, this requires super-user privileges on your system. By default, the package is installed in @file{/usr/local}; so the binary will reside in @file{/usr/local/bin}. If you don't have super-user privileges, you can install Angora in a local directory @file{full-path-to-inst-dir} by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make prefix=@var{full-path-to-inst-dir} install
@end example

The location @file{full-path-to-inst-dir} should be an absolute path. After this, the binary @command{angora} will be located in the directory @file{full-path-to-inst-dir/bin/}.

@menu
* Enabling MPI Support::    Compiling Angora with MPI support.
* Building the Documentation::    Building the Angora documentation.
@end menu

@node Enabling MPI Support
@section Enabling MPI Support

@cindex MPI support, enabling
@cindex Parallelization, enabling

Parallel execution on multiple processors or cores is supported by Angora, provided that the @acronym{MPI,Message Passing Interface} libraries are installed on your system (e.g., @uref{http://www.open-mpi.org/,OpenMPI} or @uref{http://www.mcs.anl.gov/research/projects/mpich2/,MPICH2} or other). A precompiled binary version of Angora based on the OpenMPI implementation is available on the Angora website.

If you are compiling Angora from source, you'll have to enable the MPI feature at compile time. This feature is @emph{disabled} by default. You can enable MPI functionality in Angora by adding the option @option{--with-mpi} to the @command{configure} command line:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./configure --with-mpi
@end example

For more information on launching Angora simulations on multiple processors or cores using MPI, @pxref{Parallel Execution}.

@node Building the Documentation
@section Building the Documentation

@cindex Documentation, building

The GNU @code{info} documentation for Angora is automatically built and installed by @command{make}. If you have the @uref{http://www.mathematik.uni-kl.de/~obachman/Texi2html/,texi2html} and @uref{http://www.latex2html.org/,latex2html} utilities installed, you can create an HTML version of the Angora documentation by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make html
@end example

If you have the @command{texi2dvi} command available (provided as part of the @uref{http://www.gnu.org/software/texinfo/,GNU Texinfo} package), you can also build a PDF version of the Angora documentation by typing

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} make pdf
@end example

Once built, both the HTML and PDF versions of the documentation will be located in the subdirectory @file{doc/}.

@node Execution
@chapter Execution

@cindex Running Angora
@cindex Executing Angora

Angora operates by reading a text file, called the @dfn{configuration file}, that specifies the details of the simulation. Every aspect of the simulation is configured by a related @dfn{configuration variable} (or @dfn{variable} in short) in the configuration file; which comprises either a single line or a number of lines. In general, an Angora simulation is run by putting the name of the configuration file pertaining to the simulation as a command line option when calling the @command{angora} executable:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} ./angora @var{path-to-config-file}
@end example

If the Angora executable is run without any command-line options, it looks for the configuration file named @file{angora.cfg} in the same directory from which the executable is run. @xref{Configuration Variables}, for details on configuration files.

@menu
* Parallel Execution::    Parallel execution using MPI libraries.
* Check Mode::    Checking for errors in the configuration file.
@end menu

@node Parallel Execution
@section Parallel Execution

@cindex MPI support
@cindex Parallelization
@cindex Simulations, parallelizing

If Angora is compiled with MPI support, then the standard MPI launcher (@command{mpirun}) can be used to execute the Angora binary @command{angora} in parallel:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$}@/ mpirun -n @var{num-of-processors}@/ ./angora @var{path-to-config-file}
@end example

For example, to run the simulation configured by @file{mysimulation.cfg} using Angora version @code{0.9} on 8 processors, one should type

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$} mpirun -n 8 ./angora mysimulation.cfg
@end example

MPI support should be enabled in compile time in order to run simulations in parallel. For details, @pxref{Enabling MPI Support}. If you are using the OpenMPI-based precompiled binary version of Angora, then the OpenMPI shared libraries must be in your path before the binary @file{angora} can be executed. This can either be done by installing OpenMPI globally (using a package manager etc.), or adding the path to the OpenMPI shared libraries to your @env{LD_LIBRARY_PATH} environment variable.

@node Check Mode
@section Check Mode

@cindex Check mode
@cindex Configuration file, checking for errors

Angora can check a configuration file for syntactic and semantic errors, without actually running the simulation. To do this, simply run Angora with the @option{--check} or @option{-c}option:

@example
johndoe@@mysystem:~/angora-@var{package-version}@w{$}@/ ./angora --check @var{path-to-config-file}
@end example

This reports any errors in the configuration-file syntax or invalid configuration options (see @ref{Template Configuration File}). The actual size of the simulation does not have any effect on this operation; therefore it can be run on a single processor with little memory.

@node Configuration Format
@chapter Configuration Format

@cindex Configuration format
@cindex libconfig

Angora uses the @uref{http://www.hyperrealm.com/libconfig/,libconfig} library to read configuration variables regarding the simulation from a text file. The text file, called the @dfn{configuration file}, has to conform to the libconfig grammar; which is explained in greater detail at @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html}. Here, we will provide the minimum information necessary to write configuration files for Angora simulations.

@menu
* Variable Assignment::    Assignment format for simulation variables.
* Variable Types::    Types of values that can be assigned to simulation variables.
@end menu

@node Variable Assignment
@section Variable Assignment

@cindex Configuration variables, assigning

A variable in a configuration file is set using the following assignment:

@example
@var{name}=@var{value};
@end example

or:

@example
@var{name}:@var{value};
@end example

The trailing semicolon is required. Whitespace is not significant. Here, @var{name} is the name of the variable, and @var{value} is its value; which may be a scalar value, an array, a group, or a list. @xref{Variable Types}, for information on these value types.

The order in which variables are specified in the configuration file is insignificant, except within the @code{SimulationSpace} variable (@pxref{Simulation Space}). The sub-variables of the @code{SimulationSpace} variable are processed in the order of appearance in the configuration file. This is necessary because the user needs to be able to control the order in which objects are placed in the grid, and predict the regions within an object that will be overwritten by another object.

@node Variable Types
@section Variable Types

@cindex Configuration variables, value types

Angora simulation variables can be assigned C++-type @dfn{scalar} values, as well as more complex values of type @dfn{group}, @dfn{array}, and @dfn{list}. The latter types are defined by the libconfig library. Some of the text in this section is copied verbatim from the @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html,libconfig manual}. The @command{libconfig} library, along with its documentation, is distributed under the @uref{http://www.hyperrealm.com/libconfig/libconfig_manual.html#License,GNU Lesser Public License}.

@menu
* Integer Values::
* Floating-Point Values::
* Boolean Values::
* String Values::
* Groups::
* Arrays::
* Lists::
* Comments::
* Include Directives::
@end menu

@node Integer Values
@subsection Integer Values

@cindex Integer values

Integers can be represented in one of two ways: as a series of one or
more decimal digits (@samp{0} - @samp{9}), with an optional leading
sign character (@samp{+} or @samp{-}); or as a hexadecimal value
consisting of the characters @samp{0x} followed by a series of one or
more hexadecimal digits (@samp{0} - @samp{9}, @samp{A} - @samp{F},
@samp{a} - @samp{f}).

Examples:

@example
n_sx = 3;
offset = -4;
address = 0xFFFF;
@end example

@node Floating-Point Values
@subsection Floating-Point Values

@cindex Floating-point values

Floating point values consist of a series of one or more digits, one
decimal point, an optional leading sign character (@samp{+} or
@samp{-}), and an optional exponent. An exponent consists of the
letter @samp{E} or @samp{e}, an optional sign character, and a series
of one or more digits.

Except in special circumstances, floating-point values in Angora are read and processed in @samp{double} precision, which corresponds to roughly 15 decimal digits.

Examples:

@example
f = 1.0;
origin = -3e-6;
prefactor = 5E10;
@end example

@node Boolean Values
@subsection Boolean Values

@cindex Boolean values

Boolean values may have one of the following values: @samp{true},
@samp{false}, or any mixed-case variation thereof.

Examples:

@example
include_first_value = true;
include_last_value = FaLsE;
@end example

@node String Values
@subsection String Values

@cindex String values

String values consist of arbitrary text delimited by double
quotes. Literal double quotes can be escaped by preceding them with a
backslash: @samp{\"}. The escape sequences @samp{\\}, @samp{\f},
@samp{\n}, @samp{\r}, and @samp{\t} are also recognized, and have the
usual meaning.

In addition, the @samp{\x} escape sequence is supported; this sequence
must be followed by @i{exactly two} hexadecimal digits, which represent an
8-bit ASCII value. For example, @samp{\xFF} represents the character
with ASCII code 0xFF.

No other escape sequences are currently supported.

Adjacent strings are automatically concatenated, as in C/C++ source
code. This is useful for formatting very long strings as sequences of
shorter strings. For example, the following constructs are equivalent:

@itemize @bullet
@item
@code{"The quick brown fox jumped over the lazy dog."}

@item
@code{"The quick brown fox"} @*
@code{" jumped over the lazy dog."}

@item
@code{"The quick" /* comment */ " brown fox " // another comment} @*
@code{"jumped over the lazy dog."}

@end itemize

@node Groups
@subsection Groups

@cindex Groups

A group has the form:

@example
@{
   @var{name}=@var{value};
   @var{other_name}=@var{other_value};
   @dots{}
@}
@end example

Notice the curly brackets @samp{@{@}} around the variable assignments. Groups can contain any number of variable assignments (see @ref{Variable Assignment}), but each variable must have a unique name within the group.

Example:

@example
@{
    shape_tag = "mysphere";
    center_coord_x = 5e-6;
    center_coord_y = 5e-6;
    center_coord_z = 5e-6;
    radius = 4e-6;
@}
@end example

@node Arrays
@subsection Arrays

@cindex Arrays

An array has the form:

@example
[ @var{value}, @var{value}, @dots{} ]
@end example

Notice the square brackets @samp{[]} delimiting the comma-separated values. An array may have zero or more elements, but the elements must all be @strong{scalar} values of the @strong{same type}.

Examples:

@example
disabled_runs = [0,1,3];
output_variables = ["Ex","Ey"];
@end example

@node Lists
@subsection Lists

@cindex Lists

A list has the form:

@example
( @var{value}, @var{value}, @dots{} )
@end example

Notice the parantheses @samp{()} delimiting the comma-separated values. A list may have zero or more elements, each of which can be a scalar value, an array, a group, or another list. The values in a list can be of @emph{different types}; however, in Angora, the list type is exclusively used to contain a collection of @emph{group} values. In Angora, the list type  semantically represents a collection of objects, each with a collection of properties set within their respective group value. Here is an example:

@example
Materials:
(
    @{
        material_tag = "mat1";
        rel_permittivity = 2.0;
    @},
    @{
        material_tag = "mat2";
        rel_permittivity = 2.5;
    @}
);
@end example

Here, the list structure named @code{Materials} contains two groups (each delimited by curly brackets @samp{@{@}}) separated by a comma. This defines two materials with different sets of properties.
@c This is currently the only use of the list structure in Angora.

@node Comments
@subsection Comments

@cindex Comments, inserting

Three types of comments are allowed within a configuration:

@itemize @bullet

@item Script-style comments. All text beginning with a @samp{#} character
to the end of the line is ignored.

@item C-style comments. All text, including line breaks, between a starting
@samp{/*} sequence and an ending @samp{*/} sequence is ignored.

@item C++-style comments. All text beginning with a @samp{//} sequence to the
end of the line is ignored.

@end itemize

As expected, comment delimiters appearing within quoted strings are
treated as literal text.

@example
# Here's a comment
MyGroup:
(/* This is
    also a comment */
    @{
        this_property = "myvalue";
        // Another comment
    @}
);
@end example

@node Include Directives
@subsection Include Directives

@cindex Including other configuration files

A configuration file may ``include'' the contents of another file
using an @i{include directive}. This directive has the effect of
inlining the contents of the named file at the point of inclusion.

An include directive must appear on its own line in the input. It has
the form:

@example
@@include "@var{filename}"
@end example

Any backslashes or double quotes in the file name must be escaped as
@samp{\\} and @samp{\"}, respectively.

For example, consider the following two configuration files:

@cartouche
@smallexample
# file: limits.cfg
back_coord_x = -5e-6;
front_coord_x = 6e-6;
left_coord_y = -5e-6;
right_coord_y = 6e-6;
lower_coord_z = -3e-6;
upper_coord_z = 4e-6;
@end smallexample
@end cartouche

@cartouche
@smallexample
# file: mysim.cfg
RectangularBoxes:
(
    @{
        shape_tag = "mybox";
        @@include "limits.cfg"
    @}
);
@end smallexample
@end cartouche

Include files may be nested to a maximum of 10 levels; exceeding this
limit results in a runtime error.

@node Configuration Variables
@chapter Configuration Variables

@cindex Configuring Angora simulations
@cindex Configuration variables
@cindex Simulations, configuring

The variable assignments (or @dfn{settings} in libconfig terminology) in a configuration file reside either at the uppermost level (called the @dfn{Global} level) or within a group structure (@pxref{Groups}). In the following, configuration variables will be characterized as either being a @dfn{Global variable}, or a @dfn{Sub-variable of @var{ParentVariable}}; where @var{ParentVariable} is the next parent variable upward in the hierarchy that has a name. The variable @var{ParentVariable} can either be a @emph{group} or a @emph{list} (see @ref{Groups} and @ref{Lists}). Quite often, the immediate parent of a variable assignment is an unnamed group; therefore the @var{ParentVariable} of that assignment is the list that contains this unnamed group. For example, the @var{ParentVariable} of the variable @code{material_tag} in the example in @ref{Lists} is @code{Materials}, since its immediate parent is an unnamed group, but the list structure containing the unnamed group has a name (which is @code{Materials}). On the other hand, the variable @code{Materials} is a @dfn{Global variable}; since it is assigned at the uppermost level in a configuration file, outside any enclosing structure.

The configuration variable names are case sensitive; meaning that @code{Materials} and @code{materials} are not the same.

Angora throws an error message for any missing variable or misspelled variable name. This is crucial for ensuring that no optional configuration variable is omitted because of a typo. The valid variable names are read into the Angora source code in compile time from a template file @file{config_all.cfg}. This file, although not required at the time of execution, is distributed with Angora for reference (see @ref{Template Configuration File}).

@menu
* Template Configuration File::    The template file @file{config_all.cfg} with all possible configuration variables.
* Grid Properties::    Basic properties of the FDTD grid.
* Shapes::    Defining abstract geometrical shapes.
* Materials::    Defining material types.
* Simulation Space::    Specifying the material composition of the simulation space.
* Waveforms::    Defining time waveforms.
* Point Sources::    Defining point (Hertzian) sources.
* Near-Field-to-Far-Field Transformer::    Calculation of the radiated (far-zone) field.
* Optical Imaging::    Calculation of optical images.
* Incident Beams::    Injection of incident beams into the grid.
* Recording::    Movie/line/field-value recording.
* Paths::    Specifying the input and output directories.
* Logging::    Enabling and configuring log output.
* Multiple Simulation Runs::    Configuring the number of consecutive simulations.
* Miscellaneous::    Miscellaneous features.
@end menu

@node Template Configuration File
@section Template Configuration File

@cindex Configuration file, template
@cindex @file{config_all.cfg}

A file named @file{config_all.cfg} is included in the Angora distribution, which includes all the valid configuration variables. All variables in a given configuration file are checked against @file{config_all.cfg} and labeled invalid if a corresponding variable does not exist in @file{config_all.cfg}. It should be stressed, however, that @file{config_all.cfg} is @strong{not} necessary for the execution of Angora, but @emph{is} necessary for its compilation. This is because @file{config_all.cfg} is read into the source code of Angora in the compilation stage. The file @file{config_all.cfg} is only distributed as a reference for the user's convenience.

The file @file{config_all.cfg} is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}.

@node Grid Properties
@section Grid Properties

Angora currently only supports a rectangular, Cartesian FDTD grid with equal grid spacing in the x, y, and z directions. Mesh refinement is not yet supported; therefore the grid spacing is uniform across the grid.

@menu
* Courant Factor::    The ratio between the temporal and spatial step sizes.
* Spatial Step Size::    The spatial step size in the FDTD grid.
* Grid Dimensions::    The number of FDTD cells in the x, y, and z directions.
* Perfectly-Matched Layer (PML)::    Absorbing layers for grid termination.
* Number of Time Steps::    Number of time steps in the simulation.
* Coordinate Origin::    Origin of the coordinate system.
* Dynamic Range::    The maximum field value and the useful dB dynamic range in the simulation.
@end menu

@node Courant Factor
@subsection Courant Factor

@cindex Courant factor
@cindex Stability
@cindex Step size, temporal

@deftypevr {Global variable} floating-point courant
Angora adopts a slightly modified form for the Courant factor, defined as
@tex
$$
\sqrt{3} {c\Delta t \over \Delta x}
$$
@end tex

@ifnottex
sqrt(3)*c*D_t/D_x
@end ifnottex

where c=299792458 m/s is the speed of light in vacuum, and
@tex
$\Delta t $
@end tex
@ifnottex
D_t
@end ifnottex
and
@tex
$\Delta x $
@end tex
@ifnottex
D_x
@end ifnottex
are the @emph{temporal} and @emph{spatial} step sizes (see @ref{Spatial Step Size}). The Courant factor should be less than @code{1.0} for stability. A common value for @code{courant} is @code{0.98}.
@c The Courant factor is commonly defined without the
@c @tex
@c $1/\sqrt{3} $
@c @end tex
@c @ifnottex
@c 1/sqrt(3)
@c @end ifnottex
@c factor.
@end deftypevr

@node Spatial Step Size
@subsection Spatial Step Size

@cindex Step size, spatial
@cindex Grid spacing

@deftypevr {Global variable} floating-point dx (units: m)
The spatial step size in the FDTD grid is specified by the @code{dx} variable. Currently only cubic FDTD cells are supported; therefore the spatial step sizes in the x, y, and z direction are all determined by @code{dx}.
@end deftypevr

@node Grid Dimensions
@subsection Grid Dimensions

@cindex Dimensions, grid
@cindex Grid size

@deftypevr {Global variable} floating-point grid_dimension_x (units: m)
@end deftypevr
@deftypevr {Global variable} floating-point grid_dimension_y (units: m)
@end deftypevr
@deftypevr {Global variable} floating-point grid_dimension_z (units: m)
@end deftypevr
@deftypevr {Global variable} integer grid_dimension_x_in_cells
@end deftypevr
@deftypevr {Global variable} integer grid_dimension_y_in_cells
@end deftypevr
@deftypevr {Global variable} integer grid_dimension_z_in_cells
These variables determine the size of the Cartesian FDTD grid. The dimensions of the grid can be specified either in meters, or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the dimensions are given in meters, the number of FDTD cells in the Cartesian FDTD grid in the x, y, and z directions are rounded to the closest integer. If no perfectly-matched layers are specified (see @ref{Perfectly-Matched Layer (PML)}), the total number of FDTD cells in the three-dimensional FDTD grid is equal to (grid_dimension_x_in_cells) x (grid_dimension_y_in_cells) x (grid_dimension_z_in_cells).
@end deftypevr

@node Perfectly-Matched Layer (PML)
@subsection Perfectly-Matched Layer (PML)

@cindex Absorbing layers
@cindex Perfectly-matched layers
@cindex PML
@cindex CPML
@cindex Grid termination

@deftypevr {Global variable} floating-point pml_thickness (units: m)
@end deftypevr
@deftypevr {Global variable} integer pml_thickness_in_cells
This variable sets the thickness of the perfectly-matched layers (PMLs) around the grid in all directions. Further customization of the PML thickness is not yet supported. The thickness can be specified either in meters, or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.

Typical PML thicknesses are @code{5} to @code{10} grid cells. If you do not want to place a PML layer around the grid, just assign @code{pml_thickness=0}. Without a PML layer, the boundary of the FDTD grid acts as a perfect electric conductor (PEC). Other boundary conditions (perfect magnetic conductor, periodic, etc.) will also be supported in the future.

With a PML definition, the total number of FDTD cells in the three-dimensional FDTD grid becomes

(grid_dimension_x_in_cells+2*pml_thickness_in_cells)

x (grid_dimension_y_in_cells+2*pml_thickness_in_cells)

x (grid_dimension_z_in_cells+2*pml_thickness_in_cells)

The computational burden per FDTD cell associated with the PML layer is roughly three times that of the main grid.

Angora implements the convolution PML (CPML) formulation of the complex-frequency shifted (CFS) PML (see @ref{Roden00}; @ref{Kuzuoglu96}.)
@end deftypevr

@deftypevr {Global variable} floating-point cpml_feature_size (units:m, default: @code{max(grid_dimension_x,grid_dimension_y,grid_dimension_z)})
@end deftypevr
@deftypevr {Global variable} floating-point cpml_feature_size_in_cells (default: @code{max(grid_dimension_x_in_cells,grid_dimension_y_in_cells,grid_dimension_z_in_cells)})
This variable specifies the maximum size of the scattering or radiating structure in the FDTD grid. This size can be specified either in meters, or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.

This information is used to determine the frequency-shifting parameter
@tex
$\alpha$
@end tex
@ifnottex
@emph{alpha}
@end ifnottex
in the CFS-PML formulation. Following Berenger's derivation (see @ref{Berenger02}), this parameter is defined as
@tex
$$
\alpha = c\epsilon/w
$$
@end tex

@ifnottex
alpha = c*eps/w
@end ifnottex

where c is the velocity of propagation in the medium,
@tex
$\epsilon$
@end tex
@ifnottex
@emph{eps}
@end ifnottex
is the absolute permittivity (in F/m) in the medium, and
@tex
$w$
@end tex
@ifnottex
@emph{w}
@end ifnottex
is the maximum size of the structure.

The above relationship follows essentially from the low-frequency behavior of the CFS-PML. At low frequencies where the evanescent field around the structure dominates, the CFS-PML reduces to a real stretch of coordinates without any absorption. This helps the termination of evanescent fields, which are poorly handled by ordinary PMLs.
@end deftypevr

@node Number of Time Steps
@subsection Number of Time Steps

@cindex Time steps, number of

@deftypevr {Global variable} integer num_of_time_steps
This variable determines the number of time steps in the FDTD simulation.
@end deftypevr

@node Coordinate Origin
@subsection Coordinate Origin

@cindex Origin, global
@cindex Origin, grid

@deftypevr {Global variable} floating-point origin_x (units:m, default: (grid_dimension_x+2*pml_thickness)/2+1)
@end deftypevr
@deftypevr {Global variable} floating-point origin_y (units:m, default: (grid_dimension_y+2*pml_thickness)/2+1)
@end deftypevr
@deftypevr {Global variable} floating-point origin_z (units:m, default: (grid_dimension_z+2*pml_thickness)/2+1)
@end deftypevr
@deftypevr {Global variable} integer origin_x_in_cells (default: (grid_dimension_x_in_cells+2*pml_thickness_in_cells)/2+1)
@end deftypevr
@deftypevr {Global variable} integer origin_y_in_cells (default: (grid_dimension_y_in_cells+2*pml_thickness_in_cells)/2+1)
@end deftypevr
@deftypevr {Global variable} integer origin_z_in_cells (default: (grid_dimension_z_in_cells+2*pml_thickness_in_cells)/2+1)
These variables set the origin of the coordinate system in the simulation. All other coordinates in a configuration file are taken as relative to this origin. The coordinates can be specified either in meters, or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. These three numbers represent the Cartesian coordinates of the origin from the back-left-lower corner of the grid.
@ifinfo
See printed manual for a graphical illustration.
@end ifinfo
@ifnotinfo
In @ref{fig:grid_origin,this figure}, the location of the coordinate origin in the FDTD grid is shown for (@code{origin_x_in_cells},@code{origin_y_in_cells},@code{origin_z_in_cells})=(2,3,2). The FDTD grid is composed of (3x5x3) grids, and only the back (y=z=0), left (x=z=0), and lower (x=y=0) surfaces are shown in the figure.

@float Figure,fig:grid_origin
@center @image{grid_origin,4in}
@caption{The location of the coordinate origin in the FDTD grid for (@code{origin_x_in_cells},@code{origin_y_in_cells},@code{origin_z_in_cells})=(2,3,2).}
@end float
@end ifnotinfo

If the coordinates are given in meters, they are rounded to the closest integer multiple of the spatial step size (@pxref{Spatial Step Size}).
@end deftypevr

@node Dynamic Range
@subsection Dynamic Range

@cindex Dynamic range
@cindex Maximum field value

The following two variables are only relevant in movie recording (see @ref{Movie Recording}), wherein the floating-point field values on the movie frames are sometimes discretized to fit into 1 byte.
@deftypevr {Global variable} floating-point max_field_value (default: @code{1.0})
This value specifies the maximum field value used in the discretization for 1-byte movie recording (@pxref{Movie Recording}).
@end deftypevr

@deftypevr {Global variable} floating-point dB_accuracy (default: automatic)
This value specifies the dynamic range (in dB) to be used in the discretization for 1-byte movie recording (@pxref{Movie Recording}). For example,

@example
dB_accuracy = -60;
@end example

tells Angora to discretize the field values in a dynamic range between the maximum field value (specified by @code{max_field_value} above) and 60dB below that value. If @code{dB_accuracy} is not specified, Angora tries to set this value automatically, based on its best guess on the useful accuracy range in the simulation. This value can also be read from the output of the movie recorder (@pxref{Movie Recording}).
@end deftypevr

@node Shapes
@section Shapes

@cindex Shapes, defining

@deftypevr {Global variable} group Shapes
In Angora, a geometrical shape and the material filling that shape are two distinct and independent elements of the definition of an object. The first of these elements is defined in the @code{Shapes} variable, which is a group (@pxref{Groups}).

@example
Shapes:
@{
    RectangularBoxes:
    (
        @dots{}
        @dots{}
    );
    Spheres:
    (
        @dots{}
        @dots{}
    );

    @dots{}
    @dots{}

@};
@end example

In this example, two sub-variables @code{RectangularBoxes} and @code{Spheres} of the @code{Shapes} group are shown. These are both list variables (@pxref{Lists}).
@end deftypevr

Currently, rectangular boxes and spheres are the only basic shape classes defined in Angora. Unions, intersections, and geometrical transformations of shapes, as well as more basic shape classes will be added to Angora in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@menu
* Rectangular Boxes::
* Spheres::
@end menu

@node Rectangular Boxes
@subsection Rectangular Boxes

@cindex Rectangular boxes, defining

@deftypevr {Sub-variable of Shapes} group RectangularBoxes

Rectangular boxes are defined using the @code{RectangularBoxes} variable, which is a list structure under the @code{Shapes} group.

@example
Shapes:
@{
    RectangularBoxes:
    (
        @{
            shape_tag = "mybox";
            back_coord_x = -5e-6;
            front_coord_x = 6e-6;
            left_coord_y = -5e-6;
            right_coord_y = 6e-6;
            lower_coord_z = -3e-6;
            upper_coord_z = 4e-6;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

In this example, two rectangular box shapes are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of RectangularBoxes} string shape_tag
This string variable assigns a @emph{name} to the particular shape, so it can be referred to later in the configuration file.
@end deftypevr

@deftypevr {Sub-variable of RectangularBoxes} floating-point back_coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point front_coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point left_coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point right_coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point lower_coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point upper_coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point back_coord_x_in_cells
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point front_coord_x_in_cells
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point left_coord_y_in_cells
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point right_coord_y_in_cells
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point lower_coord_z_in_cells
@end deftypevr
@deftypevr {Sub-variable of RectangularBoxes} floating-point upper_coord_z_in_cells
These variables determine the minimum and maximum Cartesian coordinates of the box in the x, y, and z directions relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@end deftypevr

@node Spheres
@subsection Spheres

@cindex Spheres, defining

@deftypevr {Sub-variable of Shapes} group Spheres

Spheres are defined using the @code{Spheres} variable, which is a list structure under the @code{Shapes} group.

@example
Shapes:
@{
    Spheres:
    (
        @{
            shape_tag = "mysphere";
            center_coord_x = 5e-6;
            center_coord_y = 5e-6;
            center_coord_z = 5e-6;
            radius = 4e-6;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

In this example, two spherical shapes are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of Spheres} string shape_tag
This string variable assigns a @emph{name} to the particular shape, so it can be referred to later in the configuration file.
@end deftypevr

@deftypevr {Sub-variable of Spheres} floating-point center_coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_coord_x_in_cells
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_coord_y_in_cells
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point center_coord_z_in_cells
These variables determine the Cartesian coordinate of the center of the sphere relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point radius (units: m)
@end deftypevr
@deftypevr {Sub-variable of Spheres} floating-point radius_in_cells
This variable determines the radius of the sphere. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@end deftypevr

@node Materials
@section Materials

@cindex Materials, defining

Currently, Angora only supports isotropic materials. Anisotropic materials may also be supported in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@deftypevr {Global variable} list Materials
The properties of a certain material type are specified in the @code{Materials} list (@pxref{Lists}).
@example
Materials:
(
    @{
        material_tag = "this_material";
        rel_permittivity = 2.0;
        rel_permeability = 1.0;
        electric_conductivity = 0.0;
        magnetic_conductivity = 0.0;
        drude_pole_frequency = 0.0;
        drude_pole_relaxation_time = 0.0;
        transparent = false;
    @},
    @{
        @dots{}
        @dots{}
    @}
);
@end example

In this example, two materials are defined in two respective unnamed groups; only the first being shown in complete detail.

@deftypevr {Sub-variable of Materials} string material_tag
This string variable assigns a @emph{name} to the particular material, so it can be referred to later in the configuration file.
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point rel_permittivity (default: @code{1.0})
This variable specifies the relative permittivity (or the dielectric constant) of the material. In SI units, the absolute permittivity of the material is this variable multiplied by the permittivity of free space (8.85418782E-12 F/m).
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point rel_permeability (default: @code{1.0})
This variable specifies the relative permeability (or the magnetic constant) of the material. In SI units, the absolute permeability of the material is this variable multiplied by the permeability of free space (4piE-7).
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point electric_conductivity (units: S/m) (default: @code{0})
This variable specifies the electric conductivity (in Siemens/m or Mho/m) of the material.
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point magnetic_conductivity (units: Ohm/m) (default: @code{0})
This variable specifies the magnetic conductivity (in Ohm/m) of the material.
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point drude_pole_frequency (units: radians) (default: @code{0})
This variable specifies the Drude pole frequency (in radians) of the material (see @ref{Drude Dispersion}).
@end deftypevr
@deftypevr {Sub-variable of Materials} floating-point drude_pole_relaxation_time (units: sec) (default: @code{0})
This variable specifies the Drude pole relaxation time (in seconds) of the material (see @ref{Drude Dispersion}).
@end deftypevr
@deftypevr {Sub-variable of Materials} boolean transparent (default: @code{false})
If set to @code{false}, any unspecified constitutive parameter is set to its default value. If set to @code{true}, unspecified constitutive parameters become @emph{transparent}, meaning that when an object made up of this material is placed in the grid, the unspecified constitutive parameters are kept unchanged.
@end deftypevr

@end deftypevr

@menu
* Drude Dispersion::    
@end menu

@node Drude Dispersion
@subsection Drude Dispersion

Angora supports frequency-dependent permittivities described by a Drude dispersion model with a single pole. The relative permittivity of a material with a single Drude pole is given by the expression
@tex
$$
\epsilon_r = \epsilon_{r_{\infty}}-{{\omega_p^2}\over{\omega^2-j\omega/\tau_p}}
$$
@end tex

@ifnottex
eps_r = eps_r_inf-(w_p^2/(w^2-j*w/tau_p))
@end ifnottex

where
@tex
$
\omega
$
@end tex
@ifnottex
w
@end ifnottex
is the radian frequency, 
@tex
$
\omega_p
$
@end tex
@ifnottex
w_p
@end ifnottex
is the Drude pole frequency (also known as the plasma frequency) of the material, and
@tex
$
\tau_p
$
@end tex
@ifnottex
tau_p
@end ifnottex
is the Drude pole relaxation time of the material.

Currently, Drude dispersion @emph{cannot} be used for materials extending into the PML (see @ref{Perfectly-Matched Layer (PML)}). Consequently, the plane-wave injector (see @ref{Plane Waves}) and the near-field-to-far-field transformer (see @ref{Near-Field-to-Far-Field Transformer}) @emph{cannot} handle planar layers with Drude dispersion. This feature may be added in the future.

@node Simulation Space
@section Simulation Space

@deftypevr {Global variable} group SimulationSpace
The @code{SimulationSpace} group is where all the objects inside the simulation space are defined. If no @code{SimulationSpace} group is specified in the configuration file, the FDTD simulation space consists entirely of vacuum.
@example
SimulationSpace:
@{
    Objects:
    (
        @dots{}
        @dots{}
    );
    RandomMaterials:
    @{
        @dots{}
        @dots{}
    @};

    @dots{}
    @dots{}

@};
@end example

In the above example, only two of the sub-variables of the @code{SimulationSpace} group, @code{Objects} and @code{RandomMaterials}, are shown. The sub-variable @code{Objects} is a list (see @ref{Lists}), whereas @code{RandomMaterials} is a group (see @ref{Groups}).

The definitions in the @code{SimulationSpace} group are processed @strong{in the order of placement}. Thus, the user has complete control over which object is placed in the simulation space first. As a consequence of this first-come-first-serve policy, objects can overwrite regions of the simulation space occupied by other objects.
@end deftypevr

@menu
* Objects::    Material objects defined as a combination of a @code{Shapes} object and a @code{Materials} object.
* Planar Layers::    Planar material layers.
* Random Materials::    Material regions having random material properties with a specified spatial correlation function.
* File Input::    Reading a region of the simulation grid from a file.
* Ground Planes::    Perfectly-conducting planar sheets.
@end menu

@node Objects
@subsection Objects

@cindex Objects, placing

@deftypevr {Sub-variable of SimulationSpace} list Objects
The @code{Objects} list defines material objects to be placed in the simulation grid. An @emph{object} in this context is defined as a combination of two abstract ingredients: A previously-defined shape (see @ref{Shapes}), and a previously-defined material to fill that shape (see @ref{Materials}). The shape and material are referred to using their shape and material tags, which are string variables assigned to them in their definitions.

Here is an example:

@example
SimulationSpace:
@{
    Objects:
    (
        @{
            material_tag = "this_material";
            shape_tag = "mysphere";
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of Objects} string material_tag
This string variable specifies the material that makes up the object. It should match a previously-defined tag in a @code{Materials} definition (@pxref{Materials}).
@end deftypevr

@deftypevr {Sub-variable of Objects} string shape_tag
This string variable specifies the geometrical shape of the object. It should match a previously-defined tag in a @code{Shapes} definition (@pxref{Shapes}).
@end deftypevr

@end deftypevr

@node Planar Layers
@subsection Planar Layers

@cindex Planar layers, placing
@cindex Stratification, defining

@deftypevr {Sub-variable of SimulationSpace} list MaterialSlabs

The purpose of the @code{MaterialSlab} list is to introduce @strong{planar stratification} into the simulation grid. Currently, Angora only supports planar stratification along the z direction. The handling of planar layers will be further improved in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

Here is an example:

@example
SimulationSpace:
@{
    MaterialSlabs:
    (
        @{
            material_tag = "material1";
            min_coord = 1e-6;
            max_coord = "max";
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

In the above example, a material slab composed of @code{material1} is placed in the grid.

@deftypevr {Sub-variable of MaterialSlabs} string material_tag
This variable specifies the material that makes up the slab. It should match a previously-defined tag in a @code{Materials} definition (@pxref{Materials}).
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} floating-point/string min_coord
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} floating-point/string max_coord
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} integer/string min_coord_in_cells
@end deftypevr
@deftypevr {Sub-variable of MaterialSlabs} integer/string max_coord_in_cells
These two floating-point variables specify the lower and upper coordinates of the material slab with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. These variables can also be assigned the string values @code{"min"} or @code{"max"}; which correspond to the lower and upper boundaries of the simulation grid, respectively. If the coordinates correspond to non-integer cell positions, they are rounded to the nearest multiple of the spatial step size. However, the tangential components of the electric tensor properties and the normal component of the magnetic tensor properties are suitably interpolated (@pxref{Hwang01}).
@end deftypevr

If the FDTD grid is terminated by absorbing PML boundaries (see @ref{Perfectly-Matched Layer (PML)}), then the @code{MaterialSlab} definitions effectively create @emph{infinite planar layers} that extend horizontally toward infinity. When the @code{"min"} or @code{"max"} strings are assigned as lower or upper coordinates of the slab, the @code{MaterialSlab} definition amounts to placing a @emph{half space}. When the @code{MaterialSlab} variable is used, the incident beams (see @ref{Incident Beams}) and the scattered far field (see @ref{Near-Field-to-Far-Field Transformer}) are both calculated as if the material slab horizontally extends toward infinity.
@end deftypevr

@node Random Materials
@subsection Random Materials

@cindex Random materials, placing

@deftypevr {Sub-variable of SimulationSpace} group RandomMaterials
Independent samples from a random distribution of material properties with a specified correlation function can be generated and placed into the simulation grid using the @code{RandomMaterials} group. It contains sub-variables in the form of lists (see @ref{Lists}) that correspond to specific correlation functions. Currently, only the @emph{Whittle-Matern} family of correlation functions is supported. More correlation functions can be added in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

Although the spatial correlation of the generated random material regions can vary, the joint probability density function of the material region is always a @emph{multivariate normal (Gaussian) function}.

@deftypevr {Sub-variable of RandomMaterials} list WhittleMaternCorrelated

The Whittle-Matern family of correlations (see @ref{Rogers09}) is a three-parameter isotropic stochastic model that can represent a wide range of spatial correlations. The Whittle-Matern correlation function
@tex
$B(r)$
@end tex
@ifnottex
B(r)
@end ifnottex
for two points separated in space by a distance of
@tex
$r$
@end tex
@ifnottex
r
@end ifnottex
is given by the formula
@tex
$$
B(r) = \sigma^{2}
	{{2^{5/2-m}(r/l_c)^{m-3/2}}\over{\Gamma(m-3/2)}}
	K_{m-3/2}(r/l_c)\
$$
@end tex

@ifnottex
B(r)=2^(5/2-m)(sigma^2)*(r/lc)^(m-3/2)*BesselK(m-3/2,r/lc)/Gamma(m-3/2)
@end ifnottex

where
@tex
$K_{m-3/2}(\cdot)$
@end tex
@ifnottex
BesselK(m-3/2,r/lc)
@end ifnottex
is the modified Bessel function of the second kind and order (m-3/2).
@itemize
@item
@tex
$m$:
@end tex
@ifnottex
m:
@end ifnottex
The shape parameter that determines the overall behavior of the correlation function. As m->infinity, the function approaches a Gaussian distribution. If m=2, the function reduces to a decaying exponential. For m<3/2, the distribution acquires an inverse power law dependence near the origin; approximating a fractal distribution. For more details, see @ref{Rogers09}.

@item
@tex
$l_c$:
@end tex
@ifnottex
lc:
@end ifnottex
(For m>3/2:) The correlation length. (For m<=3/2:) Loosely, the outer length scale where the fractal approximation no longer holds.

@item
@tex
$\sigma$:
@end tex
@ifnottex
sigma:
@end ifnottex
(For m>3/2:) The standard deviation of the distribution at a given point (r=0). (For m<=3/2:) In this range, the correlation function enters the fractal regime with an inverse-power-law dependence at the origin (see @ref{Rogers09}). The meaning of
@tex
$\sigma$
@end tex
@ifnottex
sigma
@end ifnottex
becomes more subtle in this regime. It can loosely be associated with the amplitude of the correlation between two points separated by
@tex
$l_c$.
@end tex
@ifnottex
lc.
@end ifnottex
@end itemize

The @code{WhittleMaternCorrelated} list creates regions with random material properties described by the Whittle-Matern correlation function above. Here is an example of its usage:

@example
SimulationSpace:
@{
    RandomMaterials:
    @{
        WhittleMaternCorrelated:
        (
            @{
                constitutive_param_type = "rel_permittivity";
                mean = 1.33;
                std_dev = 0.05;
                corr_len = 100e-9;
                m = 2.0;
                shape_tag = "rand_mat_shape";
                random_seed = 0;
            @},
            @{
                @dots{}
                @dots{}
            @}
        );
    @};

@};
@end example

@deftypevr {Sub-variable of WhittleMaternCorrelated} string constitutive_param_type
The Whittle-Matern correlation function can describe the relative permittivity, relative permeability, electric conductivity (in Siemens/m), or magnetic conductivity (Ohm/m) of the material region. This is specified by assigning @code{"rel_permittivity"}, @code{"rel_permeability"}, @code{"electric_conductivity"}, or @code{"magnetic_conductivity"} to the @code{constitutive_param_type} string variable.

The constitutive parameters other than the one specified are @emph{not changed}. As a result, different random constitutive parameter distributions can be superimposed using multiple random material definitions:

@example
SimulationSpace:
@{
    RandomMaterials:
    @{
        WhittleMaternCorrelated:
        (
            @{
                constitutive_param_type = "rel_permittivity";
                mean = 1.33;
                std_dev = 0.05;
                corr_len = 100e-9;
                m = 2.0;
                shape_tag = "rand_mat_shape";
            @},
            @{
                constitutive_param_type = "rel_permeability";
                mean = 1.1;
                std_dev = 0.05;
                corr_len = 100e-9;
                m = 2.0;
                shape_tag = "rand_mat_shape";
            @}
        );
    @};

@};
@end example

Here, a random permittivity distribution and a random permeability distribution are overlaid within the same region in the grid.

@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point mean (units: none or S/m)
A baseline constant value equal to @code{mean} is added to the constitutive parameter described by the Whittle-Matern correlation function. If @code{mean=0}, then the generated random distribution will have zero mean. However, this will not necessarily be reflected to the actual constitutive parameter values in the grid; since Angora will automatically clip the constitutive parameters (permittivity, permeability, conductivity, etc.) from below to either unity or zero to avoid instabilities. For this reason, @code{mean} should be high enough to avoid this clipping as much as possible. As a rule of thumb, @code{mean} should be 5 to 6 times the standard deviation (@code{std_dev}) above unity or zero.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point std_dev (units: none or S/m)
This variable specifies the
@tex
$\sigma$
@end tex
@ifnottex
sigma
@end ifnottex
parameter in the definition of the Whittle-Matern correlation function.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point corr_len (units: m)
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point corr_len_in_cells
This variable specifies the
@tex
$l_c$
@end tex
@ifnottex
lc
@end ifnottex
parameter in the definition of the Whittle-Matern correlation function. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} floating-point m
This variable specifies the
@tex
$m$
@end tex
@ifnottex
m
@end ifnottex
parameter in the definition of the Whittle-Matern correlation function.
@end deftypevr

@deftypevr {Sub-variable of WhittleMaternCorrelated} string shape_tag
This string variable specifies the geometrical shape of the region occupied by the random material. It should match a previously-defined tag in a @code{Shapes} definition (@pxref{Shapes}).
@end deftypevr
@deftypevr {Sub-variable of WhittleMaternCorrelated} integer/string random_seed (default: determined by system time)
If you would like to create @emph{exactly the same random distribution} each time the simulation is run, you can assign an integer value to the @code{random_seed} variable. Otherwise, you @strong{should not} define this variable. This value is used to initialize the random-number generator in Angora. If the same seed is used to initialize the random-number generator, the same sequence of random numbers will be generated each time, resulting in the same random distribution.

If multiple simulation runs are present (see @ref{Multiple Simulation Runs}), you can create different random samples for each simulation run by assigning the string value @code{"run_index"} to @code{random_seed}. This will initialize the intenal random-number generator with the run index (ranging from @code{0} to @code{number_of_runs-1}) of each run. This way, a different random distribution will be obtained in each simulation run; but a distribution for a given simulation run will be @emph{fixed} in subsequent executions of Angora.
@end deftypevr
@ifinfo
See printed manual for an example of a random distribution.
@end ifinfo

@ifnotinfo
In @ref{fig:random_sample,this figure}, a 2D slice of an example zero-mean sample distribution generated by @code{WhittleMaternCorrelated} is shown in grayscale.

@float Figure,fig:random_sample
@center @image{random_sample,4in}
@caption{A 2D slice of an example zero-mean sample distribution. This distribution can be assigned to different constitutive parameters of a material.}
@end float
@end ifnotinfo

@end deftypevr
@end deftypevr

@node File Input
@subsection File Input

@cindex Material files, reading from

@deftypevr {Sub-variable of SimulationSpace} list MaterialsFromFiles
Material information within rectangular regions of the FDTD simulation grid can be read from files using a @code{MaterialsFromFiles} list. This feature of Angora is still under development. The user interface for this feature may change in the future, or be superseded by another, more general interface. Currently, only a single constitutive parameter can be read from a file; and dispersive or anisotropic materials are not supported. These issues will be handled more comprehensively in a future version. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

The material file should be in a simple custom binary format that Angora can recognize. The order and type of each variable in the file is explained below:
@itemize
@item
@samp{x-extent}: The extent of the array in the x direction in grid cells (integer, 4 bytes)
@item
@samp{y-extent}: The extent of the array in the y direction in grid cells (integer, 4 bytes)
@item
@samp{z-extent}: The extent of the array in the z direction in grid cells (integer, 4 bytes)
@item
A floating-point array of length (@code{x-extent}) x (@code{y-extent}) x (@code{z-extent}). Each value in this array is either of type @code{double} (8 bytes) or @code{float} (4 bytes), depending on the @code{datatype} variable (see @ref{datatype,@code{datatype}}). The floating-point array should be laid out in the file in @emph{column-major} order, meaning that the x dimension is looped over first, then the y dimension, and finally the z dimension.
@ifinfo
See printed manual for a graphical illustration of the column-major order.
@end ifinfo
@ifnotinfo
This ordering is illustrated in @ref{fig:column_major,the following figure}. The elements of the 2x2x2 array are numbered from 0 to 7. These elements should be laid out in the binary file in the same order:

@cartouche
@example
@dots{}@dots{} 0  1  2  3  4  5  6  7  @dots{}@dots{}
@end example
@end cartouche

@float Figure,fig:column_major
@center @image{column_major,4in}
@caption{The illustration of the column-major ordering of a three-dimensional array. The values indicated by numbers should be laid out in the file in the same order.}
@end float
@end ifnotinfo

@end itemize

Here is an example usage of @code{MaterialsFromFiles}:

@example
SimulationSpace:
@{
    MaterialsFromFiles:
    (
        @{
            file_name = "path_to_file/materialfile";
            append_run_index_to_name = true;
            file_extension = "mat";
            constitutive_param_type = "rel_permittivity";
            anchor = "center";
            coord_x = 0;
            coord_y = 0;
            coord_z = 0;
            datatype = "double";
            max_new_materials = 1000;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example
@deftypevr {Sub-variable of MaterialsFromFiles} string file_name
This string specifies the name of the binary file from which the material information will be read. Path information can be prepended to the file name, as shown in the example above. This path is interpreted as being relative to @code{input_dir} (see @ref{Paths}), unless it is preceded by a slash @samp{/}.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string file_extension (default: "")
This is the extension of the material file to be read. In the above example, the file to be read is @file{path_to_file/materialfile.mat}.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} boolean append_run_index_to_name
This boolean flag becomes useful if there are multiple simulation runs (see @ref{Multiple Simulation Runs}), and a different file needs to be read in each run. This can be accomplished by appending the run index (which ranges from @code{0} to @code{number_of_runs-1}) to the file name specified by @code{file_name}. For example, if there are 3 simulation runs (@code{number_of_runs} is 3) the above assignment will tell Angora to read the file @file{path_to_file/materialfile0.mat} in the first run, @file{path_to_file/materialfile1.mat} in the second, and @file{path_to_file/materialfile2.mat} in the third.

This variable is required for all simulations (hence no default value) to help the user prevent easy mistakes such as reading the same file for all simulation runs unintentionally, reading @file{path_to_file/materialfile0.mat} instead of @file{path_to_file/materialfile.mat}, etc.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string constitutive_param_type
The values read from the input file can be assigned to one of the following constitutive parameters: relative permittivity, relative permeability, electric conductivity, or magnetic conductivity. This is determined by assigning @code{"rel_permittivity"}, @code{"rel_permeability"}, @code{"electric_conductivity"}, or @code{"magnetic_conductivity"} to the @code{constitutive_param_type} string variable. Electric conductivity is assumed to be in Siemens/m, and magnetic conductivity is assumed to be in Ohm/m.

The constitutive parameters other than the one specified are @emph{not changed}. As a result, different constitutive parameter distributions can be superimposed using multiple file-input definitions:

@example
SimulationSpace:
@{
    MaterialsFromFiles:
    (
        @{
            file_name = "permittivity_file";
            append_run_index_to_name = true;
            constitutive_param_type = "rel_permittivity";
            coord_x = 0;
            coord_y = 0;
            coord_z = 0;
            datatype = "double";
        @},
        @{
            file_name = "conductivity_file";
            append_run_index_to_name = true;
            constitutive_param_type = "electric_conductivity";
            coord_x = 0;
            coord_y = 0;
            coord_z = 0;
            datatype = "double";
        @}
    );
@};
@end example

Here, the contents of the files @file{permittivity_file} and @file{conductivity_file} are interpreted as the relative permittivity and electric conductivity of the same region, respectively.

@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} string anchor (default: @code{"center"})
This string defines an anchor point inside the rectangular-box-shaped region that is to be read from this file. This anchor is then assigned a coordinate in the FDTD grid, determining the position of the rectangular box in the grid. Valid values for @code{anchor} are:
@itemize
@item
@code{"center"}: center of the box
@item
@code{"BLL"}: back-left-lower corner of the box
@item
@code{"BLU"}: back-left-upper corner of the box
@item
@code{"BRL"}: back-right-lower corner of the box
@item
@code{"BRU"}: back-right-upper corner of the box
@item
@code{"FLL"}: front-left-lower corner of the box
@item
@code{"FLU"}: front-left-upper corner of the box
@item
@code{"FRL"}: front-right-lower corner of the box
@item
@code{"FRU"}: front-right-upper corner of the box
@end itemize
Here, as usual, "back"/"front" refers to the x coordinate, "left"/"right" refers to the y coordinate, and "lower"/"upper" refers to the z coordinate.
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} floating-point coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} floating-point coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} floating-point coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer coord_x_in_cells
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer coord_y_in_cells
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer coord_z_in_cells
These values determine the Cartesian x,y, and z coordinates of the anchor point (see above) assigned to the rectangular region to be read from the file. The coordinates are measured with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinates correspond to non-integer cell positions, the closest integer positions are chosen.
@end deftypevr
@anchor{datatype}@deftypevr {Sub-variable of MaterialsFromFiles} string datatype
The datatype for the values read from the file is determined by this variable. It should be either @code{"double"} (8 bytes) or @code{"float"} (4 bytes).
@end deftypevr
@deftypevr {Sub-variable of MaterialsFromFiles} integer max_new_materials (default: @code{1000})
Internally, Angora uses @emph{material indexing} to reduce memory use for material arrays. Every constitutive parameter in the grid can only take a distinct set of values, represented by a variable of type @code{unsigned short} (2 bytes) that can range from @code{0} to @code{65,535}. Instead of storing a floating-point value (which is usually 4 or 8 bytes) for a permittivity value at a point, Angora stores an @emph{index} that represents the permittivity at that point. The same applies to other constitutive parameters (relative permeability, electric conductivity, etc.)

Each time a material region is read into the FDTD grid using @code{MaterialsFromFiles}, a fixed number of new constitutive parameter values are defined between the minimum and maximum values found in the file. Because of this discretization, some loss of information is inevitable. The number of new materials is determined by the variable @code{max_new_materials}; which is by equal to 1000 default. With the default value, the upper limit for the number of materials will be reached after about 65 material regions are inserted into the grid. If you wish to insert more material regions, and the dynamic ranges of constitutive parameters in your material files are not large, you can decrease @code{max_new_materials}. Alternatively, you may consider combining multiple material regions into a single region.
@end deftypevr
@end deftypevr

@node Ground Planes
@subsection Ground Planes

@cindex Ground planes, placing
@cindex PEC planes, placing

@deftypevr {Sub-variable of SimulationSpace} list GroundPlanes
Infinitely thin perfect-electric-conductor (PEC) sheets can be placed in the grid using a @code{GroundPlanes} list. Currently, only z-oriented (parallel to the xy plane) sheets at integer (full-cell) positions are supported.

@example
SimulationSpace:
@{
    GroundPlanes:
    (
        @{
            coord = 0;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of GroundPlanes} floating-point coord (units: m)
@end deftypevr
@deftypevr {Sub-variable of GroundPlanes} integer coord_in_cells
This variable specifies the z-coordinate of the ground plane with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr

The @code{GroundPlanes} variable also updates the layering (stratification) information in the grid, much like @code{MaterialSlabs} (@pxref{Planar Layers}).

@end deftypevr


@node Waveforms
@section Waveforms

@cindex Waveforms, defining

@deftypevr {Global variable} group Waveforms
In Angora, a @emph{time waveform} is defined as a self-contained structure that can be used by other structures; such as a Hertzian dipole source or a plane-wave injector. The library of available time waveforms will be expanded in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

An example usage of @code{Waveforms}:
@example
Waveforms:
@{
    GaussianWaveforms:
    (
        @{
            @dots{}
        @}
    );

    DifferentiatedGaussianWaveforms:
    (
        @{
            @dots{}
        @}
    );
    @dots{}
    @dots{}
@};
@end example
@end deftypevr

@menu
* Gaussian Waveforms::
* Differentiated-Gaussian Waveforms::
* Modulated-Gaussian Waveforms::
@end menu

@node Gaussian Waveforms
@subsection Gaussian Waveforms

@cindex Gaussian waveforms, defining

@deftypevr {Sub-variable of Waveforms} list GaussianWaveforms
This variable is used to define Gaussian time waveforms given by the formula
@anchor{eq:gaussian}
@tex
$$
f(t)=A\ \exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*exp(-(t-n_tau*tau)^2/2tau^2)
@end ifnottex

The peak, 10%-amplitude (-20 dB power), and 1%-amplitude (-40 dB power) frequencies in the spectrum of the Gaussian are
@tex
$\omega=0,\ \omega=2.15/\tau,\ \omega=3.035/\tau$
@end tex
@ifnottex
w=0, w=2.15/tau, w=3.035/tau
@end ifnottex
, respectively.

Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    GaussianWaveforms:
    (
        @{
            waveform_tag = "my_waveform";
            amplitude = 1.0;
            tau = 2.1291e-15;
            delay = 3;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of GaussianWaveforms} string waveform_tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in the above equation defining the Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in the above equation defining the Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of GaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in the above equation defining the Gaussian waveform.
@end deftypevr
@end deftypevr

@node Differentiated-Gaussian Waveforms
@subsection Differentiated-Gaussian Waveforms

@cindex Gaussian waveforms (differentiated), defining

@deftypevr {Sub-variable of Waveforms} list DifferentiatedGaussianWaveforms
This variable is used to define differentiated Gaussian time waveforms, given by the formula
@anchor{eq:diffgaussian}
@tex
$$
f(t)=A\ {{d^n}\over {dt^n}}\left[\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)\right]
=A\ ({{-1}\over{\tau\,\sqrt{2}}})^{n}H_{n}\left({{t-n_{\tau}\tau}\over{\tau\,\sqrt{2}}}\right)\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*(D^n/Dt^n][exp(-(t-n_tau*tau)^2/2tau^2)]
@end ifnottex

@ifnotinfo
where @math{H_n(x)} are the (physicists') @uref{http://en.wikipedia.org/wiki/Hermite_polynomial#Definition,Hermite polynomials}.
@end ifnotinfo

The peak frequency in the spectrum of the differentiated-Gaussian is
@tex
$\omega=1/\tau$
@end tex
@ifnottex
w=1/tau
@end ifnottex
, the 10%-amplitude (-20 dB power) frequencies are
@tex
$\omega=0.06/\tau$
@end tex
@ifnottex
w=0.06/tau
@end ifnottex
and
@tex
$\omega=2.76/\tau$
@end tex
@ifnottex
w=2.76/tau
@end ifnottex
; and the 1%-amplitude (-40 dB power) frequencies are
@tex
$\omega=0.006/\tau$
@end tex
@ifnottex
w=0.006/tau
@end ifnottex
and
@tex
$\omega=3.57/\tau$
@end tex
@ifnottex
w=3.57/tau
@end ifnottex
.

Differentiated Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    DifferentiatedGaussianWaveforms:
    (
        @{
            waveform_tag = "my_waveform";
            amplitude = 1.0;
            tau = 2.1291e-15;
            delay = 3;
            n_diff = 3;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} string waveform_tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in the above equation defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in the above equation defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in the above equation defining the differentiated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of DifferentiatedGaussianWaveforms} integer n_diff
This specifies the order of differentiation
@tex
$n$
@end tex
@ifnottex
n
@end ifnottex
in the above equation defining the differentiated Gaussian waveform.
@end deftypevr
@end deftypevr

@node Modulated-Gaussian Waveforms
@subsection Modulated-Gaussian Waveforms

@cindex Gaussian waveforms (modulated), defining

@deftypevr {Sub-variable of Waveforms} list ModulatedGaussianWaveforms
This variable is used to define sinusoidally-modulated Gaussian time waveforms, given by the formula
@anchor{eq:modgaussian}
@tex
$$
f(t)=A\ g\big(2\pi f_0 (t-n_{\tau}\tau)+\phi\big)\exp\left({{-(t-n_{\tau}\tau)^{2}}\over{2\tau^{2}}}\right)
$$
@end tex

@ifnottex
f(t)=A*g(2*pi*f_0(t-n_tau\tau)+extra_phase)exp(-(t-n_tau*tau)^2/2tau^2)
@end ifnottex

where the function
@tex
$g(t)$
@end tex
@ifnottex
g(t)
@end ifnottex
is a sinusoidal function, being either
@tex
$\sin(t)$
@end tex
@ifnottex
sin(t)
@end ifnottex
or
@tex
$\cos(t)$
@end tex
@ifnottex
cos(t)
@end ifnottex
.

The peak frequency in the spectrum of the modulated-Gaussian is
@tex
$\omega=\omega_0=2\pi f_0$
@end tex
@ifnottex
w=w_0=2*pi*f_0
@end ifnottex
, the 10%-amplitude (-20 dB power) frequencies are
@tex
$\omega=\omega_0\pm2.15/\tau$
@end tex
@ifnottex
w=w_0 +- 2.15/tau
@end ifnottex
; and the 1%-amplitude (-40 dB power) frequencies are
@tex
$\omega=\omega_0\pm3.035/\tau$
@end tex
@ifnottex
w=w_0 +- 3.035/tau
@end ifnottex
. A MATLAB script named @file{mod_gaussian_wf.m} is distributed as part of the Angora package, which calculates the center frequency
@tex
$f_0$
@end tex
@ifnottex
f_0
@end ifnottex
and the time constant
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
of a modulated-Gaussian waveform that has the desired lower and upper cutoff wavelengths, and the desired amount of attenuation at these wavelengths. It also outputs the -40 dB wavelength and the suggested maximum spatial time step in the simulation (which is the -40 dB wavelength divided by 15). This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}). 

Modulated Gaussian waveforms are defined as follows:

@example
Waveforms:
@{
    ModulatedGaussianWaveforms:
    (
        @{
            waveform_tag = "my_waveform";
            modulation_type = "sine";
            amplitude = 1.0;
            tau = 2.1291e-15;
            f_0 = 5.8929e14;
            delay = 3;
            phase = 90;
            differentiated = false;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of ModulatedGaussianWaveforms} string waveform_tag
This is the string tag by which the waveform will later be referred to by another structure that requires a time waveform in its definition.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} string modulation_type
If assigned @code{"sine"}, the modulation function
@tex
$g(t)$
@end tex
@ifnottex
g(t)
@end ifnottex
in the above equation becomes a sine. If assigned @code{"cosine"}, it becomes a cosine.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point amplitude (default: @code{1.0})
This specifies the variable
@tex
$A$
@end tex
@ifnottex
A
@end ifnottex
in the above equation defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point tau (units: sec)
This specifies the variable
@tex
$\tau$
@end tex
@ifnottex
tau
@end ifnottex
in the above equation defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point f_0 (units: Hz)
This specifies the modulation frequency
@tex
$f_0$
@end tex
@ifnottex
f_0
@end ifnottex
in the above equation defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point delay (default: @code{0.0})
This specifies the variable
@tex
$n_{\tau}$
@end tex
@ifnottex
n_tau
@end ifnottex
in the above equation defining the modulated Gaussian waveform.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} floating-point phase (units: degrees, default: @code{0.0})
This specifies the extra phase
@tex
$\phi$
@end tex
@ifnottex
extra_delay
@end ifnottex
in the above equation defining the modulated Gaussian waveform. This phase should be specified in @emph{degrees}, which is then converted internally to radians, which are the actual units of
@tex
$\phi$
@end tex
@ifnottex
extra_delay
@end ifnottex
.
@end deftypevr
@deftypevr {Sub-variable of ModulatedGaussianWaveforms} boolean differentiated (default: @code{false})
If set to @code{true}, the waveform in the above equation is differentiated once with respect to time.
@end deftypevr

@end deftypevr

@node Point Sources
@section Point Sources

@cindex Point sources, placing
@cindex Hertzian sources, placing
@cindex Infinitesimal sources, placing

@deftypevr {Global variable} list PointSources
"Infinitesimal" electric dipole sources (also called @emph{Hertzian} dipoles) can be simulated in Angora using the @code{PointSources} list.

A Hertzian dipole at position
@tex
$(x_0,y_0,z_0)$
@end tex
@ifnottex
(x0,y0,z0)
@end ifnottex
is characterized by the following current distribution in space:

@tex
$$
J(x,y,z;t)={\bf a}\,j_0(t)\,\delta(x-x_0)\delta(y-y_0)\delta(z-z_0)
$$
@end tex
@ifnottex
J(x,y,z;t)=^a*j0(t)*delta(x-x0)delta(y-y0)delta(z-z0)
@end ifnottex

where
@tex
$\delta(x)$
@end tex
@ifnottex
delta(x)
@end ifnottex
is the Dirac delta function. The vector
@tex
{\bf a}
@end tex
@ifnottex
^a
@end ifnottex
determines the orientation of the dipole, which can be along the x, y, or z directions.
The prefactor
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
is called the @emph{current moment} of the dipole, with the units (Ampere*m).

Here is an example usage of @code{PointSources}:

@example
PointSources:
(
    @{
        coord_x = 0;
        coord_y = 0;
        coord_z = 0;
        source_orientation = "y_directed";
        waveform_tag = "moment_waveform";
        j_0 = 1.0;
    @},
    @{
        @dots{}
        @dots{}
    @}
);
@end example

@deftypevr {Sub-variable of PointSources} floating-point coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of PointSources} floating-point coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of PointSources} floating-point coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of PointSources} integer coord_x_in_cells
@end deftypevr
@deftypevr {Sub-variable of PointSources} integer coord_y_in_cells
@end deftypevr
@deftypevr {Sub-variable of PointSources} integer coord_z_in_cells
These variables specify the Cartesian x, y, and z coordinates of the Hertzian dipole with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinates correspond to non-integer cell positions, the closest integer positions are chosen.
@end deftypevr
@deftypevr {Sub-variable of PointSources} string source_orientation
This string specifies the spatial orientation of the Hertzian dipole. It should be @code{"x_directed"}, @code{"y_directed"}, or @code{"z_directed"}.
@end deftypevr

@deftypevr {Sub-variable of PointSources} string waveform_tag
This string variable specifies the waveform of the current moment
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
. The waveform is interpreted in (Ampere*m) units. This should match a previously-defined tag in a @code{Waveforms} definition (@pxref{Waveforms}).
@end deftypevr
@deftypevr {Sub-variable of PointSources} floating-point j_0 (units: Ampere/m, default: @code{1.0})
This is an extra prefactor applied to the current moment waveform
@tex
$j_0(t)$
@end tex
@ifnottex
j0(t)
@end ifnottex
.
@end deftypevr

@end deftypevr

@node Near-Field-to-Far-Field Transformer
@section Near-Field-to-Far-Field Transformer

@cindex Near-field-to-far-field transformer (NFFFT)

In many electromagnetic problems, it is of interest to calculate the radiated (or far-zone) field scattered from (or radiated by) the structures inside the grid. The radiated field is defined as the asymptotic form of the electric field at large distances, which decays as
@tex
$1/r$
@end tex
@ifnottex
1/r
@end ifnottex
and propagates locally like a plane wave. Although the radial dependence is trivial in the far field, the angular dependence is highly variable. In finite numerical solution methods such as FDTD and FEM, it is only the near-field that is available in the computation grid. It is hugely impractical to extend the computation grid to large distances where the field assumes an asymptotic form. Luckily, certain theorems of electromagnetics (Huygens' principle, equivalence theorem, etc.) allow the calculation of the far field using this near field information. This procedure is called a @strong{near-field-to-far-field transform} (NFFFT). There are two main types of NFFFTs. In the first type, the far-field waveforms are calculated directly in time domain. In the second, the frequency (or phasor) components in the Fourier decomposition of the far-field waveforms are calculated at a number of frequencies. Angora features both time-domain and phasor domain NFFFTs.

@menu
* Time-Domain Near-Field-to-Far-Field-Transformer::    Radiated field time-domain waveforms at a given direction.
* Phasor-Domain Near-Field-to-Far-Field-Transformer::    Phasor components of the radiated field at a range of frequencies.
@end menu

@node Time-Domain Near-Field-to-Far-Field-Transformer
@subsection Time-Domain Near-Field-to-Far-Field-Transformer

@cindex Near-field-to-far-field transformer (NFFFT), time domain

In the @emph{time-domain} NFFFT, the far-field waveforms (normalized by the distance r, and advanced in time by
@tex
$r/c$
@end tex
@ifnottex
r/c
@end ifnottex
) are calculated directly using time-domain Green's functions for the particular space. Currently, the time-domain NFFFT supports up to @emph{three} lossless infinite planar material layers with only permittivity variations.

The time-domain NFFFT should be used when the far-field waveforms are to be computed over only a few observation directions. The additional computational burden per observation direction is much larger than that of the phasor-domain NFFFT. The format used for the time-domain far-field output is @strong{HDF5} (Hierarchical Data Format) (@uref{http://www.hdfgroup.org/HDF5/}). The HDF5 format was chosen for its standard interface, and the availability of free software tools for inspecting and modifying HDF5 output. The HDF5 output created by the time-domain NFFFT is explained in more detail in @ref{HDF5 Content of Time-Domain NFFFT Output}.

The radiated electric field can be expressed in the form
@anchor{eq:far_field_angle_dependence_time_domain}
@tex
$$\bar{E}^{r}(r,\theta,\phi;t) = \bar{E}(\theta,\phi;t-r/c)/r\ .$$
@end tex
@ifnottex

E(r,theta,phi;t) = E(theta,phi;t-r/c)/r

@end ifnottex
The time-domain NFFFT only calculates the @emph{angle and time-dependent} part of the above expression, namely,
@tex
$\bar{E}(\theta,\phi;t)$
@end tex
@ifnottex
E(theta,phi;t)
@end ifnottex
.
@anchor{td_nffft_output_dir}@deftypevr {Global variable} string td_nffft_output_dir (default: @code{"nffft/td"})
This determines the subdirectory in which all the time-domain-NFFFT output will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{output_dir} (@pxref{Paths}).

@example
td_nffft_output_dir = "nffft/td";
TimeDomainNFFFT:
@{
        @dots{}
        @dots{}
@};
@end example
@end deftypevr

@deftypevr {Global variable} list TimeDomainNFFFT

Time-domain NFFFTs are defined inside a @code{TimeDomainNFFFT} list, each within its own group:

@example
TimeDomainNFFFT:
(
    @{
        theta = 36;
        phi = 57;
        write_hertzian_dipole_far_field = false;
        nffft_back_margin_x_in_cells = 3;
        nffft_front_margin_x_in_cells = 3;
        nffft_left_margin_y_in_cells = 3;
        nffft_right_margin_y_in_cells = 3;
        nffft_lower_margin_z_in_cells = 3;
        nffft_upper_margin_z_in_cells = 3;
        far_field_origin_x = 0;
        far_field_origin_y = 0;
        far_field_origin_z = 0;
        far_field_dir = "my_dir";
        far_field_file_name = "FarField_td";
        far_field_file_extension = "hd5";
        append_group_index_to_file_name = true;
    @},
    @{
        @dots{}
        @dots{}
    @}
);
@end example

@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point theta (units: degrees)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point phi (units: degrees)
The direction at which the time-domain far field will be calculated is expressed in terms of the traditional spherical-coordinate variables
@tex
$(\theta,\phi)$.
@end tex
@ifnottex
(theta,phi).
@end ifnottex
The first of these angles is the @emph{zenith angle}, while the second is the @emph{azimuth angle}.
@ifinfo
See printed manual for a graphical illustration of these angles.
@end ifinfo
@ifnotinfo
In @ref{fig:sph_coord,this figure}, the definitions of these angles are shown schematically.
@end ifnotinfo
The @code{theta} variable specifies the zenith angle in degrees. Although this angle is traditionally defined between 0 and 180deg, @code{theta} can be assigned any negative or positive value. The @code{phi} variable specifies the azimuth angle in degrees. Although this angle is traditionally defined between 0 and 360deg, @code{phi} can be assigned any negative or positive value.
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} boolean write_hertzian_dipole_far_field (default: @code{false})
If set to @code{true}, the theoretical far field waveforms due to the Hertzian point sources (see @ref{Point Sources}) in the simulation grid are also written into the output file. Any planar stratification up to three lossless layers with permittivity variations is accounted for in the calculation of the theoretical far field, but the scattering from any other structure inside the grid is ignored. As such, this feature can be (and has been) used to test the time-domain NFFFT.
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_back_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_front_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_left_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_right_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_lower_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point nffft_upper_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_back_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_front_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_left_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_right_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_lower_margin_z_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} integer nffft_upper_margin_z_in_cells (default: @code{3})
The near field is collected over the surface of a rectangular prism in the grid, called the @emph{NFFFT surface}. This surface should enclose all the scattering and/or radiating structures in the grid, as well as the total-field/scattered-field surface (see @ref{Incident Beams}). By default, this rectangular box is placed 3 grid cells away from the PML boundary (see @ref{Perfectly-Matched Layer (PML)}). You can specify different margins to reduce the computational burden associated with the NFFFT. This burden is directly proportional to the surface area of the box. The margins can be specified in meters or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If given in meters, the margins are rounded to the nearest multiple of the spatial step size.
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_x (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_y (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_z (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_x_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_y_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of TimeDomainNFFFT} floating-point far_field_origin_z_in_cells (default: @code{0})
These variables set the coordinates of the point relative to which the far field will be calculated. The distance r in @ref{eq:far_field_angle_dependence_time_domain,the above equation} is with respect to this point. The coordinates of the far-field origin are with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} string far_field_dir (default: @code{""})
This determines the subdirectory in which this individual far-field file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{td_nffft_output_dir} (see @ref{td_nffft_output_dir,@code{td_nffft_output_dir}}). By default, no subdirectory is created inside @code{td_nffft_output_dir}.
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} string far_field_file_name (default: @code{"FarField_td"})
This determines the base string in the full name of the far-field file. Other information is appended to the name of the file to differentiate individual far-field files (see the example below).
@end deftypevr

@deftypevr {Sub-variable of TimeDomainNFFFT} string far_field_file_extension (default: @code{"hd5"})
This is the extension of the far-field file name. If assigned the value @code{""}, no extension is added to the file. The HDF5 extension @code{"hd5"} is applied by default.
@end deftypevr

@anchor{far_field_filename_example_time_domain} Here is an example far-field file name:
@example
FarField_td_0_1.hd5
@end example
The base string in the name of the file (@code{"FarField_td"}) is specified by the @code{far_field_file_name} variable. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the time-domain NFFFT inside the @code{TimeDomainNFFFT} list. For example, if there are two groups (two NFFFTs) in the @code{TimeDomainNFFFT} list, the first one will write into
@example
FarField_td_0_0.hd5
@end example
while the second will write into
@example
FarField_td_0_1.hd5
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"hd5"}) of the line files is determined by the variable @code{far_field_file_extension}.

@deftypevr {Sub-variable of TimeDomainNFFFT} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (time-domain NFFFTs), there will be a name clash, and the output will be undefined.
@end deftypevr

@end deftypevr

@menu
* HDF5 Content of Time-Domain NFFFT Output::    Explanation of the HDF5 content in the time-domain far-field output file.
@end menu

@node HDF5 Content of Time-Domain NFFFT Output
@subsubsection HDF5 Content of Time-Domain NFFFT Output

@cindex Near-field-to-far-field transformer (NFFFT), time domain, HDF5 file content

The HDF5 file created as the output of the time-domain NFFFT can be viewed and modified using freely-available tools. One of these tools is @uref{http://www.hdfgroup.org/hdf-java-html/hdfview/,HDFView}, provided by the HDF Group. MATLAB also has built-in functions and tools that handle HDF5 files. For reference, a MATLAB script named @file{hdf5_read.m} is distributed as part of the Angora package, which reads an HDF5 dataset from an HDF5 file into a MATLAB array. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}). For example, if you want to read the dataset named @code{theta} from the file @file{my_file.hd5}, use
@example
>> theta = hdf5_read('my_file.hd5','theta');
@end example
In MATLAB R2011a and later, there is a high-level built-in function @code{h5read} that could be used for the same purpose.

The HDF5 datasets in the far-field file are the following:

@itemize
@item
@samp{angora_version}:  Integer array of length 3 with the major version, minor version, and revision numbers of the Angora package used to create the file.
@item
@samp{theta}:  A floating-point value for the spherical zenith angle at which the far field is calculated (in radians).
@item
@samp{phi}:  A floating-point value for the spherical azimuth angle at which the far field is calculated (in radians).
@item
@samp{time_step}:  A floating-point value specifying the temporal step in the simulation (in sec).
@item
@samp{initial_time_value}:  A floating-point value specifying the time value corresponding to the beginning of the simulation (in sec). This is usually a negative value, since time waveforms frequently begin before t=0.
@item
Floating-point arrays with the waveforms of different components of the vector radiated electric field.
@ifinfo
See the printed manual for a graphical illustration of the unit vectors in spherical coordinates.
@end ifinfo
@ifnotinfo
See @ref{fig:sph_coord,this figure} for a graphical illustration of the unit vectors in spherical coordinates.
@end ifnotinfo
Note that only the angle and time-dependent part of the radiated electric field is calculated (see @ref{eq:far_field_angle_dependence_time_domain,the above equation}). Because the (1/r) dependence has been factored out, the units are in Volts.
	@itemize
	@samp{E_theta}:  1-D array with the theta component of the radiated electric field.
	@item
	@samp{E_phi}:  1-D array with the phi component of the radiated electric field.
	@end itemize

@item
If the theoretical far field due to Hertzian point sources is also calculated (namely, @code{write_hertzian_dipole_far_field} is @code{true}):
	@itemize
	@samp{E_theta_th}:  1-D array with the @emph{theoretical} theta component of the radiated electric field created by the Hertzian dipoles in the simulation grid.
	@item
	@samp{E_phi_th}:  1-D array with the @emph{theoretical} phi component of the radiated electric field created by the Hertzian dipoles in the simulation grid.
	@end itemize
@end itemize


@node Phasor-Domain Near-Field-to-Far-Field-Transformer
@subsection Phasor-Domain Near-Field-to-Far-Field-Transformer

@cindex Near-field-to-far-field transformer (NFFFT), phasor domain

The @emph{phasor-domain} NFFFT calculates the amplitude of the far field at individual frequencies using Fourier decomposition. This NFFFT supports free space as well as @strong{infinite planar layered media} with arbitrary permittivity, permeability and conductivity profiles (see @ref{Capoglu12}). Infinite planar layers are created using the @code{MaterialSlabs} variable (@pxref{Planar Layers}).

The phasor-domain NFFFT in Angora calculates far-field values over a two-dimensional array of observation directions and a range of wavelengths; resulting in a three-dimensional array. The spacing of the wavelengths and the arrangement of observation directions is highly configurable.
The format used for the phasor-domain far-field output is @strong{HDF5} (Hierarchical Data Format) (@uref{http://www.hdfgroup.org/HDF5/}). The HDF5 format was chosen for its standard interface, and the availability of free software tools for inspecting and modifying HDF5 output. The HDF5 output created by the phasor-domain NFFFT is explained in more detail in @ref{HDF5 Content of Phasor-Domain NFFFT Output}.

Angora uses the engineering convention
@tex
$\exp(j\omega t)$
@end tex
@ifnottex
exp(j*w*t)
@end ifnottex
for time-harmonic quantities. The time-domain data on the surface of a rectangular prism in the grid, called the @emph{NFFFT surface}, is decomposed into its phasor components by a numerical approximation to the temporal Fourier transform
@tex
$F(\omega)={1 \over{2\pi}}\int f(t)\exp(-j\omega t)dt $
@end tex
@ifnottex
F(w) = (1/(2*pi))int f(t)*exp(-j*w*t)dt
@end ifnottex
. Because of the
@tex
${1 \over{2\pi}}$
@end tex
@ifnottex
1/(2*pi)
@end ifnottex
term, the phasor quantities
@tex
$F(\omega)$
@end tex
@ifnottex
F(w)
@end ifnottex
correspond to the true @emph{Fourier components} of the time-domain quantities on the NFFFT surface. These quantities are then inserted into phasor-domain electromagnetic theorems linking the near field to the far field. The complex phasor output data therefore also corresponds to the Fourier components of the far-field temporal waveforms.

In the phasor domain, the radiated electric field can be expressed in the form
@anchor{eq:far_field_angle_dependence}
@tex
$$\bar{E}^{r}(r,\theta,\phi) = \bar{E}(\theta,\phi)\exp(-jkr)/r\ .$$
@end tex
@ifnottex

E(r,theta,phi) = E(theta,phi)exp(-jkr)/r

@end ifnottex
The phasor-domain NFFFT only calculates the @emph{angle-dependent} part of the above expression, namely,
@tex
$\bar{E}(\theta,\phi)$
@end tex
@ifnottex
E(theta,phi)
@end ifnottex
.
@ifinfo
See printed manual for a graphical illustration of spherical coordinates.
@end ifinfo
@ifnotinfo
In @ref{fig:sph_coord,the following figure}, the angles and unit vectors are shown for spherical coordinates.

@float Figure,fig:sph_coord
@center @image{sph_coord,4in}
@caption{The angles and unit vectors for spherical coordinates.}
@end float
@end ifnotinfo

@anchor{pd_nffft_output_dir}@deftypevr {Global variable} string pd_nffft_output_dir (default: @code{"nffft/pd"})
This determines the subdirectory in which all the phasor-domain-NFFFT output will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{output_dir} (@pxref{Paths}).

@example
pd_nffft_output_dir = "nffft/pd";
PhasorDomainNFFFT:
@{
        @dots{}
        @dots{}
@};
@end example
@end deftypevr

@deftypevr {Global variable} list PhasorDomainNFFFT

Phasor-domain NFFFTs are defined inside a @code{PhasorDomainNFFFT} list, each within its own group:

@example
PhasorDomainNFFFT:
(
    @{
        num_of_lambdas = 10;
        lambda_min = 400e-9;
        lambda_max = 700e-9;
        lambda_spacing_type = "k-linear";
        do_not_include_first_lambda = false;
        do_not_include_last_lambda = false;
        direction_spec = "theta-phi";
        num_of_dirs_1 = 9;
        dir1_min=0.0;
        dir1_max=90.0;
        num_of_dirs_2 = 361;
        dir2_min=0.0;
        dir2_max=360.0;
        limit_to_s = 1.0;
        write_hertzian_dipole_far_field = false;
        nffft_back_margin_x_in_cells = 3;
        nffft_front_margin_x_in_cells = 3;
        nffft_left_margin_y_in_cells = 3;
        nffft_right_margin_y_in_cells = 3;
        nffft_lower_margin_z_in_cells = 3;
        nffft_upper_margin_z_in_cells = 3;
        far_field_origin_x = 0.0;
        far_field_origin_y = 0.0;
        far_field_origin_z = 0.0;
        far_field_dir = "my_dir";
        far_field_file_name = "FarField_pd";
        far_field_file_extension = "hd5";
        append_group_index_to_file_name = true;
    @},
    @{
        @dots{}
        @dots{}
    @}
);
@end example

@deftypevr {Sub-variable of PhasorDomainNFFFT} integer num_of_lambdas
This specifies the number of wavelengths (in vacuum) at which the far field will be calculated.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point lambda_min (units: m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point lambda_min_in_cells
This value sets the lower limit of the wavelength range (in vacuum) over which the far field is calculated. The far field may or may not be calculated at the wavelength @code{lambda_min}, depending on the variable @code{do_not_include_first_lambda}. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point lambda_max (units: m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point lambda_max_in_cells
This value sets the upper limit of the wavelength range (in vacuum) over which the far field is calculated. The far field may or may not be calculated at the wavelength @code{lambda_max}, depending on the variable @code{do_not_include_last_lambda}. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} string lambda_spacing_type
This string specifies how the wavelengths will be spaced between the two end points determined by @code{lambda_min}, @code{lambda_max}, @code{do_not_include_first_lambda}, and @code{do_not_include_last_lambda}.
@itemize
@item @code{"lambda-linear"}:  The wavelengths are spaced lineary between the two end points.
@item @code{"k-linear"}:  The wavenumbers
@tex
$k=2\pi/\lambda$
@end tex
@ifnottex
k=2*pi/lambda
@end ifnottex
are spaced linearly between the two end points. Since the wavenumber is also equal to
@tex
$k=\omega/c$
@end tex
@ifnottex
k=w/c
@end ifnottex
, where
@tex
$\omega$
@end tex
@ifnottex
w
@end ifnottex
is the radian frequency, this causes the frequencies to be spaced linearly as well.
@item @code{"log"}:  The logarithms of the wavelengths (therefore the logarithms of the wavenumbers) are spaced linearly between the two end points.
@end itemize
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} boolean do_not_include_first_lambda (default: @code{false})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} boolean do_not_include_last_lambda (default: @code{false})
Let's assume that @code{lambda_spacing_type} is @code{lambda-linear}. For @code{k-linear} and @code{log}, replace @code{lambda_min} in the following by
@tex
$2\pi/$
@end tex
@ifnottex
2*pi/
@end ifnottex
@code{lambda_min} and log(@code{lambda_min}), respectively. The same applies to @code{lambda_max}.

@itemize
@item If @code{do_not_include_first_lambda=false} and @code{do_not_include_last_lambda=false}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{(num_of_lambdas-1)} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, including both endpoints @code{lambda_min} and @code{lambda_max}.
@item If @code{do_not_include_first_lambda=true} and @code{do_not_include_last_lambda=false}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, excluding the endpoint @code{lambda_min}.
@item If @code{do_not_include_first_lambda=false} and @code{do_not_include_last_lambda=true}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, excluding the endpoint @code{lambda_max}.
@item If @code{do_not_include_first_lambda=true} and @code{do_not_include_last_lambda=true}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed at the midpoints of each interval.
@end itemize
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} string direction_spec
This string specifies how the observation directions are arranged in a two-dimensional array.
@itemize
@item @code{"theta-phi"}:  The first dimension is the spherical polar angle
@tex
$\theta$
@end tex
@ifnottex
theta
@end ifnottex
, defined as the angle between the observation direction and the z-axis. The second dimension is the spherical azimuth angle
@tex
$\phi$
@end tex
@ifnottex
phi
@end ifnottex
, defined as the angle between the x-axis and the projection of the observation direction onto the xy-plane.
@ifinfo
See the printed manual for a graphical illustration.
@end ifinfo
@ifnotinfo
See @ref{fig:sph_coord,the above figure} for a graphical illustration.
@end ifnotinfo
These angles are spaced linearly between their respective endpoints.
@item @code{"dircosx-dircosy-upper"} or @code{"dircosx-dircosy-lower"}:  The first dimension is the x-direction-cosine
@tex
$s_x=\sin\theta\cos\phi$
@end tex
@ifnottex
sx = sin(theta)*cos(phi)
@end ifnottex
while the second dimension is the y-direction-cosine
@tex
$s_y=\sin\theta\sin\phi$
@end tex
@ifnottex
sy = sin(theta)*sin(phi)
@end ifnottex
. These direction cosines are spaced linearly between their respective endpoints. The suffix @code{"-upper"} or @code{"-lower"} determines whether the observation direction is in the upper half space (+z direction) or the lower half space (-z direction).
@end itemize
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} integer num_of_dirs_1
This is the number of observation directions over the first dimension of the two-dimensional observation-direction array. If @code{direction_spec} is @code{"theta-phi"}, this is the number of
@tex
$\theta$
@end tex
@ifnottex
theta
@end ifnottex
values; otherwise, the number of x-direction-cosines
@tex
$s_x=\sin\theta\cos\phi$
@end tex
@ifnottex
sx = sin(theta)*cos(phi)
@end ifnottex
.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point dir1_min
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point dir1_max
These are the minimum/maximum values of either the
@tex
$\theta$
@end tex
@ifnottex
theta
@end ifnottex
angle (in degrees), or the x-direction-cosine (between -1 and 1).
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} integer num_of_dirs_2
This is the number of observation directions over the second dimension of the two-dimensional observation-direction array. If @code{direction_spec} is @code{"theta-phi"}, this is the number of
@tex
$\phi$
@end tex
@ifnottex
phi
@end ifnottex
values; otherwise, the number of y-direction-cosines
@tex
$s_y=\sin\theta\sin\phi$
@end tex
@ifnottex
sy = sin(theta)*sin(phi)
@end ifnottex
.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point dir2_min
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point dir2_max
These are the minimum/maximum values of either the
@tex
$\phi$
@end tex
@ifnottex
phi
@end ifnottex
angle (in degrees), or the y-direction-cosine (between -1 and 1).
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point limit_to_s (default: @code{1})
If @code{direction_spec} is @code{"dircosx-dircosy-upper"} or @code{"dircosx-dircosy-lower"} (the direction cosines are used to specify the observation directions), it might happen that some combinations of
@tex
$s_x$
@end tex
@ifnottex
sx
@end ifnottex
and
@tex
$s_y$
@end tex
@ifnottex
sy
@end ifnottex
do not correspond to a real observation direction, since
@tex
$s_x^2+s_y^2>1$
@end tex
@ifnottex
sx^2+sy^2>1
@end ifnottex
. Such direction cosines are automatically assigned a far-field value of zero. If you would like to limit the direction cosines further into a narrower observation cone, you can choose the value of @code{limit_to_s} to be smaller than @code{1.0}. Then, the far field corresponding to the direction cosines satisfying
@tex
$s_x^2+s_y^2>$(limit\_to\_s)
@end tex
@ifnottex
sx^2+sy^2>(limit_to_s)
@end ifnottex
are assigned a zero value. Although this could also be done in post processing, eliminating some observation directions in this way removes the burden of computing them in the first place.
Specifying a @code{limit_to_s} value corresponds to reducing the @emph{numerical aperture} in a microscope objective.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} boolean write_hertzian_dipole_far_field (default: @code{false})
If set to @code{true}, the theoretical far field due to the Hertzian point sources (see @ref{Point Sources}) in the simulation grid is also written into the output file. Any planar stratification is accounted for in the calculation of the theoretical far field, but the scattering from any other structure inside the grid is ignored. As such, this feature can be (and has been) used to test the phasor-domain NFFFT.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_back_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_front_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_left_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_right_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_lower_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point nffft_upper_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_back_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_front_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_left_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_right_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_lower_margin_z_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} integer nffft_upper_margin_z_in_cells (default: @code{3})
The near field is collected over the surface of a rectangular prism in the grid, called the @emph{NFFFT surface}. This surface should enclose all the scattering and/or radiating structures in the grid, as well as the total-field/scattered-field surface (see @ref{Incident Beams}). By default, this rectangular box is placed 3 grid cells away from the PML boundary (see @ref{Perfectly-Matched Layer (PML)}). You can specify different margins to reduce the computational burden associated with the NFFFT. This burden is directly proportional to the surface area of the box. The margins can be specified in meters or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If given in meters, the margins are rounded to the nearest multiple of the spatial step size.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_x (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_y (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_z (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_x_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_y_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PhasorDomainNFFFT} floating-point far_field_origin_z_in_cells (default: @code{0})
These variables set the coordinates of the point relative to which the far field will be calculated. The distance r in @ref{eq:far_field_angle_dependence,the above equation} is with respect to this point. The coordinates of the far-field origin are with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} string far_field_dir (default: @code{""})
This determines the subdirectory in which this individual far-field file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{pd_nffft_output_dir} (see @ref{pd_nffft_output_dir,@code{pd_nffft_output_dir}}). By default, no subdirectory is created inside @code{pd_nffft_output_dir}.
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} string far_field_file_name (default: @code{"FarField_pd"})
This determines the base string in the full name of the far-field file. Other information is appended to the name of the file to differentiate individual far-field files (see the example below).
@end deftypevr

@deftypevr {Sub-variable of PhasorDomainNFFFT} string far_field_file_extension (default: @code{"hd5"})
This is the extension of the far-field file name. If assigned the value @code{""}, no extension is added to the file. The HDF5 extension @code{"hd5"} is applied by default.
@end deftypevr

@anchor{far_field_filename_example} Here is an example far-field file name:
@example
FarField_pd_0_1.hd5
@end example
The base string in the name of the file (@code{"FarField_pd"}) is specified by the @code{far_field_file_name} variable. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the phasor-domain NFFFT inside the @code{PhasorDomainNFFFT} list. For example, if there are two groups (two NFFFTs) in the @code{PhasorDomainNFFFT} list, the first one will write into
@example
FarField_pd_0_0.hd5
@end example
while the second will write into
@example
FarField_pd_0_1.hd5
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"hd5"}) of the line files is determined by the variable @code{far_field_file_extension}.

@deftypevr {Sub-variable of PhasorDomainNFFFT} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (phasor-domain NFFFTs), there will be a name clash, and the output will be undefined.
@end deftypevr

@end deftypevr

@menu
* HDF5 Content of Phasor-Domain NFFFT Output::    Explanation of the HDF5 content in the phasor-domain far-field output file.
@end menu

@node HDF5 Content of Phasor-Domain NFFFT Output
@subsubsection HDF5 Content of Phasor-Domain NFFFT Output

@cindex Near-field-to-far-field transformer (NFFFT), phasor domain, HDF5 file content

The HDF5 file created as the output of the phasor-domain NFFFT can be viewed and modified using freely-available tools. One of these tools is @uref{http://www.hdfgroup.org/hdf-java-html/hdfview/,HDFView}, provided by the HDF Group. MATLAB also has built-in functions and tools that handle HDF5 files. For reference, a MATLAB script named @file{hdf5_read.m} is distributed as part of the Angora package, which reads an HDF5 dataset from an HDF5 file into a MATLAB array. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}). For example, if you want to read the dataset named @code{lambda} from the file @file{my_file.hd5}, use
@example
>> lambda = hdf5_read('my_file.hd5','lambda');
@end example
In MATLAB R2011a and later, there is a high-level built-in function @code{h5read} that could be used for the same purpose.

The HDF5 datasets in the far-field file are the following:

@itemize
@item
@samp{angora_version}:  Integer array of length 3 with the major version, minor version, and revision numbers of the Angora package used to create the file.
@item
@samp{lambda}:  1-D array with the recorded free-space wavelength values (in m).
@item
If @code{direction_spec} is @code{"theta-phi"}:
	@itemize
	@item
	@samp{theta}:  1-D array with the theta values.
	@item
	@samp{phi}:  1-D array with the phi values.
	@end itemize
@item
If @code{direction_spec} is @code{"dircosx-dircosy-upper"} or @code{"dircosx-dircosy-lower"}:
	@itemize
	@item
	@samp{dircos_x}:  1-D array with the x-direction-cosine values.
	@item
	@samp{dircos_y}:  1-D array with the y-direction-cosine values.
	@end itemize
@item
Floating-point arrays with the real and imaginary parts of different components of the vector radiated electric field.
@ifinfo
See the printed manual for a graphical illustration of the unit vectors in spherical coordinates.
@end ifinfo
@ifnotinfo
See @ref{fig:sph_coord,the above figure} for a graphical illustration of the unit vectors in spherical coordinates.
@end ifnotinfo
Note that only the angle-dependent part of the radiated electric field is calculated (see @ref{eq:far_field_angle_dependence,the above equation}). Because the (1/r) dependence has been factored out, the units are in Volts. The first dimension is the wavelength, the second is either theta or the x-direction-cosine, and the third is either phi or the y-direction-cosine.
	@itemize
	@samp{E_theta_r},@samp{E_theta_i}:  3-D arrays with the real and imaginary parts of the theta component of the radiated electric field.
	@item
	@samp{E_phi_r},@samp{E_phi_i}:  3-D arrays with the real and imaginary parts of the phi component of the radiated electric field.
	@end itemize

@item
If the theoretical far field due to Hertzian point sources is also calculated (namely, @code{write_hertzian_dipole_far_field} is @code{true}):
	@itemize
	@samp{E_theta_th_r},@samp{E_theta_th_i}:  3-D arrays with the @emph{theoretical} real and imaginary parts of the theta component of the radiated electric field created by the Hertzian dipoles in the simulation grid.
	@item
	@samp{E_phi_th_r},@samp{E_phi_th_i}:  3-D arrays with the @emph{theoretical} real and imaginary parts of the phi component of the radiated electric field created by the Hertzian dipoles in the simulation grid.
	@end itemize
@end itemize


@node Optical Imaging
@section Optical Imaging

@cindex Optical imaging
@cindex Imaging

Angora can synthesize numerical @strong{optical images} created by an ideal imaging system. The image is calculated in the form of a field distribution on a two-dimensional plane in the image space; which is assumed homogeneous. In photolithography, this image distribution is commonly called an @emph{aerial image}.

The optical axis of the imaging system is currently limited to the z axis. The collection can be either through the +z or -z direction, allowing the simulation of reflection or transmission-mode imaging without changing the illumination scheme.
Angora internally utilizes a near-field-to-far-field transformer (NFFFT) (see @ref{Near-Field-to-Far-Field Transformer}) to calculate the optical image.


@ifinfo
See printed manual for a graphical illustration of the optical imaging geometry.
@end ifinfo
@ifnotinfo
In @ref{fig:opt_imaging,the following figure}, a simplified representation is shown for the optical imaging geometry. The illumination scheme is not shown in the figure, and the collection is assumed to be through the upper half space. The entire optical system is represented by a single lens, although the system may comprise multiple lenses, apertures, stops, etc. The only assumptions regarding the optical system is that it satisfies Abbe's sine condition, and it is telecentric (see @ref{Capoglu12b}). Telecentricity implies that the entrance pupil is actually at infinity, although it is shown at a finite distance for ease of presentation in the figure.

@float Figure,fig:opt_imaging
@center @image{imaging_geometry,3in}
@caption{A simplified depiction of the optical imaging geometry.}
@end float
@end ifnotinfo

The format used for the optical imaging output is @strong{HDF5} (Hierarchical Data Format) (@uref{http://www.hdfgroup.org/HDF5/}). The HDF5 format was chosen for its standard interface, and the availability of free software tools for inspecting and modifying HDF5 output. The HDF5 content of the optical image file is explained in more detail in @ref{Optical Image File HDF5 Content}.


@anchor{imaging_output_dir}@deftypevr {Global variable} string imaging_output_dir (default: @code{"imaging/"})
This determines the subdirectory in which all the optical-imaging output will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{output_dir} (@pxref{Paths}).

@example
imaging_output_dir = "imaging";
OpticalImages:
@{
        @dots{}
        @dots{}
@};
@end example
@end deftypevr

@deftypevr {Global variable} list OpticalImages

Optical images are defined in an @code{OpticalImages} list:

@example
OpticalImages:
(
    @{
        output_data = ["E_x_tot","E_y_tot","E_z_tot",
                       "E_x_sca","E_y_sca","E_z_sca",
                       "E_x_unsca","E_y_unsca","E_z_unsca",
                       "intensity_tot",
                       "intensity_sca",
                       "intensity_unsca"];
        num_of_lambdas = 5;
        lambda_min = 400e-9;
        lambda_max = 700e-9;
        lambda_spacing_type = "k-linear";
        do_not_include_first_lambda = false;
        do_not_include_last_lambda = false;
        ap_half_angle = 36.87;
        magnification = 40.0;
        image_space_refr_index = 1.0;
        image_expansion_factor_x = 1.0;
        image_expansion_factor_y = 1.0;
        image_oversampling_rate_x = 1.0;
        image_oversampling_rate_y = 1.0;
        coll_half_space = "upper";
        nffft_back_margin_x_in_cells = 3;
        nffft_front_margin_x_in_cells = 3;
        nffft_left_margin_y_in_cells = 3;
        nffft_right_margin_y_in_cells = 3;
        nffft_lower_margin_z_in_cells = 3;
        nffft_upper_margin_z_in_cells = 3;
        image_origin_x = 0.0;
        image_origin_y = 0.0;
        image_origin_z = 0.0;
        image_dir = "";
        image_file_name = "Image";
        image_file_extension = "hd5";
        append_group_index_to_file_name = true;
    @},
    @{
        @dots{}
        @dots{}
    @}
);
@end example

@deftypevr {Sub-variable of OpticalImages} string-array output_data
This array of strings determines what will be included in the final output file. Any combination of the following strings can be listed in the array.
@itemize
@item
@code{"E_x_sca"}, @code{"E_y_sca"}, @code{"E_z_sca"}:  The x, y, and z components of the @emph{scattered} electric field of the image. This is the electric field that is scattered or generated by the structures inside the simulation grid. The incident beams (see @ref{Incident Beams}) and the reflections and transmissions from the infinite planar layer interfaces are @emph{not} included in the scattered field.
@item
@code{"E_x_unsca"}, @code{"E_y_unsca"}, @code{"E_z_unsca"}:  The x, y, and z components of the @emph{unscattered} electric field of the image. This is the electric field that would be created at the image plane in the absence of any scatterer inside the simulation grid except the infinite planar layers. The portion of the incident beams (see @ref{Incident Beams}) and the reflections and transmissions from the infinite planar layer interfaces that fall into the collection aperture contribute to the unscattered field.
@item
@code{"E_x_tot"}, @code{"E_y_tot"}, @code{"E_z_tot"}:  The x, y, and z components of the @emph{total} electric field of the image, defined as the sum of the scattered and unscattered fields above.
@item
@code{"intensity_sca"}:  The @emph{scattered} light intensity at the image plane (in W/m^2), defined as
@tex
$I_{sca}=n_{img}|E_{sca}|^2/\eta_0$
@end tex
@ifnottex

I_sca=n_img|E_sca|^2/eta_0

@end ifnottex
where 
@tex
$n_{img}$
@end tex
@ifnottex
n_img
@end ifnottex
is the image-side refractive index, and 
@tex
$\eta_0$
@end tex
@ifnottex
eta_0
@end ifnottex
is the free-space wave impedance (=376.7303...Ohms).
@tex
$E_{sca}$
@end tex
@ifnottex
E_sca
@end ifnottex
is the scattered electric field vector.
@item
@code{"intensity_unsca"}:  The @emph{unscattered} light intensity at the image plane (in W/m^2), defined as
@tex
$I_{unsca}=n_{img}|E_{unsca}|^2/\eta_0$
@end tex
@ifnottex

I_unsca=n_img|E_unsca|^2/eta_0

@end ifnottex
where 
@tex
$n_{img}$
@end tex
@ifnottex
n_img
@end ifnottex
is the image-side refractive index, and 
@tex
$\eta_0$
@end tex
@ifnottex
eta_0
@end ifnottex
is the free-space wave impedance (=376.7303...Ohms).
@tex
$E_{unsca}$
@end tex
@ifnottex
E_unsca
@end ifnottex
is the unscattered electric field vector.
@item
@code{"intensity_tot"}:  The @emph{total} light intensity at the image plane (in W/m^2), defined as
@tex
$I_{tot}=n_{img}|E_{tot}|^2/\eta_0$
@end tex
@ifnottex

I_tot=n_img|E_tot|^2/eta_0

@end ifnottex
where 
@tex
$n_{img}$
@end tex
@ifnottex
n_img
@end ifnottex
is the image-side refractive index, and 
@tex
$\eta_0$
@end tex
@ifnottex
eta_0
@end ifnottex
is the free-space wave impedance (=376.7303...Ohms).
@tex
$E_{tot}$
@end tex
@ifnottex
E_tot
@end ifnottex
is the total electric field vector.
@end itemize

For example, if the @code{output_data} array is
@example
output_data = ["E_x_sca","intensity_tot"];
@end example
then only the x-component of the scattered electric field of the image and the total light intensity of the image are recorded in the output.

@end deftypevr

@deftypevr {Sub-variable of OpticalImages} integer num_of_lambdas
This specifies the number of wavelengths (in vacuum) at which the optical image will be calculated.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point lambda_min (units: m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point lambda_min_in_cells
This value sets the lower limit of the wavelength range (in vacuum) over which the optical image is calculated. The optical image may or may not be calculated at the wavelength @code{lambda_min}, depending on the variable @code{do_not_include_first_lambda}. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point lambda_max (units: m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point lambda_max_in_cells
This value sets the upper limit of the wavelength range (in vacuum) over which the optical image is calculated. The optical image may or may not be calculated at the wavelength @code{lambda_max}, depending on the variable @code{do_not_include_last_lambda}. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} string lambda_spacing_type
This string specifies how the wavelengths will be spaced between the two end points determined by @code{lambda_min}, @code{lambda_max}, @code{do_not_include_first_lambda}, and @code{do_not_include_last_lambda}.
@itemize
@item @code{"lambda-linear"}:  The wavelengths are spaced lineary between the two end points.
@item @code{"k-linear"}:  The wavenumbers
@tex
$k=2\pi/\lambda$
@end tex
@ifnottex
k=2*pi/lambda
@end ifnottex
are spaced linearly between the two end points. Since the wavenumber is also equal to
@tex
$k=\omega/c$
@end tex
@ifnottex
k=w/c
@end ifnottex
, where
@tex
$\omega$
@end tex
@ifnottex
w
@end ifnottex
is the radian frequency, this causes the frequencies to be spaced linearly as well.
@item @code{"log"}:  The logarithms of the wavelengths (therefore the logarithms of the wavenumbers) are spaced linearly between the two end points.
@end itemize
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} boolean do_not_include_first_lambda (default: @code{false})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} boolean do_not_include_last_lambda (default: @code{false})
Let's assume that @code{lambda_spacing_type} is @code{lambda-linear}. For @code{k-linear} and @code{log}, replace @code{lambda_min} in the following by
@tex
$2\pi/$
@end tex
@ifnottex
2*pi/
@end ifnottex
@code{lambda_min} and log(@code{lambda_min}), respectively. The same applies to @code{lambda_max}.

@itemize
@item If @code{do_not_include_first_lambda=false} and @code{do_not_include_last_lambda=false}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{(num_of_lambdas-1)} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, including both endpoints @code{lambda_min} and @code{lambda_max}.
@item If @code{do_not_include_first_lambda=true} and @code{do_not_include_last_lambda=false}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, excluding the endpoint @code{lambda_min}.
@item If @code{do_not_include_first_lambda=false} and @code{do_not_include_last_lambda=true}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed linearly at the boundaries between the intervals, excluding the endpoint @code{lambda_max}.
@item If @code{do_not_include_first_lambda=true} and @code{do_not_include_last_lambda=true}:  The interval between @code{lambda_min} and @code{lambda_max} is divided into @code{num_of_lambdas} equal intervals. A total of @code{num_of_lambdas} wavelengths are placed at the midpoints of each interval.
@end itemize
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point ap_half_angle (units: degrees)
This is the half-angle of the collection cone over which the far field is collected.
@ifinfo
See printed manual for a graphical description of this angle.
@end ifinfo
@ifnotinfo
This angle is represented by
@tex
$\theta_{\rm obj}$
@end tex
@ifnottex
theta_obj
@end ifnottex
in @ref{fig:opt_imaging,the above figure.}
@end ifnotinfo
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point magnification (default: @code{1})
This is the absolute value of the @emph{lateral magnification} of the optical imaging system. If greater than @code{1}, the imaging system shows a magnified image of the object. This is the case in @emph{microscopy}, where the magnification ranges from 10 to 100. If less than @code{1}, the image is a de-magnified version of the object, This is the case in @emph{photolithography}, where a de-magnified image of a mask is projected on a photoresist. Typical magnifications in photolithography are 0.1 to 0.25.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point image_space_refr_index (default: @code{1})
This variable specifies the refractive index of the image space, assumed to be homogeneous.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point image_expansion_factor_x (default: @code{1})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_expansion_factor_y (default: @code{1})
By default, the optical image will only span the lateral (x-y) dimensions of the FDTD grid. The x and y dimensions of the image can be increased or decreased using these two factors. Setting these factors greater than 1 will reduce the aliasing effects in the numerical computation of the image, but linearly increase the computational burden associated with the far-field computation. This is because the far-field has to be collected at a denser set of observation directions for a larger image. The technical details of this are the subject of @emph{sampling theory}, and are explained in @ref{Capoglu12b}.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point image_oversampling_rate_x (default: @code{1})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_oversampling_rate_y (default: @code{1})
Angora tries to automatically determine the minimum number of far-field collection directions to accurately synthesize the optical image. By default, the number of pixels in the final image is the same as the number of far-field collection directions. As a result, the image is sampled very economically; causing a pixelated appearance. A finer image can be synthesized by scaling the sampling rate in the x and y directions by modifying @code{image_oversampling_rate_x} and @code{image_oversampling_rate_y}, respectively. For example, setting @code{image_oversampling_rate_x}=10 results in 10 times the default number of pixels in the x direction. Choosing high values for these two factors do not really cause much degradation in performance, since only the post-processing (post-simulation) computational burden is affected. The post-processing burden is usually a small fraction of the burden associated with the whole simulation.

In sampling theory, the minimum number of pixels needed to represent the image is determined by the @emph{Nyquist sampling rate} for the image (see @ref{Capoglu12b}). There is a well-defined Nyquist sampling rate associated with every optical image, since they are constrained in spatial frequency content by the wavelength of illumination. If desired, the default image (the one obtained with @code{image_oversampling_rate_x}=@code{image_oversampling_rate_y}=1) can be made arbitrarily fine through @emph{bandlimited interpolation} in post-processing.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} string coll_half_space
@ifinfo
The collection apparatus can either be situated in the upper (+z) half space or the lower (-z) half space. This is specified by assigning the string @code{"upper"} or @code{"lower"} to the @code{coll_half_space} variable, respectively.
@end ifinfo
@ifnotinfo
Although the collection apparatus seems to be situated in the upper (+z) half space in @ref{fig:opt_imaging,the above figure}, it can also be situated in the lower (-z) half space. This is specified by assigning the string @code{"upper"} or @code{"lower"} to the @code{coll_half_space} variable, respectively.
@end ifnotinfo
@ifinfo
See printed manual for a graphical explanation of the upper vs. lower collection half space.
@end ifinfo
@ifnotinfo
In @ref{fig:coll_half_space,the following figure}, these two imaging geometries are shown separately. Note that the image is inverted, but the image-space coordinates (x' and y') are also inverted with respect to the object space.

@float Figure,fig:coll_half_space
@center @image{coll_half_space,5in}
@caption{Collection of the scattered light in the upper half space (left figure), or the lower half space (right figure) for the calculation of the optical image.}
@end float
@end ifnotinfo
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point nffft_back_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point nffft_front_margin_x (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point nffft_left_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point nffft_right_margin_y (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point nffft_lower_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point nffft_upper_margin_z (units:m)
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_back_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_front_margin_x_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_left_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_right_margin_y_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_lower_margin_z_in_cells (default: @code{3})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} integer nffft_upper_margin_z_in_cells (default: @code{3})
In the collection stage of optical imaging
@ifinfo
(see figure in printed manual),
@end ifinfo
@ifnotinfo
(see @ref{fig:opt_imaging,the imaging schematic}),
@end ifnotinfo
the far field scattered from the sample is calculated using a near-field-to-far-field transformer (NFFFT). These variables determine the surface over which the near field is collected for the calculation of the far field. For more information, see @ref{Near-Field-to-Far-Field Transformer}.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_x (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_y (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_z (units: m, default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_x_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_y_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} floating-point image_origin_z_in_cells (default: @code{0})
These variables set the coordinates of the optical conjugate of the center of the image plane. Changing these values amounts to focusing at different positions and depths in the sample using the focusing knob on a microscope. The coordinates are with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of OpticalImages} string image_dir (default: @code{""})
This determines the subdirectory in which this individual image file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{imaging_output_dir} (see @ref{imaging_output_dir,@code{imaging_output_dir}}). By default, no subdirectory is created inside @code{imaging_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} string image_file_name (default: @code{"Image"})
This determines the base string in the full name of the image file. Other information is appended to the name of the file to differentiate individual image files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of OpticalImages} string image_file_extension (default: @code{"hd5"})
This is the extension of the image file name. If assigned the value @code{""}, no extension is added to the file.
@end deftypevr
@anchor{image_filename_example} Here is an example image file name:
@example
Image_0_1.hd5
@end example
The base string in the name of the file (@code{"Image"}) is specified by the @code{image_file_name} variable. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the image inside the @code{OpticalImages} list. For example, if there are two groups (two images) in the @code{OpticalImages} list, the first one will write into
@example
Image_0_0.hd5
@end example
while the second will write into
@example
Image_0_1.hd5
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"hd5"}) of the movie files is determined by the variable @code{image_file_extension}.

@deftypevr {Sub-variable of OpticalImages} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (optical images), there will be a name clash, and the output will be undefined.
@end deftypevr


@end deftypevr

@menu
* Optical Image File HDF5 Content::    Explanation of the HDF5 content in the optical image file.
@end menu

@node Optical Image File HDF5 Content
@subsection Optical Image File HDF5 Content

@cindex Optical imaging, HDF5 file content
@cindex Imaging, HDF5 file content

The HDF5 file created as the output of optical imaging can be viewed and modified using freely-available tools. One of these tools is @uref{http://www.hdfgroup.org/hdf-java-html/hdfview/,HDFView}, provided by the HDF Group. MATLAB also has built-in functions and tools that handle HDF5 files. For reference, a MATLAB script named @file{hdf5_read.m} is distributed as part of the Angora package, which reads an HDF5 dataset from an HDF5 file into a MATLAB array. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}). For example, if you want to read the dataset named @code{lambda} from the file @file{my_file.hd5}, use
@example
>> lambda = hdf5_read('my_file.hd5','lambda');
@end example
In MATLAB R2011a and later, there is a high-level built-in function @code{h5read} that could be used for the same purpose.

The HDF5 datasets in the optical image file are the following:

@itemize
@item
@samp{angora_version}:  Integer array of length 3 with the major version, minor version, and revision numbers of the Angora package used to create the file.
@item
@samp{wv_range}:  1-D array with the recorded free-space wavelength values (in m).
@item
@samp{k_range}:  1-D array with the recorded free-space wavenumber values (in 1/m).
@item
@samp{x_range},@samp{y_range}:  1-D arrays with the x and y coordinates of the image (in m).
@item
@samp{n_obj},@samp{n_img}:  Refractive indices of the object and image spaces, respectively.
@item
@samp{magnification}:  Absolute value of the lateral magnification of the imaging system.
@item
@samp{ap_half_angle}:  The half-angle of the collection cone over which the scattered light is collected (in degrees).
@item
@samp{E_x_sca_r},@samp{E_x_sca_i}:  3-D arrays with the real and imaginary parts of the x component of the scattered electric field in the image. (if @code{"E_x_sca"} is included in the array @code{output_data})
@item
@samp{E_x_unsca_r},@samp{E_x_unsca_i}:  3-D arrays with the real and imaginary parts of the x component of the unscattered electric field in the image. (if @code{"E_x_unsca"} is included in the array @code{output_data})
@item
@samp{E_x_tot_r},@samp{E_x_tot_i}:  3-D arrays with the real and imaginary parts of the x component of the total electric field in the image. (if @code{"E_x_tot"} is included in the array @code{output_data})
@item
@samp{E_y_sca_r},@samp{E_y_sca_i}:  3-D arrays with the real and imaginary parts of the y component of the scattered electric field in the image. (if @code{"E_y_sca"} is included in the array @code{output_data})
@item
@samp{E_y_unsca_r},@samp{E_y_unsca_i}:  3-D arrays with the real and imaginary parts of the y component of the unscattered electric field in the image. (if @code{"E_y_unsca"} is included in the array @code{output_data})
@item
@samp{E_y_tot_r},@samp{E_y_tot_i}:  3-D arrays with the real and imaginary parts of the y component of the total electric field in the image. (if @code{"E_y_tot"} is included in the array @code{output_data})
@item
@samp{E_z_sca_r},@samp{E_z_sca_i}:  3-D arrays with the real and imaginary parts of the z component of the scattered electric field in the image. (if @code{"E_z_sca"} is included in the array @code{output_data})
@item
@samp{E_z_unsca_r},@samp{E_z_unsca_i}:  3-D arrays with the real and imaginary parts of the z component of the unscattered electric field in the image. (if @code{"E_z_unsca"} is included in the array @code{output_data})
@item
@samp{E_z_tot_r},@samp{E_z_tot_i}:  3-D arrays with the real and imaginary parts of the z component of the total electric field in the image. (if @code{"E_z_tot"} is included in the array @code{output_data})
@item
@samp{intensity_sca}:  3-D array with the intensity of the scattered light at the image plane (if @code{"intensity_sca"} is included in the array @code{output_data}). See above for the definition of @samp{intensity_sca}.
@item
@samp{intensity_unsca}:  3-D array with the intensity of the unscattered light at the image plane (if @code{"intensity_unsca"} is included in the array @code{output_data}). See above for the definition of @samp{intensity_unsca}.
@item
@samp{intensity_tot}:  3-D array with the intensity of the total light at the image plane (if @code{"intensity_tot"} is included in the array @code{output_data}) See above for the definition of @samp{intensity_tot}.
@item
@end itemize


@node Incident Beams
@section Incident Beams

@cindex Incident beams
@cindex Total-field/scattered-field (TF/SF) boundary

Different types of incident beams can be sourced into the simulation grid using the @code{TFSF} group.

@deftypevr {Global variable} group TFSF
The @code{TFSF} group contains definitions for various types of incident electromagnetic beams required for scattering problems. Angora uses the @emph{total-field/scattered-field} (TF/SF) technique to source incident beams into the simulation grid (see @ref{TafloveHagness}). In this technique, a rectangular surface surrounding the scatterer is designated the total-field/scattered-field boundary (or the @emph{TF/SF box} in short); and the electromagnetic field on this surface is supplemented by certain terms proportional to the incident electromagnetic field. These additional terms create the incident field inside the surface (suggesting the term @emph{injection}), while maintaining a very small electromagnetic field outside the surface. The region outside the TF/SF box only harbors the @emph{scattered field} created by the scatterers inside the TF/SF box. The field inside the box is the @emph{total field}, which is a sum of the incident field and the scattered field. Since the boundary divides the grid into total-field and scattered-field regions, the term "TF/SF boundary" is justified.

TF/SF incident beam injection is supported for @strong{infinite planar layered media}. Infinite planar layers are created using the @code{MaterialSlabs} variable (@pxref{Planar Layers}). Currently, only layers with different permittivities and electrical conductivities are supported. Permeability variations across layers will also be supported in the future. Angora also supports @strong{evanescent plane waves} resulting from plane waves passing from a high-permittivity layer to a low-permittivity one at a low grazing angle. Angora supports evanescent waves only for @emph{narrowband} plane waves, which have appreciable frequency components only in a small band around a center frequency. A modulated Gaussian waveform with a large
@tex
$f_0\tau$
@end tex
@ifnottex
f0*tau
@end ifnottex
can be used as a narrowband waveform in cases where evanescent waves might be present (see @ref{Modulated-Gaussian Waveforms}).

Different types of incident beams are defined in their respective lists inside the @code{TFSF} group. These are explained in the following subsections.

@example
TFSF:
@{
    PlaneWaves:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
    FocusedLaserBeams:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example
@end deftypevr

@menu
* Plane Waves::
* Focused Laser Beams::    Spatially-coherent paraxial laser modes (TEM_mn) focused by an aplanatic converging lens.
@end menu

@node Plane Waves
@subsection Plane Waves

@cindex Plane waves
@cindex Total-field/scattered-field (TF/SF) boundary, plane waves

A plane wave is one of the simplest solutions of Maxwell's equations; with the electric field
@anchor{eq:pw_E_field}
@tex
$$\bar{\bf E}(\bar{\bf r},t) = \hat{\bf e}E_0\,f(t-\bar{\bf r}\cdot \hat{\bf k}^{i}/v_p)$$
@end tex

@ifnottex
E(r,t) = (^e)*E0*f(t-r.ki/vp)
@end ifnottex

where
@tex
$\hat{\bf k}^{i}$
@end tex
@ifnottex
^ki
@end ifnottex
is the unit vector in the direction of propagation,
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
is the electric-field unit vector,
@tex
$E_0$
@end tex
@ifnottex
E0
@end ifnottex
is the electric field amplitude, and
@tex
$\bar{\bf r}$
@end tex
@ifnottex
r
@end ifnottex
is the distance vector. The velocity of propagation
@tex
$v_p$
@end tex
@ifnottex
vp
@end ifnottex
is determined by the material properties in the direction from which the plane wave is incident.
The time waveform
@tex
$f(t)$
@end tex
@ifnottex
f(t)
@end ifnottex
is arbitrary. Inserting the above expression into Maxwell's equations, it is found that the electric-field unit vector
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
is perpendicular to the direction of propagation, as well as the magnetic-field unit vector.

In a discrete FDTD grid, a plane wave propagates at a slightly lower velocity than in continuum. Furthermore, there is an intrinsic grid velocity anisotropy that results from the inherent rotational asymmetry of the rectangular FDTD grid. These are partially alleviated in Angora by the use of the @emph{matched numerical dispersion} (MND) technique (see @ref{TafloveHagness}).

@deftypevr {Sub-variable of TFSF} list PlaneWaves

Plane waves are defined inside a @code{PlaneWaves} list inside the @code{TFSF} group:

@example
TFSF:
@{
    PlaneWaves:
    (
        @{
            theta = 40.0;
            phi = 90.0;
            psi = 90.0;
            waveform_tag = "waveform1";
            pw_extra_amplitude = 1.0;
            tfsf_back_margin_x_in_cells = 6;
            tfsf_front_margin_x_in_cells = 6;
            tfsf_left_margin_y_in_cells = 6;
            tfsf_right_margin_y_in_cells = 6;
            tfsf_lower_margin_z_in_cells = 6;
            tfsf_upper_margin_z_in_cells = 6;
            pw_origin_x = 0.0;
            pw_origin_y = 0.0;
            pw_origin_z = 0.0;
            display_warnings = true;
            min_cells_per_lambda = 15.0;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of PlaneWaves} floating-point theta (units: degrees)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point phi (units: degrees)
The incidence angles of the plane waves are defined in terms of the traditional spherical-coordinate variables
@tex
$(\theta,\phi)$.
@end tex
@ifnottex
(theta,phi).
@end ifnottex
The first of these angles is the @emph{zenith angle}, while the second is the @emph{azimuth angle}.
@ifinfo
See printed manual for a graphical illustration of these angles.
@end ifinfo
@ifnotinfo
In @ref{fig:pw_inc,this figure}, the definitions of these angles are shown schematically.
@end ifnotinfo
The @code{theta} variable specifies the zenith angle in degrees. Although this angle is traditionally defined between 0 and 180deg, @code{theta} can be assigned any negative or positive value. The @code{phi} variable specifies the azimuth angle in degrees. Although this angle is traditionally defined between 0 and 360deg, @code{phi} can be assigned any negative or positive value.

Note that the incidence angles
@tex
$(\theta,\phi)$
@end tex
@ifnottex
(theta,phi)
@end ifnottex
specify the direction @emph{from which the plane wave is incident}; @strong{not} the direction in which it propagates.

@end deftypevr

@deftypevr {Sub-variable of PlaneWaves} floating-point psi (units: degrees)
This variable is used to specify the polarization of the electric field of the incident plane wave. Maxwell's equations dictate that the electric field is @strong{perpendicular} to the incidence vector
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex
In order to define the orientation of the electric vector unambiguously, a local coordinate system
@tex
$(\xi,\eta)$
@end tex
@ifnottex
(xi,eta)
@end ifnottex
is defined, such that
@tex
$\hat{\xi}=\hat{\bf k}^{i}\times \hat{z}$
@end tex
@ifnottex
(^xi)=(^ki) x (^z)
@end ifnottex
and
@tex
$\hat{\eta}=\hat{\xi}\times\hat{\bf k}^{i}$
@end tex
@ifnottex
(^eta)=(^xi) x (^ki)
@end ifnottex
@c the vectors
@c @tex
@c $(\hat{\xi},\hat{\eta},\hat{\bf k}^{i})$
@c @end tex
@c @ifnottex
@c (^xi,^eta,^ki)
@c @end ifnottex
@c form a left-handed triplet.
The unit vectors
@tex
$(\hat{\xi},\hat{\eta})$
@end tex
@ifnottex
(^xi,^eta)
@end ifnottex
are perpendicular to each other, and lie in the plane perpendicular to the incidence vector
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex
The @emph{polarization angle}
@tex
$\psi$
@end tex
@ifnottex
psi
@end ifnottex
of the electric-field unit vector
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
is defined as the left-handed (clockwise) rotation angle around the axis defined by the incidence vector
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex
The variable @code{psi} sets this angle in degrees.

@end deftypevr
@ifnotinfo
@float Figure,fig:pw_inc
@center @image{pw_inc,4in}
@caption{Graphical description of the incidence and polarization angles associated with a plane wave.}
@end float
@end ifnotinfo

@deftypevr {Sub-variable of PlaneWaves} string waveform_tag
This string variable specifies the electric-field waveform
@tex
$f(t)$
@end tex
@ifnottex
f(t)
@end ifnottex
in @ref{eq:pw_E_field,the above equation}. The waveform is interpreted in (Volts/m) units. This should match a previously-defined tag in a @code{Waveforms} definition (@pxref{Waveforms}).
@end deftypevr

@deftypevr {Sub-variable of PlaneWaves} floating-point pw_extra_amplitude (units: V/m, default: @code{1.0})
This variable sets the electric field amplitude
@tex
$E_0$
@end tex
@ifnottex
E0
@end ifnottex
in @ref{eq:pw_E_field,the above equation}.
@end deftypevr

@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_back_margin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_front_margin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_left_margin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_right_margin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_lower_margin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point tfsf_upper_margin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_back_margin_x_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_front_margin_x_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_left_margin_y_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_right_margin_y_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_lower_margin_z_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} integer tfsf_upper_margin_z_in_cells (default: @code{6})
By default, the total-field/scattered-field (TF/SF) surface is placed 6 grid cells away from the PML boundary (see @ref{Perfectly-Matched Layer (PML)}). You can specify different margins to reduce the computational burden associated with the TF/SF operation. This burden is directly proportional to the area of the TF/SF surface. The margins can be specified in meters or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If given in meters, the margins are rounded to the nearest multiple of the spatial step size.
@end deftypevr

@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_x_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_y_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point pw_origin_z_in_cells (default: @code{0})
These variables set the coordinates of the point relative to which the distance
@tex
$\bar{\bf r}$
@end tex
@ifnottex
r
@end ifnottex
is defined in @ref{eq:pw_E_field,the above equation}. The coordinates are with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of PlaneWaves} boolean display_warnings (default: @code{true})
@end deftypevr
@deftypevr {Sub-variable of PlaneWaves} floating-point min_cells_per_lambda (default: @code{15})
The boolean variable @code{display_warnings} enables or disables the printing of warning messages. Currently, a warning is displayed only when there are not enough grid cells per "minimum" wavelength in the excitation waveform. This minimum wavelength is defined to be the one at which the spectrum of the waveform falls to -40dB below its maximum. The number of required grid cells per the minimum wavelength is determined by the @code{min_cells_per_lambda} variable.
@end deftypevr


@end deftypevr

@node Focused Laser Beams
@subsection Focused Laser Beams

@cindex Focused beams
@cindex Focused laser beams
@cindex Focused laser modes
@cindex Focused Hermite-Gaussian beams
@cindex Total-field/scattered-field (TF/SF) boundary, focused laser beams

Angora can synthesize @emph{focused laser beams} created by an aplanatic optical system (i.e., free of spherical aberration and coma) illuminated by a normally-incident @emph{paraxial Hermite-Gaussian laser mode}. The electromagnetic formulation of the focused beam is based on the classic work of Richards and Wolf (see @ref{Richards59}). This formulation is interpreted as a sum of plane waves, and approximated by a finite sum in the FDTD implementation (see @ref{Capoglu08}). It is assumed that the Hermite-Gaussian laser mode filling the entrance pupil of the optical system has a beam width much larger than the wavelength, and is therefore in the paraxial regime. In this regime, the wavefronts are almost planar, perpendicular to the optical axis, and the electric field of the beam has a negligible longitudinal component.

@ifinfo
See the printed manual for a graphical description of the incident laser mode illuminating the entrance pupil of the system.
@end ifinfo
@ifnotinfo
The incidence geometry for the laser mode illuminating the entrance pupil of the system is shown on the upper right in @ref{fig:fb_inc,this figure}.
@end ifnotinfo
A local coordinate system
@tex
$(\xi,\eta)$
@end tex
@ifnottex
(xi,eta)
@end ifnottex
is defined on the plane of the entrance pupil, such that
@tex
$\hat{\xi}=\hat{\bf k}^{i}\times \hat{z}$
@end tex
@ifnottex
(^xi)=(^ki) x (^z)
@end ifnottex
and
@tex
$\hat{\eta}=\hat{\xi}\times\hat{\bf k}^{i}$
@end tex
@ifnottex
(^eta)=(^xi) x (^ki)
@end ifnottex
The unit vectors
@tex
$(\hat{\xi},\hat{\eta})$
@end tex
@ifnottex
(^xi,^eta)
@end ifnottex
are perpendicular to each other, and lie in the plane perpendicular to the incidence vector
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex
The symmetry axes
@tex
$(x^\prime,y^\prime)$
@end tex
@ifnottex
(x',y')
@end ifnottex
of the Hermite-Gaussian beam are rotated at an angle of
@tex
$\alpha$
@end tex
@ifnottex
alpha
@end ifnottex
with respect to the
@tex
$\xi$
@end tex
@ifnottex
xi
@end ifnottex
axis, in a clock-wise (left-handed) sense with respect to
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex

On the plane of the entrance pupil, which is assumed to coincide with the waist of the Hermite-Gaussian beam, the electric field is given by
@anchor{eq:fb_incident_E_field}
@tex
$$\bar{\bf E}(\bar{\bf r},t) = \hat{\bf e}E_0\,f(t)H_m(\sqrt{2}{x^\prime\over w_0})H_n(\sqrt{2}{y^\prime\over w_0})\exp(-{{(x^\prime)^2+(y^\prime)^2} \over w_0^2})$$
@end tex

@ifnottex
E(r,t) = (^e)*E0*f(t)H_m(sqrt(2)*x/w0)H_n(sqrt(2)*y/w0)exp(-(x'^2+y'^2)/w0^2)
@end ifnottex

where
@tex
$w_0$
@end tex
@ifnottex
w0
@end ifnottex
is the beam half width (or beam waist radius),
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
is the electric-field unit vector,
@tex
$E_0$
@end tex
@ifnottex
E0
@end ifnottex
is the electric field amplitude, and
@tex
$H_m(\cdot)$
@end tex
@ifnottex
H_m(x)
@end ifnottex
are the (physicists') @emph{Hermite polynomials} of order m. The first few Hermite polynomials are
@tex
$$H_0(x)=1,\ \ \ H_1(x)=2x, \ \ \ H_2(x)=4x^2-2$$
@end tex
@ifnottex
H_0(x)=1

H_1(x)=2x

H_2(x)=4x^2-2
@end ifnottex
The time waveform
@tex
$f(t)$
@end tex
@ifnottex
f(t)
@end ifnottex
is arbitrary. Since we assume that the width of the beam at the entrance pupil is much larger than the wavelengths contained in the waveform
@tex
$f(t)$,
@end tex
@ifnottex
f(t),
@end ifnottex
it is reasonable to employ the @emph{paraxial} approximation, in which the rays propagate parallel to the optical axis and the electric-field unit vector
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
is perpendicular to the direction of propagation
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex

The focusing optical system between the entrance pupil and the exit pupil is assumed @emph{aplanatic}. This means that, in addition to focusing on-axis points stigmatically (without spherical aberration), the system also correctly focuses off-axis points up to the first order in off-axis distance. The latter condition corresponds to the absence of circular coma. The @emph{sine condition}, first derived by Ernst Abbe in 1881, is an expression of this in mathematical terms. The sine condition reads
@tex
$$h = f\sin(\theta_{\rm ill})$$
@end tex
@ifnottex

h = f*sin(theta_ill)

@end ifnottex
where
@tex
$h$
@end tex
@ifnottex
h
@end ifnottex
is the radius of the entrance pupil, and
@tex
$f$
@end tex
@ifnottex
f
@end ifnottex
is the back focal length of the focusing system.
@ifnotinfo
The sine condition is also shown geometrically in @ref{fig:fb_inc,this figure}.
@end ifnotinfo


@ifnotinfo
@float Figure,fig:fb_inc
@center @image{flb_inc,3.5in}
@caption{Geometry of the focused laser beam.}
@end float
@end ifnotinfo

@deftypevr {Sub-variable of TFSF} list FocusedLaserBeams

Focused laser beams are defined inside a @code{FocusedLaserBeams} list inside the @code{TFSF} group:

@example
TFSF:
@{
    FocusedLaserBeams:
    (
        @{
            theta = 40.0;
            phi = 90.0;
            psi = 90.0;
            alpha = 0;
            x_order = 1;
            y_order = 1;
            waveform_tag = "waveform1";
            flb_extra_amplitude = 1.0;
            ap_half_angle = 23.5782;
            back_focal_length = 0.1;
            filling_factor = 1;
            object_space_refr_index = 1.0;
            tfsf_back_margin_x_in_cells = 6;
            tfsf_front_margin_x_in_cells = 6;
            tfsf_left_margin_y_in_cells = 6;
            tfsf_right_margin_y_in_cells = 6;
            tfsf_lower_margin_z_in_cells = 6;
            tfsf_upper_margin_z_in_cells = 6;
            flb_origin_x = 0.0;
            flb_origin_y = 0.0;
            flb_origin_z = 0.0;
            display_warnings = true;
            min_cells_per_lambda = 15.0;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point theta (units: degrees)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point phi (units: degrees)
The incidence angles for the focused laser beam are defined in reference to the paraxial beam that hits the entrance pupil
@ifinfo
(see printed manual for a graphical illustration).
@end ifinfo
@ifnotinfo
(see @ref{fig:fb_inc,figure}).
@end ifnotinfo
The incidence angles are defined in terms of the traditional spherical-coordinate variables
@tex
$(\theta,\phi)$.
@end tex
@ifnottex
(theta,phi).
@end ifnottex
The first of these angles is the @emph{zenith angle}, while the second is the @emph{azimuth angle}.
The @code{theta} variable specifies the zenith angle in degrees. Although this angle is traditionally defined between 0 and 180deg, @code{theta} can be assigned any negative or positive value. The @code{phi} variable specifies the azimuth angle in degrees. Although this angle is traditionally defined between 0 and 360deg, @code{phi} can be assigned any negative or positive value.

Note that the incidence angles
@tex
$(\theta,\phi)$
@end tex
@ifnottex
(theta,phi)
@end ifnottex
specify the direction @emph{from which the paraxial beam is incident}; @strong{not} the direction in which it propagates.

@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point psi (units: degrees)
This variable is used to specify the polarization of the transverse electric field of the paraxial beam on the entrance pupil. The electric field is perpendicular to the incidence vector
@tex
$\hat{\bf k}^{i}.$
@end tex
@ifnottex
^ki.
@end ifnottex
The @emph{polarization angle}
@tex
$\psi$
@end tex
@ifnottex
psi
@end ifnottex
is defined as the left-handed (clockwise) rotation angle with respect to the incidence vector
@tex
$\hat{\bf k}^{i}$
@end tex
@ifnottex
^ki
@end ifnottex
between the symmetry axis
@tex
$x^\prime$
@end tex
@ifnottex
x'
@end ifnottex
and the electric-field unit vector
@tex
$\hat{\bf e}$
@end tex
@ifnottex
^e
@end ifnottex
@ifnotinfo
(see @ref{fig:fb_inc,figure}).
@end ifnotinfo
@ifinfo
(see illustration in printed manual).
@end ifinfo
The variable @code{psi} sets this angle in degrees.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point alpha (units: degrees) (default: @code{0})
This angle specifies the rotation of the symmetry axes
@tex
$(x^\prime,y^\prime)$
@end tex
@ifnottex
(x',y')
@end ifnottex
of the Hermite-Gaussian beam with respect to the local coordinate axes
@tex
$(\xi,\eta)$.
@end tex
@ifnottex
(xi,eta).
@end ifnottex
The rotation is clock-wise (left-handed) with respect to the incidence vector
@tex
$\hat{\bf k}^{i}$
@end tex
@ifnottex
^ki
@end ifnottex
@ifnotinfo
(see @ref{fig:fb_inc,figure}).
@end ifnotinfo
@ifinfo
(see illustration in printed manual).
@end ifinfo
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} integer x_order
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer y_order
These positive integers specify the orders of the Hermite polynomials
@tex
$H_m(x),H_n(y)$
@end tex
@ifnottex
H_m(x), H_n(y)
@end ifnottex
in the definition of the Hermite-Gaussian beam in @ref{eq:fb_incident_E_field,the above equation}. @code{x_order} and @code{y_order} correspond to m and n, respectively.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} string waveform_tag
This string variable specifies the electric-field waveform
@tex
$f(t)$
@end tex
@ifnottex
f(t)
@end ifnottex
in @ref{eq:fb_incident_E_field,the above equation}, except a time advance
@tex
$t_0$
@end tex
@ifnottex
t0
@end ifnottex
equal to the time of propagation from the entrance pupil to the focal point F. In other words, the actual waveform
@tex
$f(t)$
@end tex
@ifnottex
f(t)
@end ifnottex
on the entrance pupil is advanced in time by
@tex
$t_0$
@end tex
@ifnottex
t0
@end ifnottex
with respect to the waveform represented by @code{waveform_tag}. This is needed because we simulate the fields around the focus F; not the entrance pupil.
The waveform is interpreted in (Volts/m) units. The string @code{waveform_tag} should match a previously-defined string tag in a @code{Waveforms} definition (@pxref{Waveforms}).
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_extra_amplitude (units: V/m, default: @code{1.0})
This variable sets the electric field amplitude
@tex
$E_0$
@end tex
@ifnottex
E0
@end ifnottex
in @ref{eq:fb_incident_E_field,the above equation}.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point ap_half_angle (units: degrees)
This variable sets the half-angle
@tex
$\theta_{\rm ill}$
@end tex
@ifnottex
theta_ill
@end ifnottex
of the illumination cone in degrees
@ifnotinfo
(see @ref{fig:fb_inc,figure}).
@end ifnotinfo
@ifinfo
(see illustration in printed manual).
@end ifinfo

If a planar layered medium is present in the grid (see @ref{Planar Layers}), the incidence cone bounded by the angle
@tex
$\theta_{\rm ill}$
@end tex
@ifnottex
theta_ill
@end ifnottex
should lie @emph{entirely} within the upper or lower half space. In other words, the incidence cone @emph{cannot} cut across the grazing direction
@tex
$(\theta=\pi/2)$
@end tex
@ifnottex
theta=pi/2
@end ifnottex
. Angora will throw an error if this is found to be the case.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point back_focal_length (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point back_focal_length_in_cells
This variable specifies the back focal length
@tex
$f$
@end tex
@ifnottex
f
@end ifnottex
of the optical system. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point filling_factor
This dimensionless parameter represents the ratio between the half-width of the incident paraxial beam and the radius of the entrance pupil. The larger this ratio, the more overfilled the pupil, and vice versa. This parameter is defined as
@tex
$$f_0={w_0 \over {f\sin(\theta_{\rm ill})}}$$
@end tex
@ifnottex

f0 = w_0/(f*sin(theta_ill))

@end ifnottex
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point object_space_refr_index (default: @code{1.0})
This variable specifies the refractive index of the object space of the optical system; i.e., the space from which the paraxial beam is incident. Note that the FDTD simulation grid is in the image space of the optical system; therefore the refractive index of the image space is determined by the material filling the FDTD grid. If you want to simulate an oil immersion scenario, for example, you should fill the FDTD simulation space with the material representing the immersion oil. The object-side refractive index @code{object_space_refr_index} is seldom different than @code{1.0}, which is the default value.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_back_margin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_front_margin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_left_margin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_right_margin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_lower_margin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point tfsf_upper_margin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_back_margin_x_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_front_margin_x_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_left_margin_y_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_right_margin_y_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_lower_margin_z_in_cells (default: @code{6})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} integer tfsf_upper_margin_z_in_cells (default: @code{6})
By default, the total-field/scattered-field (TF/SF) surface is placed 6 grid cells away from the PML boundary (see @ref{Perfectly-Matched Layer (PML)}). You can specify different margins to reduce the computational burden associated with the TF/SF operation. This burden is directly proportional to the area of the TF/SF surface. Because the focused beam is actually a collection of many (often hundreds) of plane waves, the reduction of the surface area of the TF/SF box greatly helps the simulation performance.

The margins can be specified in meters or in grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If given in meters, the margins are rounded to the nearest multiple of the spatial step size.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_x_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_y_in_cells (default: @code{0})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point flb_origin_z_in_cells (default: @code{0})
These variables set the coordinates of the back focal point
@tex
$F$
@end tex
@ifnottex
F
@end ifnottex
of the focusing lens.
@ifinfo
(see printed manual for a graphical illustration).
@end ifinfo
@ifnotinfo
(see @ref{fig:fb_inc,figure}).
@end ifnotinfo
The coordinates are with respect to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name.
@end deftypevr

@deftypevr {Sub-variable of FocusedLaserBeams} boolean display_warnings (default: @code{true})
@end deftypevr
@deftypevr {Sub-variable of FocusedLaserBeams} floating-point min_cells_per_lambda (default: @code{15})
The boolean variable @code{display_warnings} enables or disables the printing of warning messages. Currently, a warning is displayed only when there are not enough grid cells per "minimum" wavelength in the excitation waveform. This minimum wavelength is defined to be the one at which the spectrum of the waveform falls to -40dB below its maximum. The number of required grid cells per the minimum wavelength is determined by the @code{min_cells_per_lambda} variable.
@end deftypevr

@end deftypevr

@node Recording
@section Recording

@cindex Recording

Angora can record field values computed during a simulation into a file in a variety of ways. Field values can be recorded on a cross-section of the grid, along a line through the grid, or at a given point in the grid. Currently, Angora only supports the recording of the electric or the magnetic field. Recording of other field-related quantities such as energy, flux, Poynting's vector, etc. will be implemented in the future. Please send any comments, suggestions, and requests to @email{help@@angorafdtd.org}.

@anchor{recorder_output_dir}@deftypevr {Global variable} string recorder_output_dir (default: @code{"recorder"})
This determines the subdirectory in which all the recording-related stuff will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{output_dir} (@pxref{Paths}).

@example
recorder_output_dir = "recorder";
Recorder:
@{
        @dots{}
        @dots{}
@};
@end example
@end deftypevr

@deftypevr {Global variable} group Recorder
The @code{Recorder} group contains the sub-variables related to different types of field recording. These are explained in the following subsections.

@example
Recorder:
@{
    MovieRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
    LineRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
    FieldValueRecorders:
    (
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example
@end deftypevr

@menu
* Movie Recording::
* Line Recording::
* Field-Value Recording::
@end menu

@node Movie Recording
@subsection Movie Recording

@cindex Recording, movie
@cindex Recording, cross-section

Angora can record field components on a two-dimensional cross section of the grid into a custom movie file. The binary format used for movie recording is described in more detail in @ref{Movie File Format}.

@anchor{movie_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string movie_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded movie files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    movie_recorder_output_dir = "movies";
    MovieRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example
@end deftypevr

@deftypevr {Sub-variable of Recorder} list MovieRecorders

Field values on a two-dimensional cross section of the FDTD grid can be recorded using the @code{MovieRecorders} list.

@example
Recorder:
@{
    MovieRecorders:
    (
        @{
            recorded_section = "xz";
            recorded_position = 0;
            recorded_component = "Ex";
            recording_scale = "dB";
            recording_type = "uchar1";
            movie_dir = "this_movie_dir";
            movie_file_name = "MovieFile"
            movie_file_extension = "amv";
            append_group_index_to_file_name = true;
            only_records_material_info = false;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of MovieRecorders} string recorded_section
This determines the cross section of the grid over which the field is recorded. Currently, only xz, yz, and xy cross sections are supported. These are represented by the string values @code{"xz"}, @code{"yz"}, and @code{"xy"}, respectively.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} floating-point recorded_position (units: m)
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} integer recorded_position_in_cells
This value specifies the coordinate of the recorded cross section along the perpendicular direction (e.g., the z direction if @code{recorded_section} is @code{"xy"}). The coordinate is relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recorded_component
An individual movie recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electromagnetic field. This could be one of the Cartesian components or the absolute value of the electric or the magnetic field. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, @code{"E"}, @code{"Hx"}, @code{"Hy"}, @code{"Hz"}, and @code{"H"}. If you would like to record multiple Cartesian components of a vector field, simply add other movie recorders (i.e., other groups, see @ref{Groups}) to the @code{MovieRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string recording_type
Movies can either be recorded either in raw floating-point format, or in a single-byte compressed format. This is specified by assigning the string values @code{"dbl8"} or @code{"uchar1"} to the @code{recording_type} variable, respectively. Using the single-byte format reduces the file size considerably, but results in some data loss.

If @code{recording_type} is @code{"dbl8"}, then the field values are recorded in 8-byte @code{double} datatype, after processed in accordance with the @code{recording_scale} specification above. This provides practically lossless recording, albeit with increased computational burden and file size.

With the @code{"uchar1"} option, the field values are reduced to 256 discrete bins within a fixed @emph{dynamic range}. This requires only a single byte per field value; reducing the storage requirement by a factor of 8.
@itemize
@item
If @code{recording_type} is @code{"dB"}, the maximum and minimum values in this dynamic range are determined by the global variables @code{max_field_value} and @code{dB_accuracy} (see @ref{Dynamic Range}):
@tex
$${\bf max:\ }20\log_{10}(|{\rm max\_field\_value}|)
\quad {\bf min:\ } 20\log_{10}(|{\rm max\_field\_value}|)+({\rm dB\_accuracy})$$
@end tex

@ifnottex
max:  20*log10(|max_field_value|)

min:  20*log10(|max_field_value|)+(dB_accuracy)
@end ifnottex

The @code{dB_accuracy} variable should always be negative; therefore the minimum value in the dynamic range is lower than the maximum.

@item
If @code{recording_type} is @code{"linear"} or@code{"absolute"}, the maximum and minimum values are determined only by the global variable @code{max_field_value} (see @ref{Dynamic Range}):
@tex
$${\bf max:\ }{\rm max\_field\_value}
\qquad {\bf min:\ } ({\rm -max\_field\_value})\ \  {\rm or }\ \  0$$
@end tex

@ifnottex
max:  max_field_value

min:  (-max_field_value) or 0
@end ifnottex
@end itemize
@end deftypevr

@deftypevr {Sub-variable of MovieRecorders} string movie_dir (default: @code{""})
This determines the subdirectory in which this individual movie file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{movie_recorder_output_dir} (see @ref{movie_recorder_output_dir,@code{movie_recorder_output_dir}}). By default, no subdirectory is created inside @code{movie_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string movie_file_name (default: @code{"MovieFile"})
This determines the base string in the full name of the movie file. Other information is appended to the name of the file to differentiate individual movie files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of MovieRecorders} string movie_file_extension (default: @code{"amv"})
This is the extension of the movie file name. If assigned the value @code{""}, no extension is added to the file.
@end deftypevr
@anchor{movie_filename_example} Here is an example movie file name:
@example
MovieFile_Ex_0_1.amv
@end example
The base string in the name of the file (@code{"MovieFile"}) is specified by the @code{movie_file_name} variable. The second part of the file name, @code{"Ex"}, is determined by the recorded field component. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the movie inside the @code{MovieRecorders} list. For example, if there are two groups (two movies) in the @code{MovieRecorders} list, the first one will write into
@example
MovieFile_Ex_0_0.amv
@end example
while the second will write into
@example
MovieFile_Ex_0_1.amv
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"amv"}) of the movie files is determined by the variable @code{movie_file_extension}.

@deftypevr {Sub-variable of MovieRecorders} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (movie recorders), there will be a name clash, and the output will be undefined.
@end deftypevr

@deftypevr {Sub-variable of MovieRecorders} boolean only_records_material_info (default: @code{false})
If set to @code{true}, only the material information is recorded into the file, and no field recording is performed during the simulation.
@end deftypevr

@end deftypevr

@menu
* Movie File Format::    Custom binary format for the movie output.
@end menu

@node Movie File Format
@subsubsection Movie File Format

@cindex Recording, movie, file format
@cindex Recording, cross-section, file format

Angora records movies in a custom binary format for better speed and performance. Please be aware that this format is subject to modification. The changes in the format will be documented in this manual as necessary. You may refer to the @file{ChangeLog} file in the Angora distribution for recent changes in the movie recording format.

The MATLAB script @file{angora_movie.m}, distributed as part of the Angora package, reads an Angora movie file and displays it as a MATLAB movie. It can also save the movie in AVI format. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}).

The movie file is composed of chunks of data, ordered as follows. For each chunk, a short explanation (and maybe an alias) is given, followed by a description of the datatype in parantheses.

@itemize
@item
major package version (integer, 4 bytes)
@item
minor package version (integer, 4 bytes)
@item
package revision number (integer, 4 bytes)
@item
number of bytes used to record each field component (integer, 4 bytes):  This is either equal to @code{1} or @code{8}, depending on the @code{recording_type} variable.
@item
spatial step size (double, 8 bytes)
@item
temporal step size (double, 8 bytes)
@item
time value that corresponds to the beginning of the simulation (double, 8 bytes):  This is usually a negative value, since time waveforms frequently begin before t=0.
@item
maximum value in the field discretization range (double, 8 bytes):  This is the maximum value in the discretization dynamic range for single-byte recording (i.e., @code{recording_type} is @code{"uchar1"}). If @code{recording_type} is @code{"dbl8"}, this value is irrelevant. Same applies to the next value in the file.
@item
minimum value in the field discretization range (double, 8 bytes)
@item
@samp{length_1}: length along the first dimension of the recorded array (integer, 4 bytes):  If the xy section were recorded, this would be the length of the array in the x dimension. This includes the thickness of the PML sections in both directions.
@item
@samp{length_2}: length along the second dimension of the recorded array (integer, 4 bytes):  If the xy section were recorded, this would be the length of the array in the y dimension. This includes the thickness of the PML sections in both directions.
@item
@samp{length_time}: number of time steps in the simulation (integer, 4 bytes)
@item
thickness of the PML region, in grid cells (integer, 4 bytes):  See @ref{Perfectly-Matched Layer (PML)} for more information on the PML. The PML sections are included in the recorded cross sectional area. They can easily be removed in post-processing.
@item
an array of length @code{length_1} with the actual physical coordinates (in m) along the first dimension of the recorded cross section (double, 8 bytes)
@item
an array of length @code{length_2} with the actual physical coordinates (in m) along the second dimension of the recorded cross section (double, 8 bytes)
@item
an array of length (@code{length_2} x @code{length_1}) holding the relative permittivity (if the electric field is recorded) or the relative permeability (if the magnetic field is recorded) values on the recorded cross section (double, 8 bytes):
@ifinfo
See printed manual for a graphical illustration of the 2D data layout in the movie-file .
@end ifinfo
@ifnotinfo
In @ref{fig:movie_file_layout,this figure}, it is assumed that the xy section is recorded, and the field positions are numbered from 0 to 11. It is seen that the @strong{second dimension} (here, the y-dimension) is looped through first. These positions are laid out in the movie file in the same order:

@cartouche
@example
0  1  2  3  4  5  6  7  8  9  10  11
@end example
@end cartouche

@float Figure,fig:movie_file_layout
@center @image{movie_file_layout,3in}
@caption{The layout of the field positions on the recorded cross section in the movie file.}
@end float
@end ifnotinfo

@item
an array of length (@code{length_2} x @code{length_1}) holding the electric conductivity values (in Siemens/m, if the electric field is recorded) or the magnetic conductivity values (in Ohm/m, if the magnetic field is recorded) on the recorded cross section (double, 8 bytes):  The 2D cross section is laid out in the movie file in the same way as the previous array.

@item
arrays (movie frames) of length (@code{length_2} x @code{length_1}) holding the field values on the recorded cross section (double, 8 bytes OR unsigned char, 1 byte -- depending on @code{recording_type}):  The total number of these movie frames is equal to @code{length_time}, read earlier from the binary file. Each of these frames is laid out in the movie file in the same way as the previous arrays.
@end itemize



@node Line Recording
@subsection Line Recording

@cindex Recording, line

Angora can record field components along a line into a file. The binary format used for line recording is described in more detail in @ref{Line File Format}.

@anchor{line_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string line_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded line files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    line_recorder_output_dir = "lines";
    LineRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example
@end deftypevr

@deftypevr {Sub-variable of Recorder} list LineRecorders

@example
Recorder:
@{
    LineRecorders:
    (
        @{
            line_orientation = "y_directed";
            line_position_x1 = 0;
            line_position_x2 = 0;
            recorded_component = "Ex";
            recording_scale = "linear";
            line_dir = "this_line_dir";
            line_file_name = "LineFile";
            line_file_extension = "aln";
            append_group_index_to_file_name = true;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of LineRecorders} string line_orientation
There are three possible orientations for the line over which the field values are recorded .These orientations are along the three principal axes of the grid; namely, the x,y, and z directions. These are specified by the strings @code{"x_directed"}, @code{"y_directed"}, and @code{"z_directed"}, respectively.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} floating-point line_position_x1 (units: m)
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} integer line_position_x1_in_cells
This is the first of the remaining two coordinates that specify the position of the recorded line. The coordinate is relative to the grid origin (@pxref{Coordinate Origin}). For example, if the line is oriented in the y direction (@code{line_orientation} is @code{"y_directed"}), then @code{line_position_x1_in_cells} specifies the x coordinate of the line. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} floating-point line_position_x2 (units: m)
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} integer line_position_x2_in_cells
This is the second of the remaining two coordinates that specify the position of the recorded line. The coordinate is relative to the grid origin (@pxref{Coordinate Origin}). For example, if the line is oriented in the y direction (@code{line_orientation} is @code{"y_directed"}), then @code{line_position_x2_in_cells} specifies the z coordinate of the line. The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string recorded_component
An individual line recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electromagnetic field. This could be one of the Cartesian components or the absolute value of the electric or the magnetic field. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, @code{"E"}, @code{"Hx"}, @code{"Hy"}, @code{"Hz"}, and @code{"H"}. If you would like to record multiple Cartesian components of a vector field, simply add other line recorders (i.e., other groups, see @ref{Groups}) to the @code{LineRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_dir (default: @code{""})
This determines the subdirectory in which this individual line file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{line_recorder_output_dir} (see @ref{line_recorder_output_dir,@code{line_recorder_output_dir}}). By default, no subdirectory is created inside @code{line_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_file_name (default: @code{"LineFile"})
This determines the base string in the full name of the line file. Other information is appended to the name of the file to differentiate individual line files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of LineRecorders} string line_file_extension (default: @code{"aln"})
This is the extension of the line file name. If assigned the value @code{""}, no extension is added to the file.
@end deftypevr
@anchor{line_filename_example} Here is an example line file name:
@example
LineFile_Ey_Y_0_1.aln
@end example
The base string in the name of the file (@code{"LineFile"}) is specified by the @code{line_file_name} variable. The second part of the file name, @code{"Ey"}, is determined by the recorded field component. The following string @code{"Y"} indicates the orientation of the line, which is y-directed for this example. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the line recorder inside the @code{LineRecorders} list. For example, if there are two groups (two line recorders) in the @code{LineRecorders} list, the first one will write into
@example
LineFile_Ey_Y_0_0.aln
@end example
while the second will write into
@example
LineFile_Ey_Y_0_1.aln
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"aln"}) of the line files is determined by the variable @code{line_file_extension}.
@deftypevr {Sub-variable of LineRecorders} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (line recorders), there will be a name clash, and the output will be undefined.
@end deftypevr

@end deftypevr

@menu
* Line File Format::    Custom binary format for the line-recorder output.
@end menu

@node Line File Format
@subsubsection Line File Format

@cindex Recording, line, file format

As with movies, Angora records the line files in a custom binary format for better speed and performance. Please be aware that this format is subject to modification. The changes in the format will be documented in this manual as necessary. You may refer to the @file{ChangeLog} file in the Angora distribution for recent changes in the line recording format.

The MATLAB script @file{angora_line.m}, distributed as part of the Angora package, reads an Angora line file and displays it as a MATLAB movie. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}).

The line file is composed of chunks of data, ordered as follows. For each chunk, a short explanation (and maybe an alias) is given, followed by a description of the datatype in parantheses.

@itemize
@item
major package version (integer, 4 bytes)
@item
minor package version (integer, 4 bytes)
@item
package revision number (integer, 4 bytes)
@item
temporal step size (double, 8 bytes)
@item
time value that corresponds to the beginning of the simulation (double, 8 bytes):  This is usually a negative value, since time waveforms frequently begin before t=0.
@item
@samp{total_length}: the number of recorded elements on each line snapshot (integer, 4 bytes)
@item
@samp{length_time}: number of time steps in the simulation (integer, 4 bytes)
@item
thickness of the PML region, in grid cells (integer, 4 bytes):  See @ref{Perfectly-Matched Layer (PML)} for more information on the PML. The recorded line includes two PML sections on opposite ends, each with this length. These sections can easily be removed in post-processing.
@item
arrays (line snapshots) of length @code{total_length} holding the field values on the recorded line (double, 8 bytes):  The total number of these line snapshots is equal to @code{length_time}, read earlier from the binary file.
@end itemize


@node Field-Value Recording
@subsection Field-Value Recording

@cindex Recording, field-value

Angora can record the time history of the field at a given position in the simulation grid. The format used for this sort of recording is @strong{HDF5} (Hierarchical Data Format) (@uref{http://www.hdfgroup.org/HDF5/}). The HDF5 format was chosen for its standard interface, and the availability of free software tools for inspecting and modifying HDF5 output. The HDF5 output created by the field-value recorder is explained in more detail in @ref{Field-Value File HDF5 Content}.

@anchor{field_value_recorder_output_dir}@deftypevr {Sub-variable of Recorder} string field_value_recorder_output_dir (default: @code{""})
This determines the subdirectory in which all the recorded field-value files will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{recorder_output_dir} (see @ref{recorder_output_dir,@code{recorder_output_dir}}).

@example
Recorder:
@{
    field_value_recorder_output_dir = "fieldvalues";
    FieldValueRecorders:
    (
        @dots{}
        @dots{}
    );
@};
@end example
@end deftypevr

@deftypevr {Sub-variable of Recorder} list FieldValueRecorders

@example
Recorder:
@{
    FieldValueRecorders:
    (
        @{
            coord_x = 0;
            coord_y = 0;
            coord_z = 0;
            recorded_component = "Ex";
            recording_scale = "linear";
            field_value_dir = "this_field_value_dir";
            field_value_file_name = "FieldValueFile";
            field_value_file_extension = "hd5";
            append_group_index_to_file_name = true;
        @},
        @{
            @dots{}
            @dots{}
        @}
    );
@};
@end example

@deftypevr {Sub-variable of FieldValueRecorders} floating-point coord_x (units: m)
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} integer coord_x_in_cells
This is the x coordinate of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} floating-point coord_y (units: m)
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} integer coord_y_in_cells
This is the y coordinate of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} floating-point coord_z (units: m)
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} integer coord_z_in_cells
This is the z coordinate of the recorded position in the simulation grid. It is relative to the grid origin (@pxref{Coordinate Origin}). The units are either in meters or grid cells. For the latter, the @code{_in_cells} suffix should be appended to the variable name. If the coordinate corresponds to a non-integer cell position, the closest integer position is chosen.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string recorded_component
An individual field-value recorder (in a group delineated by the curly brackets @samp{@{@}}) only records a single scalar value extracted from the vector-valued electromagnetic field. This could be one of the Cartesian components or the absolute value of the electric or the magnetic field. These are represented by the string values @code{"Ex"}, @code{"Ey"}, @code{"Ez"}, @code{"E"}, @code{"Hx"}, @code{"Hy"}, @code{"Hz"}, and @code{"H"}. If you would like to record multiple Cartesian components of a vector field, simply add other field-value recorders (i.e., other groups, see @ref{Groups}) to the @code{FieldValueRecorders} list with the desired @code{recorded_component} values.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string recording_scale
If @code{"linear"}, the raw values are recorded. If @code{"absolute"}, the absolute value is taken before recording. If @code{"dB"}, the decibel value
@tex
$(20\log_{10}(|\cdot|))$
@end tex
@ifnottex
(20*log10(|x|))
@end ifnottex
is recorded.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_dir (default: @code{""})
This determines the subdirectory in which this individual field-value file will be placed. Unless it has a slash @samp{/} up front; this path is interpreted as being relative to @code{field_value_recorder_output_dir} (see @ref{field_value_recorder_output_dir,@code{field_value_recorder_output_dir}}). By default, no subdirectory is created inside @code{field_value_recorder_output_dir}.
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_file_name (default: @code{"FieldValueFile"})
This determines the base string in the full name of the field-value file. Other information is appended to the name of the file to differentiate individual field-value files (see the example below).
@end deftypevr
@deftypevr {Sub-variable of FieldValueRecorders} string field_value_file_extension (default: @code{"hd5"})
This is the extension of the field-value file name. If assigned the value @code{""}, no extension is added to the file. The HDF5 extension @code{"hd5"} is applied by default.
@end deftypevr
@anchor{field_value_filename_example} Here is an example field-value file name:
@example
FieldValueFile_Ex_0_1.hd5
@end example
The base string in the name of the file (@code{"FieldValueFile"}) is specified by the @code{field_value_file_name} variable. The second part of the file name, @code{"Ex"}, is determined by the recorded field component. The two integers that follow are the run index (see @ref{Multiple Simulation Runs}) and the index of the field-value recorder inside the @code{FieldValueRecorders} list. For example, if there are two groups (two field-value recorders) in the @code{FieldValueRecorders} list, the first one will write into
@example
FieldValueFile_Ex_0_0.hd5
@end example
while the second will write into
@example
FieldValueFile_Ex_0_1.hd5
@end example
If there are two simulation runs (i.e., @code{number_of_runs} is equal to 2 -- see @ref{Multiple Simulation Runs}), then the files created in the second run will have @code{1} instead of @code{0} as the first integer in the above file names. Finally, the extension (@code{"hd5"}) of the line files is determined by the variable @code{field_value_file_extension}.
@deftypevr {Sub-variable of FieldValueRecorders} boolean append_group_index_to_file_name (default: @code{true})
If this is set to @code{false}, the second integer in the filename (see above) and the underscore preceding it are not included in the filename. It is set to @code{true} by default. If this variable is set to @code{false} and there are multiple groups (field-value recorders), there will be a name clash, and the output will be undefined.
@end deftypevr

@end deftypevr

@menu
* Field-Value File HDF5 Content::    Explanation of the HDF5 content in the field-value-recorder output file.
@end menu

@node Field-Value File HDF5 Content
@subsubsection Field-Value File HDF5 Content

@cindex Recording, field-value, HDF5 file format

The HDF5 file created as the output of the field-value recorder can be viewed and modified using freely-available tools. One of these tools is @uref{http://www.hdfgroup.org/hdf-java-html/hdfview/,HDFView}, provided by the HDF Group. MATLAB also has built-in functions and tools that handle HDF5 files. For reference, a MATLAB script named @file{angora_fieldvalue.m} is distributed as part of the Angora package, which reads an Angora field-value file and plots the recorded waveform. This script is installed in the directory @file{$(prefix)/share/angora/} (see @ref{Compilation and Installation}). If Angora was installed without any @code{$(prefix)} configuration option, the default location is @file{/usr/local/share/angora/}. This script can also be downloaded directly from the Angora website (link @uref{http://www.angorafdtd.org/scripts.html,here}).

@c The script @file{angora_fieldvalue.m} makes use of another MATLAB script installed in the same directory, @file{hdf5_read.m}, that reads a dataset from an HDF5 file into a MATLAB array.

The HDF5 datasets in the field-value file are the following:

@itemize
@item
@samp{angora_version}:  An integer array of length 3 with the major version, minor version, and revision numbers of the Angora package used to create the file.
@c @item
@c @samp{num_time_steps}:  An integer value specifying the number of time steps in the simulation.
@item
@samp{time_step}:  A floating-point value specifying the temporal step in the simulation (in sec).
@item
@samp{initial_time_value}:  A floating-point value specifying the time value corresponding to the beginning of the simulation (in sec). This is usually a negative value, since time waveforms frequently begin before t=0.
@item
@samp{field_values}:  A 1-D floating-point array with the recorded field values.
@end itemize


@node Paths
@section Paths

@cindex Paths, specifying
@cindex Paths, output
@cindex Paths, input
@cindex Directories, specifying
@cindex Directories, output
@cindex Directories, input

@deftypevr {Global variable} string angora_basepath  (default: @code{"."})
This variable specifies the base directory for all the input-output operations in Angora. If there is no slash @samp{/} in front of the path, it is interpreted as a relative path starting from the working directory (i.e, the one from which Angora is launched.)

Any other input or output directory will be assumed @emph{relative} to @code{angora_basepath}. An overarching exception is when a directory is specified with a slash @samp{/} up front; in which case that directory will be taken as an @emph{absolute path}, and not relative to @code{angora_basepath}.

@end deftypevr
@deftypevr {Global variable} string output_dir  (default: @code{"output"})
This is the base directory for all the output that will result from Angora. It is interpreted as being relative to @code{angora_basepath}, unless it is preceded by a slash @samp{/}. All other output directories are created as subdirectories of this directory.

Example:

@example
angora_basepath = "angora_stuff";
output_dir = "data";
@end example

With these variable assignments, all the output will be written into subdirectories within @file{./angora_stuff/data/}.
@end deftypevr

@deftypevr {Global variable} string input_dir
This is the base directory for all the input that will be read by Angora. It is interpreted as being relative to @code{angora_basepath}, unless it is preceded by a slash @samp{/}. Unless the path to an input file is absolute (i.e., preceded by a slash @samp{/}), it is interpreted as being relative to @code{input_dir}.

Example:

@example
angora_basepath = "angora_stuff";
input_dir = "input_data";
@end example

With these variable assignments, the input base directory becomes @file{./angora_stuff/input_data/}.
@end deftypevr


@node Logging
@section Logging

@cindex Logging
@cindex Log, keeping

You can keep a log of the simulations run by Angora in a log file, which contains several lines of information for each simulation. First, an estimate of the finishing time and duration of the simulation is written into the log entry. The actual finishing time and duration is added to the log entry upon completion of the simulation.

Here is an example entry for a simulation in the log file:

@example
johndoe started Angora on 02/22/12 11:54:36AM
    Estimated to finish on 02/22/12 11:54:42AM
    Estimated duration : 6 seconds.
    Simulation finished on 02/22/12 11:54:42AM
    Elapsed time : 6 seconds.
@end example

@deftypevr {Global variable} boolean enable_logging  (default: @code{"true"})
If set to @samp{true}, Angora will keep a record of the simulations that it runs in a log file. The name of this log file is specified by the @code{log_file_name} variable, and the directory in which this file resides is specified by the @code{log_output_dir} variable.
@end deftypevr

@deftypevr {Global variable} string log_file_name  (default: @code{"angora.log"})
This is the name of the Angora log file. It resides in the  directory specified by the @code{log_output_dir} variable.
@end deftypevr

@deftypevr {Global variable} string log_output_dir  (default: @code{"log"})
This is the directory in which the Angora log file is kept. Unless it is preceded by a slash @samp{/}, it is taken as relative to the base output directory @code{output_dir} (@pxref{Paths}).
@end deftypevr

@node Multiple Simulation Runs
@section Multiple Simulation Runs

@cindex Multiple simulations
@cindex Multiple runs

A number of consecutive Angora simulations can be set up in a single configuration file.

@deftypevr {Global variable} integer number_of_runs  (default: @code{1})
The number of simulation runs is specified by the @code{number_of_runs} variable. The simulation runs (or @emph{runs} for short) are indexed from @code{0} to @code{number_of_runs-1}. You can refer to these indices later in the configuration file for enabling or disabling certain configuration variables for certain runs (@pxref{enabled_for_runs,@code{enabled_for_runs}}).
@end deftypevr

@deftypevr {Global variable} {integer-array} disabled_runs (default: none)
This array of integers (see @ref{Arrays}) lists the run indices for simulations that will be skipped.

Example:

@example
disabled_runs = [1,2,3,4,5];
@end example

If @code{number_of_runs} was @code{7}, the above variable will cause only the simulations with indices @code{0} and @code{6} to be run.

@end deftypevr

@deftypevr {Global variable} {integer-array} disabled_run_range (default: none)
If you would like to disable simulations that correspond to a @emph{range} of run indices, you can use this variable. This has to be an array of integers with only two elements (@pxref{Arrays}). Simulations with run indices between (and including) these two integers will be skipped.

The following variable assignment has the same effect as the one in the previous example:

@example
disabled_run_range = [1,5];
@end example
@end deftypevr

@anchor{enabled_for_runs}@deftypevr {Sub-variable of any group} {integer-array} enabled_for_runs (default: all)
@end deftypevr
@anchor{enabled_for_run_range}@deftypevr {Sub-variable of any group} {integer-array} enabled_for_run_range (default: all)
Certain variables can be @emph{enabled} or @emph{disabled} for any of the simulation runs using the @code{enabled_for_runs} or @code{enabled_for_run_range} arrays. These arrays can be used inside any group structure (see @ref{Groups}) to specify the run indices for which that group is enabled.

The @code{enabled_for_runs} array simply lists the run indices for which the specific group is enabled. For example,

@example
number_of_runs = 4;
PointSources:
(
    @{
        //point source #1
        enabled_for_runs = [0,1,2];
        coord_x_in_cells = 0;
        coord_y_in_cells = 0;
        coord_z_in_cells = 0;
        source_orientation = "x_directed";
        waveform_tag = "waveform1";
    @},
    @{
        //point source #2
        enabled_for_runs = [3];
        coord_x_in_cells = 0;
        coord_y_in_cells = 0;
        coord_z_in_cells = 0;
        source_orientation = "x_directed";
        waveform_tag = "waveform2";
    @}
);
@end example

In this example, each group represents a collection of variable assignments that characterize an individual point source. With the @code{enabled_for_runs} variables set as shown, simulations @code{0}, @code{1}, and @code{2} will be run with the first point source; whereas simulation @code{3} will be run with the second point source.

Alternatively, the @code{enabled_for_run_range} array can be used to specify a range of run indices for which the group is enabled. This should be an integer array of length two. It specifies the lower and upper limits of the range of run indices for the specific group. For example,

@example
number_of_runs = 10;
PointSources:
(
    @{
        enabled_for_run_range = [0,5];
        coord_x_in_cells = 0;
        coord_y_in_cells = 0;
        coord_z_in_cells = 0;
        source_orientation = "x_directed";
        waveform_tag = "waveform1";
    @}
);
@end example

This point source will only be enabled for run indices @code{0}, @code{1}, @code{2}, @code{3}, @code{4}, and @code{5}.

@end deftypevr

@node Miscellaneous
@section Miscellaneous

@menu
* Auto-Saving the Configuration::    Keeping record of the simulation configuration.
@end menu

@node Auto-Saving the Configuration
@subsection Auto-Saving the Configuration

@cindex Configuration, auto-saving

Angora can automatically save a record of every simulation configuration that it processes.

@deftypevr {Global variable} boolean auto_save_cfg  (default: @code{"false"})
If set to @samp{true}, Angora will automatically write every simulation configuration it runs into another configuration file, and save it in the directory specified by @code{cfg_output_dir}. A time/date string is appended to the name of the saved file to differentiate between subsequent executions of the same configuration file.
@end deftypevr

@deftypevr {Global variable} string cfg_output_dir  (default: @code{"cfg"})
This is the directory in which the auto-saved configuration files are placed. Unless it is preceded by a slash @samp{/}, it is taken as relative to the base output directory @code{output_dir} (@pxref{Paths}).
@end deftypevr

@node References
@chapter References

@anchor{Matzler02} [Matzler02]  C. Matzler, "MATLAB Functions for Mie Scattering and Absorption Version 2," [Online]. Available: http://www.iap.unibe.ch/publications/download/199/en/. [Accessed April 2012].

@anchor{Roden00} [Roden00]  J. A. Roden and S. D. Gedney, "Convolution PML (CPML): an efficient FDTD implementation of the CFD-PML for arbitrary media," Microw. Opt. Technol. Lett., vol. 27, pp. 334-9, Dec. 2000.

@anchor{Kuzuoglu96} [Kuzuoglu96]   M. Kuzuoglu and R. Mittra, "Frequency dependence of the constitutive parameters of causal perfectly matched absorbers," IEEE Microwave Guided Wave Lett., vol. 6, pp. 447-449, Dec. 1996.

@anchor{Berenger02} [Berenger02]   J.-P. Berenger,"Numerical reflection from FDTD-PMLs: a comparison of the split PML with the unsplit and CFS PMLs," IEEE Trans. Antennas Propag, vol. 50, pp.258-265, Mar 2002.

@anchor{Rogers09} [Rogers09]   J. D. Rogers, I. R. Capoglu, V. Backman, "Nonscalar elastic light scattering from continuous media in the Born approximation", Optics Letters, vol. 34, no. 12, pp. 1891-1893, 2009.

@anchor{Richards59} [Richards59]   B. Richards and E. Wolf, "Electromagnetic diffraction in optical systems. II. Structure of the image field in an aplanatic system," Proc. Roy. Soc. A, vol. 253, no. 1274, pp.358379, Dec. 1959.

@anchor{Capoglu08} [Capoglu08]   I. R. Capoglu, A. Taflove, and V. Backman, "Generation of an incident focused light pulse in FDTD," Optics Express, vol. 16, no. 23, pp. 19,20819,220, Nov. 2008.

@anchor{Capoglu12} [Capoglu12]   I. R. Capoglu, A. Taflove, V. Backman, "A frequency-domain near-field-to-far-field transform for planar layered media", IEEE Trans. Antennas Propag, vol. 60 No. 04, Apr. 2012.

@anchor{Capoglu12b} [Capoglu12b]   I. R. Capoglu, J. D. Rogers, A. Taflove, V. Backman, "The microscope in a computer:  Image synthesis from three-dimensional full-vector solutions of Maxwells equations at the nanometer scale", Progress in Optics, (to appear in vol. 57, 2012.)

@anchor{TafloveHagness} [TafloveHagness]   A. Taflove and S. C. Hagness (2005). Computational Electrodynamics: The Finite-Difference Time-Domain Method, 3rd ed.. Artech House Publishers. ISBN 1-58053-832-0.

@anchor{Hwang01} [Hwang01]   K.-P. Hwang and A. C. Cangellaris, Effective permittivities for second-order accurate FDTD equations at dielectric interfaces, IEEE Microw. Wireless Compon. Lett., vol. 11, no. 4, pp. 15860, Apr. 2001.

@ifnotinfo
@node List of Figures
@unnumbered List of Figures
@listoffloats Figure
@end ifnotinfo

@node Indices
@unnumbered Indices

@menu
* Configuration Variable Index::    Index of Angora configuration variables.
* Concept Index::    Index of Angora concepts.
@end menu

@node Configuration Variable Index
@unnumberedsec Configuration Variable Index

@printindex vr

@node Concept Index
@unnumberedsec Concept Index

@printindex cp

@bye
